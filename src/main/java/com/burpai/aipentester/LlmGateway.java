package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * Manages LLM client creation, system-prompt loading, persona overlays, and
 * the OpenAI-style tool schema sent to the model on every chat call.
 *
 * <p>Persona payload protocol (matches {@link AgentLoop#runAgent}):
 * <ul>
 *   <li>{@code null} / blank → General mode; base system prompt unchanged</li>
 *   <li>{@code "persona:<Name>"} → base prompt + appended focus-mode block from {@link #BUILT_IN_PERSONAS}</li>
 *   <li>Any other non-blank string → full custom system-prompt replacement</li>
 * </ul>
 */
class LlmGateway {

  // ── Built-in focus personas ───────────────────────────────────────────────

  static final LinkedHashMap<String, String> BUILT_IN_PERSONAS = new LinkedHashMap<>();

  static {
    BUILT_IN_PERSONAS.put("IDOR Focus",
        "## ACTIVE FOCUS MODE: IDOR (Insecure Direct Object Reference)\n\n" +
        "Your SOLE objective this run is to find IDOR vulnerabilities.\n" +
        "- Enumerate every endpoint that references an object by ID (numeric, UUID, slug).\n" +
        "- Use `fuzz_parameter` with location `path` or `query`: try IDs ±1, ±10, 0, -1, random UUIDs, IDs from other authenticated sessions if available.\n" +
        "- For every 200 response, use `search_in_response` to detect PII or data belonging to a different user.\n" +
        "- Test POST/PUT/DELETE endpoints too — attempt to modify or delete objects owned by other users.\n" +
        "- Only call `report_vulnerability` for confirmed IDOR issues.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-IDOR anomaly MUST be added to `additional_findings` in `finish_run` "
        + "as a structured entry — do NOT write them as prose or discard as 'noted for later'. "
        + "Examples: SQL errors (Medium), XSS reflection (Medium/High), missing auth (High), CORS * (Low).\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");

    BUILT_IN_PERSONAS.put("XSS Focus",
        "## ACTIVE FOCUS MODE: Cross-Site Scripting (XSS)\n\n" +
        "Your SOLE objective this run is to find XSS vulnerabilities (Reflected, Stored, DOM).\n" +
        "- Spider every page and identify all user-controlled input vectors: query params, form fields, JSON body keys, custom headers, URL path segments.\n" +
        "- Use `fuzz_parameter` with a full XSS payload set for every input. Key payloads:\n" +
        "  `<script>alert(1)</script>`, `\">`<img src=x onerror=alert(1)>`, `'><svg onload=alert(1)>`,\n" +
        "  `\" onmouseover=\"alert(1)`, `';alert(1)//`, `javascript:alert(1)`, `<details open ontoggle=alert(1)>`\n" +
        "- After `fuzz_parameter`, use `search_in_response` to confirm unencoded reflection in the response body.\n" +
        "- For Stored XSS: after submitting a payload, retrieve the page where data is displayed and search for unencoded payload there.\n" +
        "- Report only confirmed XSS via `report_vulnerability`.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-XSS anomaly you observe MUST be added to `additional_findings` in `finish_run` " +
        "as a structured entry. Do NOT discard them as 'noted for later'. Examples:\n" +
        "  • A 500 response body containing 'SQLITE_ERROR' or 'syntax error' → severity=Medium, name='Potential SQL Injection Indicator'\n" +
        "  • Missing Content-Security-Policy header → severity=Low, name='Missing CSP Header'\n" +
        "  • Access-Control-Allow-Origin: * → severity=Low, name='Permissive CORS Policy'\n" +
        "  • Any unexpected auth bypass, information disclosure, or server error → severity as appropriate\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");

    BUILT_IN_PERSONAS.put("SQL Injection Focus",
        "## ACTIVE FOCUS MODE: SQL Injection\n\n" +
        "Your SOLE objective this run is to find SQL Injection vulnerabilities.\n" +
        "- Test EVERY string/integer parameter, header value (User-Agent, Referer, X-Forwarded-For), path segment, and JSON field.\n" +
        "- Use `fuzz_parameter` with: `'`, `''`, `1' AND 1=1--`, `1' AND 1=2--`, `1' AND SLEEP(3)--`,\n" +
        "  `1' AND pg_sleep(3)--`, `1'; WAITFOR DELAY '0:0:3'--`, `1' UNION SELECT null--`,\n" +
        "  `1' AND extractvalue(1,concat(0x7e,version()))--`, `1 OR 1=1`.\n" +
        "- Compare baseline vs fuzz `interesting_results` for length changes and error keywords.\n" +
        "- For time-based blind: confirm with a second request targeting the same parameter.\n" +
        "- Try second-order injection: store a payload, then trigger it via a different endpoint.\n" +
        "- Report only confirmed SQLi via `report_vulnerability`.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-SQLi anomaly MUST be added to `additional_findings` in `finish_run` "
        + "as a structured entry. Examples: XSS reflection (Medium/High), CORS * (Low), "
        + "missing security headers (Low), unexpected 401 bypass (High).\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");

    BUILT_IN_PERSONAS.put("SSRF Focus",
        "## ACTIVE FOCUS MODE: Server-Side Request Forgery (SSRF)\n\n" +
        "Your SOLE objective this run is to find SSRF vulnerabilities.\n" +
        "- Identify all parameters that accept URLs or hostnames: `url=`, `endpoint=`, `webhook=`, `redirect=`,\n" +
        "  `callback=`, `target=`, `src=`, `href=`, `path=`, `file=`, `uri=`, `dest=`.\n" +
        "- Use `fuzz_parameter` with SSRF payloads:\n" +
        "  `http://169.254.169.254/latest/meta-data/`, `http://127.0.0.1:22`, `http://127.0.0.1:6379`,\n" +
        "  `http://0.0.0.0/`, `http://[::]:80/`, `http://localhost/admin`, `http://10.0.0.1/`,\n" +
        "  `http://192.168.0.1/`, `file:///etc/passwd`.\n" +
        "- Use `search_in_response` to detect internal content (AMI IDs, SSH banners, Redis PONG, file content).\n" +
        "- Test POST body, JSON fields, XML entities, and custom headers for SSRF as well.\n" +
        "- Report only confirmed SSRF via `report_vulnerability`.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-SSRF anomaly MUST be added to `additional_findings` in `finish_run` "
        + "as a structured entry. Examples: open redirects (Medium), SQL errors (Medium), "
        + "information disclosure in error pages (Low/Medium).\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");

    BUILT_IN_PERSONAS.put("Auth & Session Focus",
        "## ACTIVE FOCUS MODE: Authentication & Session Management\n\n" +
        "Your SOLE objective this run is to find authentication and session vulnerabilities.\n" +
        "- Decode every JWT immediately with `decode_encode` (`jwt_decode`). Check `alg`, `exp`, custom claims.\n" +
        "- Test alg:none attack, HS256/RS256 confusion, weak HMAC secrets (`secret`, `password`, app name).\n" +
        "- Try `kid` injection: `\"kid\": \"../../dev/null\"` (sign with empty string).\n" +
        "- Check session cookies for Secure, HttpOnly, SameSite flags via `search_in_response`.\n" +
        "- Test CSRF: submit state-changing requests without CSRF tokens and check if they succeed.\n" +
        "- Test password reset flows for token predictability, token reuse, and host header injection.\n" +
        "- Use `fuzz_parameter` on login endpoints for credential stuffing and account enumeration (different error messages).\n" +
        "- Report only confirmed auth/session issues via `report_vulnerability`.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-auth anomaly MUST be added to `additional_findings` in `finish_run` "
        + "as a structured entry. Examples: SQL errors in login (High), XSS in error pages (Medium), "
        + "verbose stack traces (Low), CORS * on authenticated endpoints (Medium).\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");

    BUILT_IN_PERSONAS.put("LLM Prompt Injection Focus",
        "## ACTIVE FOCUS MODE: LLM / Prompt Injection\n\n" +
        "Your SOLE objective this run is to find LLM and Prompt Injection vulnerabilities.\n" +
        "Follow the LLM / PROMPT INJECTION section of the playbook above meticulously:\n" +
        "- Step 1: Identify every LLM-backed endpoint via spidering and header/response analysis.\n" +
        "- Step 2: Direct Prompt Injection — use `fuzz_parameter` on all text fields with all listed payloads.\n" +
        "- Step 3: System Prompt Leakage — try every listed disclosure probe.\n" +
        "- Step 4: Indirect Prompt Injection — supply attacker-controlled URLs/documents with injection payloads.\n" +
        "- Step 5: Sensitive Data Exfiltration — try all listed exfiltration prompts.\n" +
        "- Confirm injection by using `search_in_response` to look for system prompt fragments or compliance with injected instruction.\n" +
        "- Report only confirmed LLM injection findings via `report_vulnerability`.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-LLM anomaly MUST be added to `additional_findings` in `finish_run` " +
        "as a structured entry. Examples: reflected input in non-AI endpoints (XSS/Medium), " +
        "verbose error pages (Low), CORS * (Low).\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");

    BUILT_IN_PERSONAS.put("Business Logic Focus",
        "## ACTIVE FOCUS MODE: Business Logic Vulnerabilities\n\n" +
        "Your SOLE objective this run is to find business logic flaws — weaknesses in the application's intended workflow that an attacker can abuse without exploiting a technical injection or memory issue.\n\n" +
        "## ATTACK CATEGORIES TO TEST\n\n" +
        "### 1. Price & Quantity Manipulation\n" +
        "- Identify any order/cart/checkout flow. Submit items with: `quantity=-1`, `quantity=0`, `price=0.01`, `price=-1`, `discount=100`.\n" +
        "- Use `fuzz_parameter` on numeric fields with: `-1`, `0`, `0.001`, `999999`, `9999999999`, `-9999`.\n" +
        "- Check if the server recalculates totals server-side or trusts the client-submitted price/total.\n" +
        "- Confirm exploit: a negative price that results in a negative total or free checkout = Critical.\n\n" +
        "### 2. Workflow Step Skipping\n" +
        "- Map the full multi-step flow (e.g. add-to-cart → shipping → payment → confirm). Identify required sequential steps.\n" +
        "- Attempt to call later steps directly without completing earlier ones (e.g. POST /checkout/confirm without POST /checkout/payment).\n" +
        "- Try replaying a completed-step request to skip re-validation (e.g. reuse a payment confirmation token).\n\n" +
        "### 3. Coupon & Discount Abuse\n" +
        "- Apply the same coupon code multiple times in the same session and across requests.\n" +
        "- Stack multiple discount codes simultaneously.\n" +
        "- Apply a coupon after the order total is set to see if it recalculates.\n" +
        "- Try expired, invalid, or other users' coupon codes.\n\n" +
        "### 4. Race Conditions\n" +
        "- Identify single-use resources: coupon redemptions, loyalty points, referral bonuses, limited-stock items.\n" +
        "- Use `execute_http_request` to probe the endpoint first, then reason about whether a simultaneous burst of the same request could produce inconsistent state.\n" +
        "- Note endpoints where a race condition is plausible as a Medium finding in `additional_findings`.\n\n" +
        "### 5. Negative Balance / Wallet Abuse\n" +
        "- Look for wallet, credit, or refund endpoints. Attempt to refund more than the original purchase amount.\n" +
        "- Try transferring a negative balance to another account.\n" +
        "- Submit a refund on an already-refunded order.\n\n" +
        "### 6. Privilege Escalation via Role Parameters\n" +
        "- Look for `role`, `isAdmin`, `userType`, `plan`, `tier`, or similar fields in request bodies or JSON.\n" +
        "- Attempt to set these to elevated values (`admin`, `true`, `1`, `premium`) in POST/PUT requests.\n" +
        "- Check if the server accepts and honours the client-supplied role.\n\n" +
        "### 7. Mass Assignment\n" +
        "- For every POST/PUT that creates or updates a resource, add extra fields not present in the original request: `id`, `role`, `isAdmin`, `balance`, `credit`, `verified`.\n" +
        "- Use `search_in_response` on the subsequent GET to check if the extra fields were persisted.\n\n" +
        "### 8. Limit & Quota Bypass\n" +
        "- Identify rate-limited or capped actions (file upload size, API call quota, max order quantity).\n" +
        "- Try chunked uploads, boundary values (limit+1), or repeated requests to push past caps.\n\n" +
        "## REPORTING RULES\n" +
        "- Call `report_vulnerability` only for confirmed exploitable business logic flaws.\n" +
        "- Severity guide: free/negative checkout = Critical; workflow bypass = High; coupon stacking = Medium; race condition indicator = Medium; mass-assignment persisted = High.\n" +
        "- INCIDENTAL FINDINGS RULE: Any non-business-logic anomaly MUST be added to `additional_findings` in `finish_run` as a structured entry. " +
        "Examples: SQL errors (Medium), XSS reflection (Medium/High), CORS * (Low), missing auth on admin endpoint (Critical).\n" +
        "- Always end the run by calling `finish_run`. Never write a plain-text conclusion.\n");
  }

  // ── Fallback system prompt ────────────────────────────────────────────────

  private static final String FALLBACK_SYSTEM_PROMPT =
      "You are an autonomous penetration testing agent inside Burp Suite.\n" +
      "\nTOOLS AND WHEN TO USE THEM:\n" +
      "- execute_http_request   : send every HTTP request to the target\n" +
      "- get_sitemap            : query Burp site map + proxy history for already-seen URLs — call this FIRST before any reconnaissance\n" +
      "- spider_links           : call IMMEDIATELY after any baseline request to get all links, form actions, JS API calls, input names\n" +
      "- search_in_response     : search a stored response body by regex (use instead of re-fetching a page to find one value)\n" +
      "- extract_from_response  : extract a value (CSRF token, nonce) from response and save as {{var_name}} for reuse\n" +
      "- set_variable / get_variable : manually store/retrieve named values across iterations\n" +
      "- fuzz_parameter         : send a BATCH of payloads into one parameter — use for ALL injection testing (SQLi, XSS, CMDi, SSTI, SSRF). Do NOT loop individual payloads with execute_http_request.\n" +
      "- decode_encode          : locally decode/encode (jwt_decode, base64_decode, url_decode, hex_decode, etc.) — no HTTP request needed\n" +
      "- generate_oob_payload   : generate a Burp Collaborator OOB domain for blind injection detection (blind SQLi, SSRF, XXE, XSS). Returns ready-to-use payloads for DNS/HTTP/Gopher.\n" +
      "- poll_collaborator      : poll the Collaborator server for OOB callbacks. A DNS/HTTP callback confirms a blind vulnerability.\n" +
      "- report_vulnerability   : report a confirmed vulnerability with evidence_request_ids\n" +
      "- finish_run             : call when ALL testing is done. The loop terminates immediately. ALWAYS use this instead of writing plain text conclusions.\n" +
      "  → 'summary' (required): comprehensive text summary of what was tested and found.\n" +
      "  → 'additional_findings' (required array): EVERY Medium/Low/Informational observation goes here as a structured object — \"\n" +
      "    {name, severity, location, description, remediation}. This is how they appear in the HTML report.\n" +
      "    Do NOT omit findings just because they were not confirmed with a PoC. If you observed it, include it.\n" +
      "Use {{var_name}} in any url or body to interpolate a stored variable.\n" +
      "\nRULES:\n" +
      "- spider_links after every baseline. fuzz_parameter for injection testing. decode_encode for any token inspection.\n" +
      "- OOB WORKFLOW: call generate_oob_payload → embed oob_domain in blind-injection payload → call poll_collaborator after 5-10 s to detect DNS/HTTP callback.\n" +
      "- WAF BYPASS: if fuzz_parameter returns waf_bypass_variants, retry fuzz_parameter with those encoded variants immediately.\n" +
      "- VARIABLE CHAINING: stored_vars in STATE_SIGNALS lists ALL active variables — use them via {{var_name}}. Do NOT re-extract variables already listed there.\n" +
      "- Actively read ALL data returned by tools: status, headers, cookies, body, timing.\n" +
      "- Never invent or assume response content not present in tool output.\n" +
      "- Validate before reporting; then call report_vulnerability with evidence_request_ids.\n" +
      "- Never spam report_vulnerability.\n" +
      "- When all test vectors are exhausted, call finish_run — NEVER write a plain-text final summary without a tool call.\n" +
      "- TASK FOCUS: If the task specifies a single vulnerability class (e.g. 'find SSRF'), ONLY call report_vulnerability for that class. Any other observations go into finish_run additional_findings — NOT into the summary text.\n";

  // ── Instance ──────────────────────────────────────────────────────────────

  private final MontoyaApi api;
  private final AgentLogger logger;
  private final String systemPromptText;

  LlmGateway(MontoyaApi api, AgentLogger logger) {
    this.api = api;
    this.logger = logger;
    this.systemPromptText = loadSystemPrompt();
  }

  // ── Prompt loading ────────────────────────────────────────────────────────

  private String loadSystemPrompt() {
    try (InputStream is = getClass().getResourceAsStream("/burp-ai-agent-prompt.md")) {
      if (is != null) {
        String text = new String(is.readAllBytes(), StandardCharsets.UTF_8);
        api.logging().logToOutput(
            "[LlmGateway] Loaded system prompt from classpath (" + text.length() + " chars).");
        return text;
      }
    } catch (Exception e) {
      api.logging().logToError("[LlmGateway] Failed to load system prompt: " + e);
    }
    api.logging().logToOutput("[LlmGateway] Using built-in fallback system prompt.");
    return FALLBACK_SYSTEM_PROMPT;
  }

  String systemPromptText() {
    return systemPromptText;
  }

  /**
   * Builds the effective system prompt based on the persona payload.
   *
   * @param personaPayload see class-level javadoc for the protocol
   */
  String buildEffectiveSystemPrompt(String personaPayload) {
    if (personaPayload == null || personaPayload.isBlank()) {
      return systemPromptText;
    }
    if (personaPayload.startsWith("persona:")) {
      String key = personaPayload.substring(8);
      String overlay = BUILT_IN_PERSONAS.get(key);
      if (overlay == null || overlay.isBlank()) {
        api.logging().logToOutput(
            "[LlmGateway] Unknown built-in persona key '" + key + "', using base prompt.");
        return systemPromptText;
      }
      api.logging().logToOutput("[LlmGateway] Applying built-in persona: " + key);
      return systemPromptText + "\n\n---\n\n" + overlay;
    }
    api.logging().logToOutput(
        "[LlmGateway] Using custom persona/system prompt (" + personaPayload.length() + " chars).");
    return personaPayload;
  }

  // ── Client factory ────────────────────────────────────────────────────────

  /** Creates the appropriate {@link LlmClient} for the given provider. */
  LlmClient createClient(String provider, String baseUrl, String model, String apiKey) {
    if ("gemini".equalsIgnoreCase(provider)) {
      return new GeminiClient(model, apiKey, api.logging());
    }
    if ("openrouter".equalsIgnoreCase(provider)) {
      return new OpenRouterClient(model, apiKey, api.logging());
    }
    if ("deepseek".equalsIgnoreCase(provider)) {
      return new DeepSeekClient(model, apiKey, api.logging());
    }
    return new OllamaClient(baseUrl, model, api.logging());
  }

  /** Tests the connection to the LLM and writes results via the logger. */
  void testConnection(String provider, String baseUrl, String model, String apiKey) {
    boolean isApiKeyProvider = "gemini".equalsIgnoreCase(provider)
        || "openrouter".equalsIgnoreCase(provider)
        || "deepseek".equalsIgnoreCase(provider);
    logger.log("\n[DEBUG] Testing connection to: "
        + (isApiKeyProvider ? provider.toUpperCase() + " API" : baseUrl)
        + " with model: " + model + "\n");
    api.logging().logToOutput("[LlmGateway] testConnection() entered");
    try {
      LlmClient client = createClient(provider, baseUrl, model, apiKey);
      api.logging().logToOutput("[LlmGateway] Calling client.testConnection()...");
      var res = client.testConnection();
      logger.log("\n" + "=".repeat(60) + "\n");
      logger.log("CONNECTION TEST RESULT\n");
      logger.log("Provider: " + provider + "\n");
      if (!isApiKeyProvider) logger.log("URL: " + baseUrl + "\n");
      logger.log("Model: " + model + "\n");
      logger.log(res.ok ? "[SUCCESS] " : "[FAILED] ");
      logger.log(res.message + "\n");
      logger.log("=".repeat(60) + "\n\n");
    } catch (Throwable t) {
      String msg = t.getMessage();
      if (msg == null || msg.isBlank()) msg = String.valueOf(t);
      logger.log("[ERROR] Connection test crashed: " + t.getClass().getName() + ": " + msg + "\n");
      api.logging().logToError("testConnection crashed: " + t);
    } finally {
      api.logging().logToOutput("[LlmGateway] testConnection() exiting");
    }
  }

  // ── Tool schema ───────────────────────────────────────────────────────────

  /** Returns the OpenAI-style tool definitions sent to the LLM on every chat call. */
  static List<Map<String, Object>> toolSchema() {
    Map<String, Object> exec = new HashMap<>();
    exec.put("type", "function");
    exec.put("function", Map.of(
        "name", "execute_http_request",
        "description", "Send an HTTP request via Burp.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "method", Map.of("type", "string"),
                "url", Map.of("type", "string"),
                "headers", Map.of("type", "object"),
                "body", Map.of("type", "string"),
                "purpose", Map.of("type", "string"),
                "expected", Map.of("type", "string")),
            "required", List.of("method", "url", "purpose", "expected"))));

    Map<String, Object> rep = new HashMap<>();
    rep.put("type", "function");
    rep.put("function", Map.of(
        "name", "report_vulnerability",
        "description", "Report a confirmed vulnerability.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "name", Map.of("type", "string"),
                "severity", Map.of("type", "string"),
                "location", Map.of("type", "string"),
                "description", Map.of("type", "string"),
                "impact", Map.of("type", "string"),
                "poc", Map.of("type", "string"),
                "evidence_request_ids", Map.of("type", "array", "items", Map.of("type", "integer")),
                "remediation", Map.of("type", "string")),
            "required", List.of("name", "severity", "location", "description", "impact",
                "poc", "evidence_request_ids", "remediation"))));

    Map<String, Object> extract = new HashMap<>();
    extract.put("type", "function");
    extract.put("function", Map.of(
        "name", "extract_from_response",
        "description", "Extract a value from a stored response body using a regex and optionally save it to a named variable for reuse in future requests.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "request_id", Map.of("type", "integer", "description", "ID returned by execute_http_request"),
                "pattern", Map.of("type", "string", "description", "Java regex with capture groups"),
                "group", Map.of("type", "integer", "description", "Capture group index (default 1)"),
                "store_as", Map.of("type", "string", "description", "Variable name to save the first match")),
            "required", List.of("request_id", "pattern"))));

    Map<String, Object> getVar = new HashMap<>();
    getVar.put("type", "function");
    getVar.put("function", Map.of(
        "name", "get_variable",
        "description", "Retrieve the value of a session variable previously saved by extract_from_response or set_variable.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of("name", Map.of("type", "string", "description", "Variable name")),
            "required", List.of("name"))));

    Map<String, Object> setVar = new HashMap<>();
    setVar.put("type", "function");
    setVar.put("function", Map.of(
        "name", "set_variable",
        "description", "Store a string value under a named variable for use in future requests via {{var_name}} interpolation.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "name", Map.of("type", "string", "description", "Variable name"),
                "value", Map.of("type", "string", "description", "Value to store")),
            "required", List.of("name", "value"))));

    Map<String, Object> fuzz = new HashMap<>();
    fuzz.put("type", "function");
    fuzz.put("function", Map.of(
        "name", "fuzz_parameter",
        "description", "Send multiple HTTP requests substituting a list of payloads into a single parameter. Returns all results plus a highlighted list of interesting responses.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "url", Map.of("type", "string", "description", "Full target URL. Use {{var}} for variable interpolation. FUZZ anywhere in the url is treated as a url_template automatically."),
                "method", Map.of("type", "string", "description", "HTTP method (default GET)"),
                "parameter", Map.of("type", "string", "description", "Parameter name to fuzz. Not required when url_template or a FUZZ-containing url is used."),
                "payload_list", Map.of("type", "array", "items", Map.of("type", "string"), "description", "List of payloads (max 25)"),
                "location", Map.of("type", "string", "description", "Where to inject: query (default), body, json_body, header, path. Ignored when url_template is used."),
                "body_template", Map.of("type", "string", "description", "Optional request body template; use FUZZ as the payload placeholder"),
                "url_template", Map.of("type", "string", "description", "Optional full URL template with FUZZ as path placeholder")),
            "required", List.of("url", "payload_list"))));

    Map<String, Object> dec = new HashMap<>();
    dec.put("type", "function");
    dec.put("function", Map.of(
        "name", "decode_encode",
        "description", "Locally decode or encode a string. Supports: base64_decode, base64_encode, base64_decode_url, base64_encode_url, url_decode, url_encode, hex_decode, hex_encode, jwt_decode, html_decode, html_encode.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "operation", Map.of("type", "string", "description", "One of the supported operations"),
                "input", Map.of("type", "string", "description", "The string to decode/encode")),
            "required", List.of("operation", "input"))));

    Map<String, Object> sir = new HashMap<>();
    sir.put("type", "function");
    sir.put("function", Map.of(
        "name", "search_in_response",
        "description", "Search a stored response body by regex and get matching lines with surrounding context.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "request_id", Map.of("type", "integer", "description", "ID returned by execute_http_request"),
                "pattern", Map.of("type", "string", "description", "Case-insensitive Java regex to search for"),
                "context_lines", Map.of("type", "integer", "description", "Lines of context above/below each match (default 2, max 5)")),
            "required", List.of("request_id", "pattern"))));

    Map<String, Object> spl = new HashMap<>();
    spl.put("type", "function");
    spl.put("function", Map.of(
        "name", "spider_links",
        "description", "Parse all links, form actions, script URLs, and JS API calls from a stored response.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "request_id", Map.of("type", "integer", "description", "ID returned by execute_http_request"),
                "base_url", Map.of("type", "string", "description", "Base URL for resolving relative links")),
            "required", List.of("request_id"))));

    Map<String, Object> getSm = new HashMap<>();
    getSm.put("type", "function");
    getSm.put("function", Map.of(
        "name", "get_sitemap",
        "description", "Query Burp's site map AND proxy history for all known requests to a given base URL.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "base_url", Map.of("type", "string", "description", "Base URL prefix to filter on")),
            "required", List.of())));

    Map<String, Object> finish = new HashMap<>();
    finish.put("type", "function");
    Map<String, Object> additionalFindingProps = new HashMap<>();
    additionalFindingProps.put("name",        Map.of("type", "string", "description", "Short finding name"));
    additionalFindingProps.put("severity",    Map.of("type", "string", "enum", List.of("Critical","High","Medium","Low","Informational"), "description", "Severity level"));
    additionalFindingProps.put("location",    Map.of("type", "string", "description", "Endpoint or component affected"));
    additionalFindingProps.put("description", Map.of("type", "string", "description", "What was observed and why it matters"));
    additionalFindingProps.put("remediation", Map.of("type", "string", "description", "Recommended fix"));
    Map<String, Object> additionalFindingSchema = new HashMap<>();
    additionalFindingSchema.put("type", "object");
    additionalFindingSchema.put("properties", additionalFindingProps);
    additionalFindingSchema.put("required", List.of("name","severity","location","description"));
    Map<String, Object> finishProps = new HashMap<>();
    finishProps.put("summary", Map.of("type", "string", "description", "Comprehensive summary: what was tested, what was found, steps taken."));
    finishProps.put("additional_findings", Map.of(
        "type", "array",
        "description", "Observed issues that were NOT confirmed with a PoC but are worth noting — Medium/Low/Informational items, security header gaps, information disclosure, suspicious endpoints. Every such finding MUST appear here, not just in the summary text.",
        "items", additionalFindingSchema));
    finish.put("function", Map.of(
        "name", "finish_run",
        "description", "Signal that the pentest run is complete. ALL observed issues — even unconfirmed Medium/Low/Info — must be passed in additional_findings so they appear in the HTML report. The loop terminates immediately after this call.",
        "parameters", Map.of(
            "type", "object",
            "properties", finishProps,
            "required", List.of("summary"))));

    Map<String, Object> oobGen = new HashMap<>();
    oobGen.put("type", "function");
    oobGen.put("function", Map.of(
        "name", "generate_oob_payload",
        "description",
            "Generate a unique Burp Collaborator out-of-band (OOB) domain payload for detecting blind "
            + "vulnerabilities (blind SQLi, blind SSRF, blind XXE, blind XSS). "
            + "Returns ready-to-use payloads for DNS, HTTP, Gopher-Redis, XXE DTD, and SQL-specific OOB. "
            + "After embedding the oob_domain in a request, call poll_collaborator to detect callbacks.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "protocol", Map.of("type", "string",
                    "description", "Hint for the primary protocol to target: dns (default), http, gopher-redis",
                    "enum", List.of("dns", "http", "gopher-redis", "ftp"))),
            "required", List.of())));

    Map<String, Object> oobPoll = new HashMap<>();
    oobPoll.put("type", "function");
    oobPoll.put("function", Map.of(
        "name", "poll_collaborator",
        "description",
            "Poll the Burp Collaborator server for any DNS, HTTP, or SMTP interactions received since "
            + "the last poll. A callback confirms a blind vulnerability was triggered. "
            + "Call this 5-10 seconds after submitting an OOB payload.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(),
            "required", List.of())));

    return List.of(exec, rep, extract, getVar, setVar, fuzz, dec, sir, spl, getSm, oobGen, oobPoll, finish);
  }
}
