package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;

/**
 * Manages LLM client creation, system-prompt loading, persona overlays, and
 * the OpenAI-style tool schema sent to the model on every chat call.
 *
 * <p>Persona payload protocol (matches {@link AgentLoop#runAgent}):
 * <ul>
 *   <li>{@code null} / blank → General mode; base system prompt unchanged</li>
 *   <li>{@code "persona:<Name>"} → base prompt + appended focus-mode block from {@link #BUILT_IN_PERSONAS}</li>
 *   <li>Any other non-blank string → full custom system-prompt replacement</li>
 * </ul>
 */
class LlmGateway {

  // ── Built-in focus personas (loaded from /personas/*.md on the classpath) ──

  static final LinkedHashMap<String, String> BUILT_IN_PERSONAS = new LinkedHashMap<>();

  /** Display-name → classpath resource filename under {@code /personas/}. */
  private static final LinkedHashMap<String, String> PERSONA_FILES = new LinkedHashMap<>();

  static {
    PERSONA_FILES.put("Command & Code Execution Focus", "command-code-execution-focus.md");
    PERSONA_FILES.put("File & Path Handling Focus",     "file-path-handling-focus.md");
    PERSONA_FILES.put("API Security Focus",             "api-security-focus.md");
    PERSONA_FILES.put("Auth & Authorization Focus",     "auth-authorization-focus.md");
    PERSONA_FILES.put("Secrets & Cryptography Focus",   "secrets-cryptography-focus.md");
    PERSONA_FILES.put("XSS Focus",                      "xss-focus.md");
    PERSONA_FILES.put("SQL Injection Focus",             "sqli-focus.md");
    PERSONA_FILES.put("Injection Attacks Focus",         "injection-attacks-focus.md");
    PERSONA_FILES.put("SSRF Focus",                     "ssrf-focus.md");
    PERSONA_FILES.put("Business Logic Focus",           "business-logic-focus.md");
    PERSONA_FILES.put("Security Misconfiguration Focus","security-misconfiguration-focus.md");
    PERSONA_FILES.put("Cloud Security Focus",           "cloud-security-focus.md");
    PERSONA_FILES.put("Container & Kubernetes Security Focus", "container-kubernetes-security-focus.md");
    PERSONA_FILES.put("Supply Chain Security Focus",    "supply-chain-security-focus.md");
    PERSONA_FILES.put("LLM Security Focus",             "llm-security-focus.md");

    PERSONA_FILES.forEach((displayName, fileName) -> {
      String path = "/personas/" + fileName;
      try (InputStream is = LlmGateway.class.getResourceAsStream(path)) {
        if (is != null) {
          BUILT_IN_PERSONAS.put(displayName,
              new String(is.readAllBytes(), StandardCharsets.UTF_8));
        } else {
          System.err.println("[LlmGateway] Persona file not found on classpath: " + path);
        }
      } catch (Exception e) {
        System.err.println("[LlmGateway] Failed to load persona '" + displayName + "': " + e);
      }
    });
  }

  // ── Fallback system prompt ────────────────────────────────────────────────

  private static final String FALLBACK_SYSTEM_PROMPT =
      "You are an autonomous penetration testing agent inside Burp Suite.\n" +
      "\nTOOLS AND WHEN TO USE THEM:\n" +
      "- execute_http_request   : send every HTTP request to the target\n" +
      "- get_sitemap            : query Burp site map + proxy history for already-seen URLs — call this FIRST before any reconnaissance\n" +
      "- spider_links           : call IMMEDIATELY after any baseline request to get all links, form actions, JS API calls, input names\n" +
      "- search_in_response     : search a stored response body by regex (use instead of re-fetching a page to find one value)\n" +
      "- extract_from_response  : extract a value (CSRF token, nonce) from response and save as {{var_name}} for reuse\n" +
      "- set_variable / get_variable : manually store/retrieve named values across iterations\n" +
      "- fuzz_parameter         : send a BATCH of payloads into one parameter — use for ALL injection testing (SQLi, XSS, CMDi, SSTI, SSRF). Do NOT loop individual payloads with execute_http_request.\n" +
      "- decode_encode          : locally decode/encode (jwt_decode, base64_decode, url_decode, hex_decode, etc.) — no HTTP request needed\n" +
      "- generate_oob_payload   : generate a Burp Collaborator OOB domain for blind injection detection (blind SQLi, SSRF, XXE, XSS). Returns ready-to-use payloads for DNS/HTTP/Gopher.\n" +
      "- poll_collaborator      : poll the Collaborator server for OOB callbacks. A DNS/HTTP callback confirms a blind vulnerability.\n" +
      "- report_vulnerability   : report a confirmed vulnerability with evidence_request_ids\n" +
      "- finish_run             : call when ALL testing is done. The loop terminates immediately. ALWAYS use this instead of writing plain text conclusions.\n" +
      "  → 'summary' (required): comprehensive text summary of what was tested and found.\n" +
      "  → 'additional_findings' (required array): EVERY Medium/Low/Informational observation goes here as a structured object — \"\n" +
      "    {name, severity, location, description, remediation}. This is how they appear in the HTML report.\n" +
      "    Do NOT omit findings just because they were not confirmed with a PoC. If you observed it, include it.\n" +
      "Use {{var_name}} in any url or body to interpolate a stored variable.\n" +
      "\nRULES:\n" +
      "- spider_links after every baseline. fuzz_parameter for injection testing. decode_encode for any token inspection.\n" +
      "- OOB WORKFLOW: call generate_oob_payload → embed oob_domain in blind-injection payload → call poll_collaborator after 5-10 s to detect DNS/HTTP callback.\n" +
      "- WAF BYPASS: if fuzz_parameter returns waf_bypass_variants, retry fuzz_parameter with those encoded variants immediately.\n" +
      "- VARIABLE CHAINING: stored_vars in STATE_SIGNALS lists ALL active variables — use them via {{var_name}}. Do NOT re-extract variables already listed there.\n" +
      "- Actively read ALL data returned by tools: status, headers, cookies, body, timing.\n" +
      "- Never invent or assume response content not present in tool output.\n" +
      "- Validate before reporting; then call report_vulnerability with evidence_request_ids.\n" +
      "- Never spam report_vulnerability.\n" +
      "- When all test vectors are exhausted, call finish_run — NEVER write a plain-text final summary without a tool call.\n" +
      "- TASK FOCUS: If the task specifies a single vulnerability class (e.g. 'find SSRF'), ONLY call report_vulnerability for that class. Any other observations go into finish_run additional_findings — NOT into the summary text.\n";

  // ── Instance ──────────────────────────────────────────────────────────────

  private final MontoyaApi api;
  private final AgentLogger logger;
  private final String systemPromptText;

  LlmGateway(MontoyaApi api, AgentLogger logger) {
    this.api = api;
    this.logger = logger;
    this.systemPromptText = loadSystemPrompt();
  }

  // ── Prompt loading ────────────────────────────────────────────────────────

  private String loadSystemPrompt() {
    try (InputStream is = getClass().getResourceAsStream("/burp-ai-agent-prompt.md")) {
      if (is != null) {
        String text = new String(is.readAllBytes(), StandardCharsets.UTF_8);
        api.logging().logToOutput(
            "[LlmGateway] Loaded system prompt from classpath (" + text.length() + " chars).");
        return text;
      }
    } catch (Exception e) {
      api.logging().logToError("[LlmGateway] Failed to load system prompt: " + e);
    }
    api.logging().logToOutput("[LlmGateway] Using built-in fallback system prompt.");
    return FALLBACK_SYSTEM_PROMPT;
  }

  String systemPromptText() {
    return systemPromptText;
  }

  /**
   * Builds the effective system prompt based on the persona payload.
   *
   * @param personaPayload see class-level javadoc for the protocol
   */
  String buildEffectiveSystemPrompt(String personaPayload) {
    if (personaPayload == null || personaPayload.isBlank()) {
      return systemPromptText;
    }
    if (personaPayload.startsWith("persona:")) {
      String key = personaPayload.substring(8);
      String overlay = BUILT_IN_PERSONAS.get(key);
      if (overlay == null || overlay.isBlank()) {
        api.logging().logToOutput(
            "[LlmGateway] Unknown built-in persona key '" + key + "', using base prompt.");
        return systemPromptText;
      }
      api.logging().logToOutput("[LlmGateway] Applying built-in persona: " + key);
      return systemPromptText + "\n\n---\n\n" + overlay;
    }
    api.logging().logToOutput(
        "[LlmGateway] Using custom persona/system prompt (" + personaPayload.length() + " chars).");
    return personaPayload;
  }

  // ── Client factory ────────────────────────────────────────────────────────

  /** Creates the appropriate {@link LlmClient} for the given provider. */
  LlmClient createClient(String provider, String baseUrl, String model, String apiKey) {
    if ("gemini".equalsIgnoreCase(provider)) {
      return new GeminiClient(model, apiKey, api.logging());
    }
    if ("openrouter".equalsIgnoreCase(provider)) {
      return new OpenRouterClient(model, apiKey, api.logging());
    }
    if ("deepseek".equalsIgnoreCase(provider)) {
      return new DeepSeekClient(model, apiKey, api.logging());
    }
    return new OllamaClient(baseUrl, model, api.logging());
  }

  /** Tests the connection to the LLM and writes results via the logger. */
  void testConnection(String provider, String baseUrl, String model, String apiKey) {
    boolean isApiKeyProvider = "gemini".equalsIgnoreCase(provider)
        || "openrouter".equalsIgnoreCase(provider)
        || "deepseek".equalsIgnoreCase(provider);
    logger.log("\n[DEBUG] Testing connection to: "
        + (isApiKeyProvider ? provider.toUpperCase() + " API" : baseUrl)
        + " with model: " + model + "\n");
    api.logging().logToOutput("[LlmGateway] testConnection() entered");
    try {
      LlmClient client = createClient(provider, baseUrl, model, apiKey);
      api.logging().logToOutput("[LlmGateway] Calling client.testConnection()...");
      var res = client.testConnection();
      logger.log("\n" + "=".repeat(60) + "\n");
      logger.log("CONNECTION TEST RESULT\n");
      logger.log("Provider: " + provider + "\n");
      if (!isApiKeyProvider) logger.log("URL: " + baseUrl + "\n");
      logger.log("Model: " + model + "\n");
      logger.log(res.ok ? "[SUCCESS] " : "[FAILED] ");
      logger.log(res.message + "\n");
      logger.log("=".repeat(60) + "\n\n");
    } catch (Throwable t) {
      String msg = t.getMessage();
      if (msg == null || msg.isBlank()) msg = String.valueOf(t);
      logger.log("[ERROR] Connection test crashed: " + t.getClass().getName() + ": " + msg + "\n");
      api.logging().logToError("testConnection crashed: " + t);
    } finally {
      api.logging().logToOutput("[LlmGateway] testConnection() exiting");
    }
  }

  // ── Tool schema ───────────────────────────────────────────────────────────

  /** Returns the OpenAI-style tool definitions sent to the LLM on every chat call. */
  static List<Map<String, Object>> toolSchema() {
    Map<String, Object> exec = new HashMap<>();
    exec.put("type", "function");
    exec.put("function", Map.of(
        "name", "execute_http_request",
        "description", "Send an HTTP request via Burp.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "method", Map.of("type", "string"),
                "url", Map.of("type", "string"),
                "headers", Map.of("type", "object"),
                "body", Map.of("type", "string"),
                "purpose", Map.of("type", "string"),
                "expected", Map.of("type", "string")),
            "required", List.of("method", "url", "purpose", "expected"))));

    Map<String, Object> rep = new HashMap<>();
    rep.put("type", "function");
    rep.put("function", Map.of(
        "name", "report_vulnerability",
        "description", "Report a confirmed vulnerability.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "name", Map.of("type", "string"),
                "severity", Map.of("type", "string"),
                "location", Map.of("type", "string"),
                "description", Map.of("type", "string"),
                "impact", Map.of("type", "string"),
                "poc", Map.of("type", "string"),
                "evidence_request_ids", Map.of("type", "array", "items", Map.of("type", "integer")),
                "remediation", Map.of("type", "string")),
            "required", List.of("name", "severity", "location", "description", "impact",
                "poc", "evidence_request_ids", "remediation"))));

    Map<String, Object> extract = new HashMap<>();
    extract.put("type", "function");
    extract.put("function", Map.of(
        "name", "extract_from_response",
        "description", "Extract a value from a stored response body using a regex and optionally save it to a named variable for reuse in future requests.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "request_id", Map.of("type", "integer", "description", "ID returned by execute_http_request"),
                "pattern", Map.of("type", "string", "description", "Java regex with capture groups"),
                "group", Map.of("type", "integer", "description", "Capture group index (default 1)"),
                "store_as", Map.of("type", "string", "description", "Variable name to save the first match")),
            "required", List.of("request_id", "pattern"))));

    Map<String, Object> getVar = new HashMap<>();
    getVar.put("type", "function");
    getVar.put("function", Map.of(
        "name", "get_variable",
        "description", "Retrieve the value of a session variable previously saved by extract_from_response or set_variable.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of("name", Map.of("type", "string", "description", "Variable name")),
            "required", List.of("name"))));

    Map<String, Object> setVar = new HashMap<>();
    setVar.put("type", "function");
    setVar.put("function", Map.of(
        "name", "set_variable",
        "description", "Store a string value under a named variable for use in future requests via {{var_name}} interpolation.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "name", Map.of("type", "string", "description", "Variable name"),
                "value", Map.of("type", "string", "description", "Value to store")),
            "required", List.of("name", "value"))));

    Map<String, Object> fuzz = new HashMap<>();
    fuzz.put("type", "function");
    fuzz.put("function", Map.of(
        "name", "fuzz_parameter",
        "description", "Send multiple HTTP requests substituting a list of payloads into a single parameter. Returns all results plus a highlighted list of interesting responses.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "url", Map.of("type", "string", "description", "Full target URL. Use {{var}} for variable interpolation. FUZZ anywhere in the url is treated as a url_template automatically."),
                "method", Map.of("type", "string", "description", "HTTP method (default GET)"),
                "parameter", Map.of("type", "string", "description", "Parameter name to fuzz. Not required when url_template or a FUZZ-containing url is used."),
                "payload_list", Map.of("type", "array", "items", Map.of("type", "string"), "description", "List of payloads (max 25)"),
                "location", Map.of("type", "string", "description", "Where to inject: query (default), body, json_body, header, path. Ignored when url_template is used."),
                "body_template", Map.of("type", "string", "description", "Optional request body template; use FUZZ as the payload placeholder"),
                "url_template", Map.of("type", "string", "description", "Optional full URL template with FUZZ as path placeholder")),
            "required", List.of("url", "payload_list"))));

    Map<String, Object> dec = new HashMap<>();
    dec.put("type", "function");
    dec.put("function", Map.of(
        "name", "decode_encode",
        "description", "Locally decode or encode a string. Supports: base64_decode, base64_encode, base64_decode_url, base64_encode_url, url_decode, url_encode, hex_decode, hex_encode, jwt_decode, html_decode, html_encode.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "operation", Map.of("type", "string", "description", "One of the supported operations"),
                "input", Map.of("type", "string", "description", "The string to decode/encode")),
            "required", List.of("operation", "input"))));

    Map<String, Object> sir = new HashMap<>();
    sir.put("type", "function");
    sir.put("function", Map.of(
        "name", "search_in_response",
        "description", "Search a stored response body by regex and get matching lines with surrounding context.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "request_id", Map.of("type", "integer", "description", "ID returned by execute_http_request"),
                "pattern", Map.of("type", "string", "description", "Case-insensitive Java regex to search for"),
                "context_lines", Map.of("type", "integer", "description", "Lines of context above/below each match (default 2, max 5)")),
            "required", List.of("request_id", "pattern"))));

    Map<String, Object> spl = new HashMap<>();
    spl.put("type", "function");
    spl.put("function", Map.of(
        "name", "spider_links",
        "description", "Parse all links, form actions, script URLs, and JS API calls from a stored response.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "request_id", Map.of("type", "integer", "description", "ID returned by execute_http_request"),
                "base_url", Map.of("type", "string", "description", "Base URL for resolving relative links")),
            "required", List.of("request_id"))));

    Map<String, Object> getSm = new HashMap<>();
    getSm.put("type", "function");
    getSm.put("function", Map.of(
        "name", "get_sitemap",
        "description", "Query Burp's site map AND proxy history for all known requests to a given base URL.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "base_url", Map.of("type", "string", "description", "Base URL prefix to filter on")),
            "required", List.of())));

    Map<String, Object> finish = new HashMap<>();
    finish.put("type", "function");
    Map<String, Object> additionalFindingProps = new HashMap<>();
    additionalFindingProps.put("name",        Map.of("type", "string", "description", "Short finding name"));
    additionalFindingProps.put("severity",    Map.of("type", "string", "enum", List.of("Critical","High","Medium","Low","Informational"), "description", "Severity level"));
    additionalFindingProps.put("location",    Map.of("type", "string", "description", "Endpoint or component affected"));
    additionalFindingProps.put("description", Map.of("type", "string", "description", "What was observed and why it matters"));
    additionalFindingProps.put("remediation", Map.of("type", "string", "description", "Recommended fix"));
    Map<String, Object> additionalFindingSchema = new HashMap<>();
    additionalFindingSchema.put("type", "object");
    additionalFindingSchema.put("properties", additionalFindingProps);
    additionalFindingSchema.put("required", List.of("name","severity","location","description"));
    Map<String, Object> finishProps = new HashMap<>();
    finishProps.put("summary", Map.of("type", "string", "description", "Comprehensive summary: what was tested, what was found, steps taken."));
    finishProps.put("additional_findings", Map.of(
        "type", "array",
        "description", "Observed issues that were NOT confirmed with a PoC but are worth noting — Medium/Low/Informational items, security header gaps, information disclosure, suspicious endpoints. Every such finding MUST appear here, not just in the summary text.",
        "items", additionalFindingSchema));
    finish.put("function", Map.of(
        "name", "finish_run",
        "description", "Signal that the pentest run is complete. ALL observed issues — even unconfirmed Medium/Low/Info — must be passed in additional_findings so they appear in the HTML report. The loop terminates immediately after this call.",
        "parameters", Map.of(
            "type", "object",
            "properties", finishProps,
            "required", List.of("summary"))));

    Map<String, Object> oobGen = new HashMap<>();
    oobGen.put("type", "function");
    oobGen.put("function", Map.of(
        "name", "generate_oob_payload",
        "description",
            "Generate a unique Burp Collaborator out-of-band (OOB) domain payload for detecting blind "
            + "vulnerabilities (blind SQLi, blind SSRF, blind XXE, blind XSS). "
            + "Returns ready-to-use payloads for DNS, HTTP, Gopher-Redis, XXE DTD, and SQL-specific OOB. "
            + "After embedding the oob_domain in a request, call poll_collaborator to detect callbacks.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "protocol", Map.of("type", "string",
                    "description", "Hint for the primary protocol to target: dns (default), http, gopher-redis",
                    "enum", List.of("dns", "http", "gopher-redis", "ftp"))),
            "required", List.of())));

    Map<String, Object> oobPoll = new HashMap<>();
    oobPoll.put("type", "function");
    oobPoll.put("function", Map.of(
        "name", "poll_collaborator",
        "description",
            "Poll the Burp Collaborator server for any DNS, HTTP, or SMTP interactions received since "
            + "the last poll. A callback confirms a blind vulnerability was triggered. "
            + "Call this 5-10 seconds after submitting an OOB payload.",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(),
            "required", List.of())));

    return List.of(exec, rep, extract, getVar, setVar, fuzz, dec, sir, spl, getSm, oobGen, oobPoll, finish);
  }
}
