package com.burpai.aipentester;

import java.util.List;
import java.util.Map;

/**
 * Common interface for LLM backend clients (Ollama, Gemini, etc.).
 */
public interface LlmClient {

  /** Tests connectivity and model availability. */
  ConnResult testConnection();

  /**
   * Sends a chat turn with optional tool definitions.
   *
   * @param messages OpenAI-style message list (role/content, tool messages).
   * @param tools    OpenAI-style function/tool schema list.
   */
  ChatResult chat(List<Map<String, Object>> messages, List<Map<String, Object>> tools);

  // ---- Value types shared by all implementations ----

  final class ConnResult {
    public final boolean ok;
    public final String message;

    public ConnResult(boolean ok, String message) {
      this.ok = ok;
      this.message = message;
    }
  }

  final class ToolCall {
    /** Tool-call ID from the API (e.g. DeepSeek / OpenAI); null for providers that omit it. */
    public final String id;
    public final String name;
    public final Map<String, Object> args;

    /** Full constructor â€” use when the API returns a tool-call ID. */
    public ToolCall(String id, String name, Map<String, Object> args) {
      this.id   = id;
      this.name = name;
      this.args = args;
    }

    /** Backward-compat constructor for providers that don't return IDs. */
    public ToolCall(String name, Map<String, Object> args) {
      this(null, name, args);
    }
  }

  final class ChatResult {
    public final boolean ok;
    public final String content;
    public final List<ToolCall> toolCalls;
    public final String error;
    /**
     * Optional: the full assistant message map to store verbatim in the history.
     * When non-null, AgentLoop uses this instead of building a plain text-only message.
     * Providers that support native tool calling (e.g. DeepSeek) populate this with
     * {@code reasoning_content} and the {@code tool_calls} array so the API can
     * continue reasoning across tool-call sub-turns correctly.
     */
    public final Map<String, Object> rawAssistantMessage;

    private ChatResult(boolean ok, String content, List<ToolCall> toolCalls,
                       String error, Map<String, Object> rawAssistantMessage) {
      this.ok = ok;
      this.content = content;
      this.toolCalls = toolCalls;
      this.error = error;
      this.rawAssistantMessage = rawAssistantMessage;
    }

    public static ChatResult ok(String content, List<ToolCall> toolCalls) {
      return new ChatResult(true, content, toolCalls, null, null);
    }

    public static ChatResult ok(String content, List<ToolCall> toolCalls,
                                Map<String, Object> rawAssistantMessage) {
      return new ChatResult(true, content, toolCalls, null, rawAssistantMessage);
    }

    public static ChatResult err(String error) {
      return new ChatResult(false, null, null, error, null);
    }
  }
}
