package com.burpai.aipentester;

import burp.api.montoya.logging.Logging;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * LLM client targeting OpenRouter's OpenAI-compatible REST API.
 *
 * <p>Default model: {@code deepseek/deepseek-r1-0528:free}
 *
 * <p>API reference: <a href="https://openrouter.ai/docs/api/reference/overview">
 * https://openrouter.ai/docs/api/reference/overview</a>
 *
 * <p>If the model returns a 404 "No endpoints found that support tool use" error, the
 * client permanently switches to <em>text-mode tool calling</em>: it sends a system
 * message instructing the model to emit JSON tool-call objects inline in its response
 * text, and parses those objects on the way back out. This matches the fallback used
 * by {@link OllamaClient} and keeps the rest of the agent loop unchanged.
 *
 * <p>DeepSeek R1 embeds chain-of-thought inside {@code <think>…</think>} tags in the
 * {@code content} field; text-mode parsing skips those blocks safely.
 */
public class OpenRouterClient implements LlmClient {

  /** OpenRouter chat-completions endpoint (OpenAI-compatible). */
  private static final String API_URL = "https://openrouter.ai/api/v1/chat/completions";

  /** Sent as HTTP-Referer — informational, helps OpenRouter analytics. */
  private static final String SITE_URL = "https://github.com/burp-ai-pentester";

  private final String model;
  private final String apiKey;
  private final Logging logging;
  private final HttpClient http;
  private final ObjectMapper json = new ObjectMapper();

  /** Flipped permanently when a 404 reveals the model doesn't support native tool use. */
  private volatile boolean toolsStripped = false;

  /**
   * @param model  OpenRouter model ID, e.g. {@code "deepseek/deepseek-r1-0528:free"}
   * @param apiKey OpenRouter API key (sk-or-v1-…)
   */
  public OpenRouterClient(String model, String apiKey, Logging logging) {
    this.model   = model.trim();
    this.apiKey  = apiKey.trim();
    this.logging = logging;
    this.http = HttpClient.newBuilder()
        .followRedirects(HttpClient.Redirect.NORMAL)
        .proxy(new DirectProxySelector())   // bypass Burp proxy for external API calls
        .connectTimeout(Duration.ofSeconds(20))
        .build();
  }

  // Force direct connections — avoids Burp intercepting calls to openrouter.ai.
  private static final class DirectProxySelector extends ProxySelector {
    @Override public List<Proxy> select(URI uri) { return List.of(Proxy.NO_PROXY); }
    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}
  }

  // ── LlmClient ────────────────────────────────────────────────────────────

  @Override
  public ConnResult testConnection() {
    // Use the /models endpoint — instant response, no inference queue, validates the API key.
    try {
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create("https://openrouter.ai/api/v1/models"))
          .timeout(Duration.ofSeconds(15))
          .header("Authorization", "Bearer " + apiKey)
          .header("HTTP-Referer", SITE_URL)
          .header("X-Title", "BurpAI Pentester")
          .GET()
          .build();

      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(20));

      if (resp.statusCode() == 401 || resp.statusCode() == 403) {
        return new ConnResult(false, "OpenRouter API key is invalid (HTTP " + resp.statusCode() + ").");
      }
      if (resp.statusCode() == 402) {
        return new ConnResult(false, "OpenRouter: Insufficient credits — add more at https://openrouter.ai/credits");
      }
      if (resp.statusCode() != 200) {
        return new ConnResult(false,
            "OpenRouter /models returned HTTP " + resp.statusCode() + ": " + extractError(resp.body()));
      }

      // Check whether the requested model appears in the catalogue.
      boolean found = resp.body().contains("\"" + model + "\"");
      if (!found) {
        return new ConnResult(false,
            "API key is valid but model '" + model + "' was not found in OpenRouter's model list. "
            + "Check the model ID at https://openrouter.ai/models");
      }
      return new ConnResult(true,
          "Connected to OpenRouter. API key valid. Model '" + model + "' is available.");

    } catch (Exception e) {
      return new ConnResult(false,
          "Connection error: " + e.getClass().getSimpleName() + ": " + e.getMessage());
    }
  }

  @Override
  public ChatResult chat(List<Map<String, Object>> messages, List<Map<String, Object>> tools) {
    int attempts = 0;
    while (true) {
      attempts++;
      try {
        List<Map<String, Object>> sendMessages = toolsStripped ? stripToolMessages(messages) : messages;
        List<Map<String, Object>> sendTools    = toolsStripped ? List.of() : tools;

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("model", model);
        payload.put("messages", sendMessages);
        if (!sendTools.isEmpty()) {
          payload.put("tools", sendTools);
          payload.put("tool_choice", "auto");
        }

        String body = json.writeValueAsString(payload);
        logging.logToOutput("[OpenRouterClient] POST " + API_URL
            + " (msgs=" + sendMessages.size() + ", body=" + body.length()
            + " bytes, toolsStripped=" + toolsStripped + ")");

        HttpRequest req = buildRequest(body, Duration.ofSeconds(180));
        HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(185));
        logging.logToOutput("[OpenRouterClient] HTTP " + resp.statusCode());

        // ── 404: model doesn't support native tool use → switch to text mode ──
        if (resp.statusCode() == 404 && !toolsStripped
            && resp.body() != null && resp.body().contains("support tool use")) {
          logging.logToError("[OpenRouterClient] Model does not support native tool use — "
              + "switching permanently to text-mode tool calling.");
          toolsStripped = true;
          attempts--; // don't count this against retry limit
          continue;
        }

        // ── 402: Insufficient credits — no point retrying ────────────────
        if (resp.statusCode() == 402) {
          return ChatResult.err("OpenRouter: Insufficient credits. "
              + "Add credits at https://openrouter.ai/credits  ["
              + extractError(resp.body()) + "]");
        }

        // ── Retryable provider/infrastructure errors (per OpenRouter spec) ─
        // 429 Too Many Requests, 502 Bad Gateway (provider error),
        // 503 Service Unavailable, 524 Edge Network Timeout,
        // 529 Provider Overloaded
        int sc = resp.statusCode();
        if (sc == 429 || sc == 502 || sc == 503 || sc == 524 || sc == 529) {
          if (attempts >= 4) {
            return ChatResult.err("OpenRouter HTTP " + sc + " after " + attempts
                + " attempts: " + extractError(resp.body()));
          }
          long backoffMs = attempts * 3000L;
          logging.logToError("[OpenRouterClient] HTTP " + sc
              + " (retryable); retrying in " + backoffMs + "ms (attempt " + attempts + ")");
          Thread.sleep(backoffMs);
          continue;
        }

        if (resp.statusCode() != 200) {
          return ChatResult.err("OpenRouter HTTP " + resp.statusCode()
              + ": " + extractError(resp.body()));
        }

        // ── Parse response ───────────────────────────────────────────────
        @SuppressWarnings("unchecked")
        Map<String, Object> data = json.readValue(resp.body(), Map.class);

        @SuppressWarnings("unchecked")
        List<Object> choices = (List<Object>) data.get("choices");
        if (choices == null || choices.isEmpty()) {
          return ChatResult.err("OpenRouter response missing 'choices': " + truncate(resp.body(), 300));
        }

        @SuppressWarnings("unchecked")
        Map<String, Object> choice = (Map<String, Object>) choices.get(0);
        @SuppressWarnings("unchecked")
        Map<String, Object> msg = (Map<String, Object>) choice.get("message");
        if (msg == null) {
          return ChatResult.err("OpenRouter 'message' missing in choice");
        }

        // Content may contain DeepSeek R1's <think>…</think> reasoning block.
        // Strip it before passing to the text-mode parser so the JSON brace
        // scanner doesn't get confused by reasoning text.
        Object rawContent = msg.get("content");
        String content = rawContent != null ? String.valueOf(rawContent) : "";

        // ── Tool calls ───────────────────────────────────────────────────
        List<LlmClient.ToolCall> toolCalls;
        if (toolsStripped) {
          // Strip <think>…</think> before scanning for JSON tool calls
          String stripped = content.replaceAll("(?s)<think>.*?</think>", "").trim();
          toolCalls = parseToolCallsFromText(stripped);
        } else {
          toolCalls = parseToolCalls(msg);
        }

        return ChatResult.ok(content, toolCalls);

      } catch (InterruptedException ie) {
        Thread.currentThread().interrupt();
        return ChatResult.err("Interrupted during OpenRouter call");

      } catch (java.net.ConnectException | java.net.SocketTimeoutException | HttpTimeoutException e) {
        if (attempts >= 3) {
          return ChatResult.err("OpenRouter connect/timeout after " + attempts
              + " attempts: " + e.getMessage());
        }
        long backoffMs = attempts * 1500L;
        logging.logToError("[OpenRouterClient] Transient failure (attempt " + attempts
            + "): " + e + "; retrying in " + backoffMs + "ms");
        try {
          Thread.sleep(backoffMs);
        } catch (InterruptedException ie2) {
          Thread.currentThread().interrupt();
          return ChatResult.err("Interrupted while retrying OpenRouter call");
        }

      } catch (Throwable t) {
        logging.logToError("[OpenRouterClient] chat failed: " + t);
        String msg2 = t.getMessage();
        if (msg2 == null || msg2.isBlank()) msg2 = String.valueOf(t);
        return ChatResult.err(t.getClass().getName() + ": " + msg2);
      }
    }
  }

  // ── Text-mode helpers (used when model doesn't support native tool use) ────

  /**
   * Converts the message history to a form safe for models without native tool support:
   * <ul>
   *   <li>Injects a system-level instruction explaining JSON tool-call format.</li>
   *   <li>Re-wraps {@code role:tool} messages as {@code role:user} messages.</li>
   *   <li>Drops {@code role:assistant} messages that contain only a {@code tool_calls}
   *       payload with no text, to avoid confusing the model.</li>
   * </ul>
   */
  @SuppressWarnings("unchecked")
  private static List<Map<String, Object>> stripToolMessages(List<Map<String, Object>> messages) {
    List<Map<String, Object>> out = new ArrayList<>();

    Map<String, Object> instruction = new HashMap<>();
    instruction.put("role", "system");
    instruction.put("content",
        "TOOL CALLING MODE: This model does not support native function calling. " +
        "Whenever you want to call a tool, emit a JSON object in your response text with exactly this shape:\n" +
        "{\"name\":\"<tool_name>\",\"arguments\":{<args>}}\n" +
        "Available tools: execute_http_request, report_vulnerability, extract_from_response, get_variable, set_variable, fuzz_parameter, decode_encode, search_in_response, spider_links, get_sitemap, finish_run\n" +
        "Examples:\n" +
        "{\"name\":\"execute_http_request\",\"arguments\":{\"method\":\"GET\",\"url\":\"/search?q=test\",\"purpose\":\"probe search\",\"expected\":\"200\"}}\n" +
        "{\"name\":\"fuzz_parameter\",\"arguments\":{\"url\":\"https://host/search\",\"parameter\":\"q\",\"payload_list\":[\"'\",\"1 OR 1=1\",\"<script>\"],\"location\":\"query\"}}\n" +
        "{\"name\":\"finish_run\",\"arguments\":{\"summary\":\"All tests complete.\",\"additional_findings\":[]}}\n" +
        "Do NOT use markdown fences. Place the JSON on its own line. Text before/after is fine.");
    out.add(instruction);

    for (Map<String, Object> m : messages) {
      String role = String.valueOf(m.getOrDefault("role", ""));
      if ("tool".equals(role)) {
        String name    = String.valueOf(m.getOrDefault("name", "tool"));
        String content = String.valueOf(m.getOrDefault("content", ""));
        Map<String, Object> wrapped = new HashMap<>();
        wrapped.put("role", "user");
        wrapped.put("content", "[Tool result for " + name + "]\n" + content);
        out.add(wrapped);
      } else {
        if ("system".equals(role)) {
          String c = String.valueOf(m.getOrDefault("content", ""));
          if (c.startsWith("TOOL CALLING MODE:")) continue; // deduplicate
        }
        out.add(m);
      }
    }
    return out;
  }

  /**
   * Scans {@code content} for bare JSON objects that look like tool calls
   * (containing {@code "name"} and {@code "arguments"} keys) and returns them.
   * Called when {@link #toolsStripped} is true.
   */
  @SuppressWarnings("unchecked")
  private List<LlmClient.ToolCall> parseToolCallsFromText(String content) {
    List<LlmClient.ToolCall> result = new ArrayList<>();
    if (content == null || content.isBlank()) return result;

    int depth = 0;
    int start = -1;
    for (int i = 0; i < content.length(); i++) {
      char c = content.charAt(i);
      if (c == '{') {
        if (depth == 0) start = i;
        depth++;
      } else if (c == '}') {
        depth--;
        if (depth == 0 && start >= 0) {
          String candidate = content.substring(start, i + 1);
          try {
            Object parsed = json.readValue(candidate, Object.class);
            if (parsed instanceof Map<?, ?> m) {
              Map<String, Object> map = (Map<String, Object>) m;
              String name = null;
              Object argsObj = null;

              if (map.containsKey("name") && map.containsKey("arguments")) {
                name    = String.valueOf(map.get("name"));
                argsObj = map.get("arguments");
              } else if (map.containsKey("function") && map.get("function") instanceof Map<?, ?> fn) {
                name    = String.valueOf(((Map<?, ?>) fn).get("name"));
                argsObj = ((Map<?, ?>) fn).get("arguments");
              }

              if (name != null && isKnownTool(name)) {
                Map<String, Object> args = new HashMap<>();
                if (argsObj instanceof Map<?, ?> am) {
                  args = (Map<String, Object>) am;
                } else if (argsObj instanceof String s) {
                  try {
                    Object p = json.readValue(s, Object.class);
                    if (p instanceof Map<?, ?> pm) args = (Map<String, Object>) pm;
                  } catch (Exception ignored) {}
                }
                result.add(new LlmClient.ToolCall(name, args));
              }
            }
          } catch (Exception ignored) {}
          start = -1;
        }
      }
    }
    return result;
  }

  private static boolean isKnownTool(String name) {
    return switch (name) {
      case "execute_http_request", "report_vulnerability", "extract_from_response",
           "get_variable", "set_variable", "fuzz_parameter", "decode_encode",
           "search_in_response", "spider_links", "get_sitemap", "finish_run" -> true;
      default -> false;
    };
  }

  // ── Helpers ───────────────────────────────────────────────────────────────

  private HttpRequest buildRequest(String body, Duration timeout) {
    return HttpRequest.newBuilder()
        .uri(URI.create(API_URL))
        .timeout(timeout)
        .header("Content-Type", "application/json")
        .header("Authorization", "Bearer " + apiKey)
        .header("HTTP-Referer", SITE_URL)
        .header("X-Title", "BurpAI Pentester")
        .POST(HttpRequest.BodyPublishers.ofString(body))
        .build();
  }

  @SuppressWarnings("unchecked")
  private List<LlmClient.ToolCall> parseToolCalls(Map<String, Object> msg) {
    List<LlmClient.ToolCall> result = new ArrayList<>();
    Object tcObj = msg.get("tool_calls");
    if (!(tcObj instanceof List<?> list)) return result;

    for (Object o : list) {
      if (!(o instanceof Map<?, ?> tc)) continue;
      Object fnObj = tc.get("function");
      if (!(fnObj instanceof Map<?, ?> fn)) continue;

      String name = fn.get("name") != null ? String.valueOf(fn.get("name")) : null;
      if (name == null || name.isBlank()) continue;

      Object argsObj = fn.get("arguments");
      Map<String, Object> args = new HashMap<>();
      if (argsObj instanceof String s) {
        try {
          Object parsed = json.readValue(s, Object.class);
          if (parsed instanceof Map<?, ?> pm) args = (Map<String, Object>) pm;
        } catch (Exception ignored) {}
      } else if (argsObj instanceof Map<?, ?> am) {
        args = (Map<String, Object>) am;
      }
      result.add(new LlmClient.ToolCall(name, args));
    }
    return result;
  }

  private String extractError(String body) {
    if (body == null || body.isBlank()) return "(empty body)";
    try {
      @SuppressWarnings("unchecked")
      Map<String, Object> map = json.readValue(body, Map.class);
      Object err = map.get("error");
      if (err instanceof Map<?, ?> em) {
        Object msg = em.get("message");
        if (msg != null) return String.valueOf(msg);
      }
      if (err != null) return String.valueOf(err);
    } catch (Exception ignored) {}
    return truncate(body, 300);
  }

  private static String truncate(String s, int max) {
    if (s == null) return "";
    return s.length() <= max ? s : s.substring(0, max) + "...[truncated]";
  }

  private HttpResponse<String> sendWithTimeout(HttpRequest req, Duration timeout) throws Exception {
    var fut = http.sendAsync(req, HttpResponse.BodyHandlers.ofString());
    try {
      return fut.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException te) {
      fut.cancel(true);
      throw new HttpTimeoutException("OpenRouter request timed out after " + timeout.toSeconds() + "s");
    } catch (ExecutionException ee) {
      Throwable cause = ee.getCause();
      if (cause instanceof Exception e) throw e;
      throw new RuntimeException(cause);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw ie;
    }
  }
}
