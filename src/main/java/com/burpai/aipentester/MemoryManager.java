package com.burpai.aipentester;

import java.net.URI;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Thread-safe, structured memory for a single agent run.
 *
 * <p>All mutable state uses lock-free or concurrent primitives so that
 * {@link ToolExecutor} (which records HTTP events) and {@link AgentLoop}
 * (which reads the snapshot every iteration) can operate concurrently without
 * synchronised blocks.
 *
 * <p>Rather than producing verbose prose summaries, this class exposes a
 * {@link #buildSnapshot()} method that captures a deterministic, compact
 * {@link AgentStateSnapshot}. The snapshot's {@link AgentStateSnapshot#toPromptSignals()}
 * produces a tightly bounded signal block for LLM injection.
 */
class MemoryManager {

  // ── Tunables ──────────────────────────────────────────────────────────────

  /** Maximum number of recent observations to retain. */
  private static final int MAX_OBS = 8;

  // ── Thread-safe state ─────────────────────────────────────────────────────

  private final AtomicInteger              testedRequestCount = new AtomicInteger(0);
  private final Set<String>               uniqueEndpoints    = ConcurrentHashMap.newKeySet();
  private final Set<String>               discoveredParams   = ConcurrentHashMap.newKeySet();
  private final AtomicBoolean             wafDetected        = new AtomicBoolean(false);
  private final ConcurrentHashMap<Integer, AtomicInteger> statusHistogram = new ConcurrentHashMap<>();
  /** Bounded observation buffer. */
  private final CopyOnWriteArrayList<String> recentObservations = new CopyOnWriteArrayList<>();

  /** Dedup set for vulnerability reports — used by AgentLoop. */
  private final Set<String> reportedVulnKeys = ConcurrentHashMap.newKeySet();

  // ── HTTP recording ────────────────────────────────────────────────────────

  /**
   * Records one HTTP exchange. Called from {@link ToolExecutor} on every request.
   */
  void recordHttp(int requestId,
                  String method,
                  String url,
                  int status,
                  String purpose,
                  String requestBodyPreview,
                  String responseBodyPreview,
                  Map<String, List<String>> responseHeaders) {

    testedRequestCount.incrementAndGet();

    // Normalise endpoint key: method + path (strip query/fragment for dedup)
    uniqueEndpoints.add(method.toUpperCase(Locale.ROOT) + " " + stripQuery(url));

    // Extract and record query/body parameter names
    extractParamNames(url, requestBodyPreview).forEach(discoveredParams::add);

    // Status histogram — CAS-safe via AtomicInteger per bucket
    statusHistogram.computeIfAbsent(status, k -> new AtomicInteger(0)).incrementAndGet();

    // WAF / block signals
    String resp = responseBodyPreview == null ? "" : responseBodyPreview;
    String respLower = resp.toLowerCase(Locale.ROOT);
    if (status == 403 || status == 406 || status == 429
        || respLower.contains("access denied")
        || respLower.contains("request blocked")
        || respLower.contains("cloudflare")
        || respLower.contains("akamai")
        || respLower.contains("waf")) {
      wafDetected.set(true);
    }

    // Bounded observation buffer
    if (status == 405) {
      addObs("405 Method Not Allowed: " + method + " " + stripQuery(url));
    }
    if (status == 403 || status == 406 || status == 429) {
      addObs(status + " on " + method + " " + stripQuery(url) + " (WAF/ACL/rate-limit)");
    }
    if (responseHeaders != null) {
      for (var e : responseHeaders.entrySet()) {
        if (e.getKey() == null) continue;
        String k = e.getKey().toLowerCase(Locale.ROOT);
        if (k.equals("access-control-allow-origin")) {
          String v = e.getValue() != null && !e.getValue().isEmpty() ? e.getValue().get(0) : "?";
          addObs("CORS: Access-Control-Allow-Origin=" + v);
        }
      }
    }
  }

  // ── Snapshot / signals ────────────────────────────────────────────────────

  /**
   * Captures a point-in-time, immutable {@link AgentStateSnapshot}.
   * Called once per iteration by {@link AgentLoop}.
   */
  AgentStateSnapshot buildSnapshot() {
    Map<Integer, Integer> hist = new HashMap<>();
    statusHistogram.forEach((k, v) -> hist.put(k, v.get()));

    return new AgentStateSnapshot(
        testedRequestCount.get(),
        new HashSet<>(uniqueEndpoints),
        new HashSet<>(discoveredParams),
        wafDetected.get(),
        hist,
        new ArrayList<>(recentObservations)
    );
  }

  /**
   * Convenience: build snapshot then return compact prompt signals string.
   * This is the only memory string injected into the LLM context each iteration.
   */
  String toPromptSignals() {
    return buildSnapshot().toPromptSignals();
  }

  // ── Vulnerability dedup ───────────────────────────────────────────────────

  boolean alreadyReported(String key) {
    return key != null && !key.isBlank() && reportedVulnKeys.contains(key);
  }

  void markReported(String key) {
    if (key != null && !key.isBlank()) reportedVulnKeys.add(key);
  }

  // ── Private helpers ───────────────────────────────────────────────────────

  private void addObs(String s) {
    if (s == null || s.isBlank()) return;
    if (recentObservations.contains(s)) return; // deduplicate
    recentObservations.add(s);
    while (recentObservations.size() > MAX_OBS) recentObservations.remove(0);
  }

  /** Returns the URL stripped of query string and fragment. */
  private static String stripQuery(String url) {
    if (url == null) return "";
    try {
      URI u = new URI(url);
      return new URI(u.getScheme(), u.getAuthority(), u.getPath(), null, null).toString();
    } catch (Exception e) {
      int q = url.indexOf('?');
      return q < 0 ? url : url.substring(0, q);
    }
  }

  /**
   * Extracts parameter names from URL query string and simple form/JSON body previews.
   */
  private static Set<String> extractParamNames(String url, String bodyPreview) {
    Set<String> params = new LinkedHashSet<>();
    if (url != null) {
      int q = url.indexOf('?');
      if (q >= 0) {
        for (String pair : url.substring(q + 1).split("&")) {
          String name = pair.split("=")[0];
          if (!name.isBlank()) params.add(name);
        }
      }
    }
    if (bodyPreview != null && !bodyPreview.isBlank()) {
      String b = bodyPreview.trim();
      if (b.startsWith("{")) {
        var m = java.util.regex.Pattern.compile("\"([^\"]{1,40})\"\\s*:").matcher(b);
        while (m.find()) params.add(m.group(1));
      } else if (b.contains("=")) {
        for (String pair : b.split("&")) {
          String name = pair.split("=")[0];
          if (!name.isBlank()) params.add(name);
        }
      }
    }
    return params;
  }
}

