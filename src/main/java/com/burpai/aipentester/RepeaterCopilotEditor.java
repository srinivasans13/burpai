package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.core.ToolType;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.ui.Selection;
import burp.api.montoya.ui.editor.extension.EditorCreationContext;
import burp.api.montoya.ui.editor.extension.ExtensionProvidedHttpRequestEditor;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;


/**
 * RepeaterCopilotEditor – adds an "AI Copilot" tab directly inside every
 * Repeater tab's request editor panel (alongside Raw / Pretty / Hex).
 *
 * One instance is created per Repeater tab by the HttpRequestEditorProvider
 * registered in Extension.java.
 *
 * Burp calls setRequestResponse() after every request/response cycle, so we
 * hook in there to trigger automatic AI analysis – no HTTP handler needed.
 */
public class RepeaterCopilotEditor implements ExtensionProvidedHttpRequestEditor {

  private final MontoyaApi       api;
  private final ToolType         toolType;
  private final RepeaterCopilot  copilot;

  // ── UI ────────────────────────────────────────────────────────────────────
  private final JPanel     root       = new JPanel(new BorderLayout(4, 4));
  private final JTextField urlField   = new JTextField("http://localhost:11434", 24);
  private final JTextField modelField = new JTextField("glm-5:cloud", 22);
  private final JLabel     statusLbl   = new JLabel("Send a Repeater request to activate the copilot.");
  private final JTextArea  promptArea  = new JTextArea(2, 60);  // user-supplied focus/instruction
  private final JButton    analyzeBtn  = new JButton("⟳ Re-analyze");
  private final JTextArea  reasonArea  = new JTextArea();
  private final JTextArea  suggestArea = new JTextArea();  // editable so users can tweak
  private final JButton    approveBtn  = new JButton("✓ Approve");
  private final JButton    chainBtn    = new JButton("⟳ Analyze Again");
  private final JButton    rejectBtn   = new JButton("✗ Reject");
  private final JTextArea  logArea     = new JTextArea(3, 60);

  // ── State ─────────────────────────────────────────────────────────────────
  private volatile HttpRequest  currentRequest  = null;
  private volatile HttpRequest  pendingRequest  = null;  // suggested request – returned to Burp so Raw/Pretty/Hex sync
  private volatile String       lastRespHash    = "";  // de-dupe to avoid re-analyzing unchanged cycles

  // ── Constructor ───────────────────────────────────────────────────────────
  public RepeaterCopilotEditor(MontoyaApi api, EditorCreationContext ctx) {
    this.api      = api;
    this.toolType = ctx.toolSource().toolType();
    this.copilot  = new RepeaterCopilot(api);

    buildUi();
    wireUi();

    copilot.setCallbacks(
        s   -> SwingUtilities.invokeLater(() -> statusLbl.setText(s)),
        s   -> SwingUtilities.invokeLater(() -> appendLog(s)),
        sug -> SwingUtilities.invokeLater(() -> applySuggestion(sug)),
        rr  -> {}  // send path unused – user clicks Repeater's own Send button
    );
  }

  // ── ExtensionProvidedHttpRequestEditor contract ───────────────────────────

  /** Caption shown on the tab inside Repeater's message editor. */
  @Override
  public String caption() { return "AI Copilot"; }

  /** Only show this tab in Repeater (not in Proxy, Scanner, etc.). */
  @Override
  public boolean isEnabledFor(HttpRequestResponse rr) {
    return toolType == ToolType.REPEATER;
  }

  /**
   * Called by Burp whenever the displayed request/response changes –
   * i.e. after every "Send" in Repeater.  If there is a fresh response,
   * kick off async AI analysis automatically.
   */
  @Override
  public void setRequestResponse(HttpRequestResponse rr) {
    currentRequest = rr.request();
    pendingRequest = null;  // clear any previous suggestion when a new cycle arrives

    if (rr.response() == null) return;  // no response yet

    // De-duplicate: only re-analyze if the response actually changed
    String hash = responseFingerprint(rr);
    if (hash.equals(lastRespHash)) return;
    lastRespHash = hash;

    resetApprovalButtons(false);
    copilot.analyze(rr.request(), rr.response(), promptArea.getText().trim());
  }

  @Override
  public HttpRequest getRequest() {
    // Return the AI-suggested request when one is pending so Burp syncs Raw/Pretty/Hex.
    if (pendingRequest != null) return pendingRequest;
    return currentRequest != null ? currentRequest : HttpRequest.httpRequest();
  }

  @Override
  public boolean isModified() {
    // Tell Burp our editor has a modified request so it reads getRequest() and updates all tabs.
    return pendingRequest != null;
  }

  @Override
  public Selection selectedData() { return null; }

  @Override
  public Component uiComponent() { return root; }

  // ── UI construction ───────────────────────────────────────────────────────
  private void buildUi() {
    root.setBorder(new EmptyBorder(6, 6, 6, 6));

    // ── Settings strip ──
    JPanel settingsRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 2));
    settingsRow.add(new JLabel("Ollama URL:"));
    settingsRow.add(urlField);
    settingsRow.add(new JLabel("Model:"));
    settingsRow.add(modelField);

    // ── Prompt strip ──
    promptArea.setLineWrap(true);
    promptArea.setWrapStyleWord(true);
    promptArea.setFont(new Font("SansSerif", Font.PLAIN, 12));
    promptArea.setText("e.g. Focus on IDOR and auth bypass only");
    promptArea.setForeground(Color.GRAY);
    // Clear placeholder on first focus
    promptArea.addFocusListener(new java.awt.event.FocusAdapter() {
      public void focusGained(java.awt.event.FocusEvent e) {
        if (promptArea.getForeground() == Color.GRAY) {
          promptArea.setText("");
          promptArea.setForeground(UIManager.getColor("TextArea.foreground"));
        }
      }
    });
    analyzeBtn.setToolTipText("Re-run analysis with current prompt (without sending a new request)");
    JPanel promptRow = new JPanel(new BorderLayout(6, 0));
    promptRow.setBorder(javax.swing.BorderFactory.createTitledBorder("Prompt / Focus  (optional – guide what the AI should test)"));
    promptRow.add(new JScrollPane(promptArea), BorderLayout.CENTER);
    promptRow.add(analyzeBtn, BorderLayout.EAST);
    promptRow.setPreferredSize(new Dimension(0, 72));

    // ── Reasoning area ──
    reasonArea.setEditable(false);
    reasonArea.setLineWrap(true);
    reasonArea.setWrapStyleWord(true);
    reasonArea.setFont(new Font("SansSerif", Font.PLAIN, 12));
    reasonArea.setBackground(new Color(255, 253, 228));
    reasonArea.setText("Waiting for Repeater request/response cycle…");
    JPanel reasonPanel = titled("AI Reasoning", new JScrollPane(reasonArea));

    // ── Suggested request area ──
    suggestArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
    suggestArea.setTabSize(4);
    suggestArea.setText("(suggestion appears here)");
    JPanel suggestPanel = titled("Suggested Request  (editable – tweak before approving)",
                                  new JScrollPane(suggestArea));

    JSplitPane analysisSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT, reasonPanel, suggestPanel);
    analysisSplit.setResizeWeight(0.38);

    // ── Action buttons ──
    approveBtn.setBackground(new Color(180, 240, 180));
    approveBtn.setFont(approveBtn.getFont().deriveFont(Font.BOLD, 13f));
    chainBtn.setBackground(new Color(200, 220, 255));
    chainBtn.setFont(chainBtn.getFont().deriveFont(Font.BOLD, 13f));
    rejectBtn.setForeground(new Color(180, 0, 0));
    rejectBtn.setFont(rejectBtn.getFont().deriveFont(Font.BOLD, 13f));
    resetApprovalButtons(false);

    JPanel btnRow = new JPanel(new FlowLayout(FlowLayout.CENTER, 12, 4));
    btnRow.add(approveBtn);
    btnRow.add(chainBtn);
    btnRow.add(rejectBtn);

    // ── Log strip ──
    logArea.setEditable(false);
    logArea.setFont(new Font("Monospaced", Font.PLAIN, 11));
    logArea.setBackground(new Color(245, 245, 245));
    JPanel logPanel = titled("Copilot Log", new JScrollPane(logArea));
    logPanel.setPreferredSize(new Dimension(0, 80));

    // ── Status bar ──
    JPanel statusRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 2));
    statusRow.add(new JLabel("Status: "));
    statusRow.add(statusLbl);

    // ── Assemble ──
    JPanel top = new JPanel(new BorderLayout());
    JPanel topSettings = new JPanel(new BorderLayout());
    topSettings.add(settingsRow, BorderLayout.NORTH);
    topSettings.add(promptRow, BorderLayout.CENTER);
    top.add(topSettings, BorderLayout.NORTH);
    top.add(analysisSplit, BorderLayout.CENTER);
    top.add(btnRow, BorderLayout.SOUTH);

    JSplitPane mainSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT, top, logPanel);
    mainSplit.setResizeWeight(0.80);

    root.add(mainSplit, BorderLayout.CENTER);
    root.add(statusRow, BorderLayout.SOUTH);

    api.userInterface().applyThemeToComponent(root);
  }

  // ── Event wiring ──────────────────────────────────────────────────────────
  private void wireUi() {
    // Keep copilot in sync with field changes
    DocumentListener sync = new DocumentListener() {
      private void push() {
        copilot.configure(urlField.getText().trim(), modelField.getText().trim());
      }
      public void insertUpdate(DocumentEvent e)  { push(); }
      public void removeUpdate(DocumentEvent e)  { push(); }
      public void changedUpdate(DocumentEvent e) { push(); }
    };
    urlField.getDocument().addDocumentListener(sync);
    modelField.getDocument().addDocumentListener(sync);

    // ── Re-analyze button (manual trigger with current prompt) ──
    analyzeBtn.addActionListener(e -> {
      HttpRequest req = currentRequest;
      if (req == null) { statusLbl.setText("No request captured yet – send one in Repeater first."); return; }
      // We re-trigger analysis on the last captured response; reset hash so de-dupe doesn't block it
      lastRespHash = "";
      pendingRequest = null;
      resetApprovalButtons(false);
      copilot.analyze(req, null, promptArea.getForeground() == Color.GRAY ? "" : promptArea.getText().trim());
    });

    // ── Approve – lock suggestion into Repeater's Request panel; user clicks Send ──
    approveBtn.addActionListener(e -> {
      // pendingRequest is already set by applySuggestion(); isModified()==true keeps it
      // visible in Raw/Pretty/Hex.  Just confirm and update status.
      resetApprovalButtons(false);
      statusLbl.setText("Approved – click Send in Repeater to fire the request.");
      appendLog("[Copilot] Suggestion approved. Click Send in Repeater.\n");
    });

    // ── Analyze Again – re-run AI on the current response (with updated prompt) ──
    chainBtn.addActionListener(e -> {
      HttpRequest req = currentRequest;
      if (req == null) { statusLbl.setText("No request captured yet."); return; }
      resetApprovalButtons(false);
      lastRespHash = "";  // bypass dedup
      reasonArea.setText("Re-analyzing…");
      copilot.analyze(req, null, promptArea.getForeground() == Color.GRAY ? "" : promptArea.getText().trim());
    });

    // ── Reject ──
    rejectBtn.addActionListener(e -> {
      resetApprovalButtons(false);
      pendingRequest = null;  // stop claiming we have a modified request
      reasonArea.setText("Suggestion rejected.\n\nSend another Repeater request to get a new suggestion.");
      suggestArea.setText("");
      lastRespHash = "";  // allow re-analysis on the same response if user wants
      statusLbl.setText("Rejected – send a new request in Repeater.");
      appendLog("[Copilot] Suggestion rejected by user.\n");
    });
  }

  // ── Callbacks ─────────────────────────────────────────────────────────────
  private void applySuggestion(RepeaterCopilot.Suggestion sug) {
    if (sug == null) {
      reasonArea.setText("Failed to parse AI response.");
      return;
    }
    reasonArea.setText("[" + sug.testName + "]\n\n" + sug.reasoning);
    suggestArea.setText(sug.toDisplayString());
    suggestArea.setCaretPosition(0);

    // Build the suggested HttpRequest and store it so getRequest() / isModified()
    // propagate it to Raw / Pretty / Hex tabs automatically.
    // Strategy: start from the ORIGINAL request so all auth/session headers are
    // preserved by default; overlay only what the AI explicitly changed.
    try {
      pendingRequest = buildHttpRequest(currentRequest, sug);
    } catch (Exception ex) {
      api.logging().logToError("RepeaterCopilotEditor: could not build HttpRequest from suggestion: " + ex);
    }

    resetApprovalButtons(true);
  }

  /**
   * Builds a Montoya HttpRequest by overlaying the AI suggestion onto the
   * original request.  All headers from the original (auth, cookies, etc.) are
   * kept; the AI can add or override individual headers, change the method/URL,
   * and replace the body.
   */
  private static HttpRequest buildHttpRequest(HttpRequest original, RepeaterCopilot.Suggestion sug) {
    // Start from the original so every header (Authorization, Cookie, …) is present.
    HttpRequest req = original;

    // Override method if the AI changed it.
    if (sug.method != null && !sug.method.isBlank() && !sug.method.equalsIgnoreCase(original.method())) {
      req = req.withMethod(sug.method);
    }

    // Override URL/path if the AI changed it.
    if (sug.url != null && !sug.url.isBlank() && !sug.url.equals(original.url())) {
      // Use withPath() if only the path changed; fall back to full URL reconstruction.
      try {
        java.net.URI sugUri  = new java.net.URI(sug.url);
        java.net.URI origUri = new java.net.URI(original.url());
        if (sugUri.getHost() != null && !sugUri.getHost().equals(origUri.getHost())) {
          // Host changed – rebuild from scratch but copy original headers afterward.
          HttpRequest fresh = HttpRequest.httpRequestFromUrl(sug.url).withMethod(req.method());
          for (var h : req.headers()) fresh = fresh.withHeader(h);
          req = fresh;
        } else {
          // Same host – just update the path (+ query).
          String newPath = sugUri.getRawPath();
          if (sugUri.getRawQuery() != null) newPath += "?" + sugUri.getRawQuery();
          req = req.withPath(newPath);
        }
      } catch (Exception ignore) { /* keep original URL on parse error */ }
    }

    // Overlay headers the AI explicitly provided (add or replace, never remove originals).
    for (var entry : sug.headers.entrySet()) {
      req = req.withHeader(burp.api.montoya.http.message.HttpHeader.httpHeader(entry.getKey(), entry.getValue()));
    }

    // Replace body only if the AI supplied one.
    if (sug.body != null && !sug.body.isBlank()) {
      req = req.withBody(sug.body);
    }

    return req;
  }

  // ── Helpers ───────────────────────────────────────────────────────────────
  private void resetApprovalButtons(boolean enabled) {
    approveBtn.setEnabled(enabled);
    chainBtn.setEnabled(enabled);
    rejectBtn.setEnabled(enabled);
  }

  private void appendLog(String s) {
    logArea.append(s);
    logArea.setCaretPosition(logArea.getDocument().getLength());
  }

  private static String responseFingerprint(HttpRequestResponse rr) {
    if (rr.response() == null) return "";
    try {
      return rr.request().method() + " " + rr.request().url() + " "
          + rr.response().statusCode() + " "
          + Integer.toHexString(java.util.Objects.hashCode(rr.response().bodyToString()));
    } catch (Exception e) {
      return String.valueOf(System.nanoTime());
    }
  }

  private static JPanel titled(String title, Component inner) {
    JPanel p = new JPanel(new BorderLayout());
    p.setBorder(javax.swing.BorderFactory.createTitledBorder(title));
    p.add(inner, BorderLayout.CENTER);
    return p;
  }
}
