package com.burpai.aipentester;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Persistent, cross-session, structured memory for known targets.
 *
 * <p><b>Storage:</b> {@code ~/.burpai/target_memory.json} — a two-level map:
 * <pre>
 * {
 *   "juice-shop.herokuapp.com": {
 *     "waf":       { "data": {"detected":true,"vendor":"cloudflare"}, "keywords":["cloudflare","waf"], "saved_at":"..." },
 *     "auth_flow": { "data": {"type":"bearer_token","alg":"RS256"},   "keywords":["jwt","bearer"],     "saved_at":"..." },
 *     "params":    { "data": {"names":["q","email","password"]},      "keywords":["q","email"],        "saved_at":"..." }
 *   }
 * }
 * </pre>
 *
 * <p><b>Key contracts:</b>
 * <ul>
 *   <li>One entry per {@code factType} per domain — saves always upsert (no duplicates).</li>
 *   <li>Retrieval uses keyword-overlap scoring — no external DB or embedding model required.</li>
 *   <li>All I/O is synchronised on {@code this} for safe concurrent access.</li>
 *   <li>Any I/O failure is swallowed; the store degrades gracefully to no-op.</li>
 * </ul>
 */
class TargetMemoryStore {

  // ── Constants ─────────────────────────────────────────────────────────────

  private static final String STORE_DIR  = ".burpai";
  private static final String STORE_FILE = "target_memory.json";
  private static final Pattern WORD_RE   = Pattern.compile("[a-zA-Z0-9_\\-\\.]{2,}");
  private static final int     MAX_PROFILE_PARAMS    = 15;
  private static final int     MAX_PROFILE_ENDPOINTS = 20;

  // ── State ─────────────────────────────────────────────────────────────────

  private final File         storeFile;
  private final ObjectMapper json;
  private final AgentLogger  logger;

  /** In-memory image of the JSON file. Outer key = domain, inner key = factType. */
  private Map<String, Map<String, Map<String, Object>>> store = new LinkedHashMap<>();

  // ── Constructor ───────────────────────────────────────────────────────────

  TargetMemoryStore(AgentLogger logger) {
    this.logger = logger;
    this.json   = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    File dir    = new File(System.getProperty("user.home"), STORE_DIR);
    if (!dir.exists()) dir.mkdirs();
    this.storeFile = new File(dir, STORE_FILE);
    load();
  }

  // ── Public API ────────────────────────────────────────────────────────────

  /**
   * Saves (upserts) a structured fact for a target domain.
   *
   * @param domain      hostname, e.g. {@code juice-shop.herokuapp.com}
   * @param factType    short key, e.g. {@code waf}, {@code auth_flow}, {@code params}
   * @param data        the structured fact — any JSON-serialisable map
   */
  synchronized void saveTargetFact(String domain, String factType, Map<String, Object> data) {
    saveTargetFactInternal(normalise(domain), factType, data, true);
  }
  /**
   * Retrieves the raw serialized string for a given fact's \"serialized\" field.
   * Useful for restoring opaque state blobs like attack graph testing state.
   *
   * @param domain   target hostname
   * @param factType the fact key (e.g. {@code "attack_graph_state"})
   * @return the serialized string, or {@code null} if not found
   */
  synchronized String getFactData(String domain, String factType) {
    Map<String, Map<String, Object>> domainFacts = store.get(normalise(domain));
    if (domainFacts == null) return null;
    Map<String, Object> entry = domainFacts.get(factType);
    if (entry == null) return null;
    @SuppressWarnings("unchecked")
    Map<String, Object> data = (Map<String, Object>) entry.get("data");
    if (data == null) return null;
    Object serialized = data.get("serialized");
    return serialized != null ? String.valueOf(serialized) : null;
  }
  /** Internal upsert. {@code flush=false} defers {@link #persist()} for batch callers. */
  private void saveTargetFactInternal(String normDomain, String factType,
                                      Map<String, Object> data, boolean flush) {
    if (normDomain == null || normDomain.isBlank() || factType == null || factType.isBlank()) return;
    try {
      Map<String, Map<String, Object>> domainFacts =
          store.computeIfAbsent(normDomain, k -> new LinkedHashMap<>());

      Map<String, Object> entry = new LinkedHashMap<>();
      entry.put("data",     data);
      entry.put("keywords", extractKeywords(data));
      entry.put("saved_at", LocalDateTime.now()
          .format(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss")));

      domainFacts.put(factType, entry);
      if (flush) persist();
      logger.log("[TargetMemory] Saved fact [" + factType + "] for " + normDomain + "\n");
    } catch (Exception e) {
      logger.log("[TargetMemory] Failed to save fact: " + e.getMessage() + "\n");
    }
  }

  /**
   * Retrieves the top-K most relevant structured facts for a domain,
   * ranked by keyword overlap with {@code queryText}.
   *
   * @param domain    target hostname
   * @param queryText free text describing what you're looking for (e.g. "auth jwt token")
   * @param topK      maximum number of facts to return
   * @return ordered list of fact entries: each map has {@code "fact_type"} + all stored fields
   */
  synchronized List<Map<String, Object>> retrieveRelevantFacts(
      String domain, String queryText, int topK) {
    Map<String, Map<String, Object>> domainFacts = store.get(normalise(domain));
    if (domainFacts == null || domainFacts.isEmpty()) return List.of();

    Set<String> queryTokens = tokenise(queryText);

    record Scored(String type, Map<String, Object> entry, int score) {}
    List<Scored> scored = new ArrayList<>();

    for (var e : domainFacts.entrySet()) {
      @SuppressWarnings("unchecked")
      List<String> kw = (List<String>) e.getValue().getOrDefault("keywords", List.of());
      int overlap = 0;
      for (String k : kw) if (queryTokens.contains(k.toLowerCase(Locale.ROOT))) overlap++;
      // factType name itself contributes
      if (queryTokens.contains(e.getKey().toLowerCase(Locale.ROOT))) overlap += 2;
      scored.add(new Scored(e.getKey(), e.getValue(), overlap));
    }

    return scored.stream()
        .sorted(Comparator.comparingInt(Scored::score).reversed())
        .limit(topK)
        .map(s -> {
          Map<String, Object> out = new LinkedHashMap<>();
          out.put("fact_type", s.type());
          out.putAll(s.entry());
          return out;
        })
        .toList();
  }

  /**
   * Builds a concise {@code TARGET_PROFILE:} block from all stored facts for a domain.
   * Returns an empty string if no facts are stored yet.
   *
   * <p>The block is intended to be injected as a system message at the start of a run.
   * It is intentionally terse — only key=value pairs, no prose.
   */
  synchronized String buildTargetProfile(String domain) {
    Map<String, Map<String, Object>> domainFacts = store.get(normalise(domain));
    if (domainFacts == null || domainFacts.isEmpty()) return "";

    StringBuilder sb = new StringBuilder();
    sb.append("TARGET_PROFILE: ").append(domain).append(" (from prior sessions)\n");

    for (var e : domainFacts.entrySet()) {
      String factType = e.getKey();
      @SuppressWarnings("unchecked")
      Map<String, Object> data = (Map<String, Object>) e.getValue().getOrDefault("data", Map.of());
      if (data.isEmpty()) continue;

      // Render each fact as one compact line
      switch (factType) {
        case "waf" -> {
          Object detected = data.get("detected");
          Object vendor   = data.get("vendor");
          sb.append("waf=").append(detected);
          if (vendor != null && !"unknown".equals(vendor)) sb.append(" (").append(vendor).append(")");
          sb.append("\n");
        }
        case "auth_flow" -> {
          sb.append("auth=").append(data.getOrDefault("type", "?"));
          Object alg = data.get("alg");
          if (alg != null) sb.append("+").append(alg);
          sb.append("\n");
        }
        case "tech_stack" -> {
          sb.append("tech=").append(data.values().stream()
              .map(Object::toString).collect(Collectors.joining(","))).append("\n");
        }
        case "params" -> {
          @SuppressWarnings("unchecked")
          List<String> names = (List<String>) data.getOrDefault("names", List.of());
          if (!names.isEmpty()) {
            List<String> capped = names.stream().limit(MAX_PROFILE_PARAMS).toList();
            sb.append("known_params=").append(capped).append("\n");
          }
        }
        case "endpoints" -> {
          @SuppressWarnings("unchecked")
          List<String> eps = (List<String>) data.getOrDefault("paths", List.of());
          if (!eps.isEmpty()) {
            sb.append("prior_endpoints_count=").append(data.getOrDefault("count", eps.size())).append("\n");
            List<String> sample = eps.stream().limit(MAX_PROFILE_ENDPOINTS).toList();
            // Labelled as "hints" — do NOT treat these as already-tested; re-test with current session creds.
            sb.append("prior_endpoints_hint=").append(sample).append("\n");
          }
        }
        case "vuln_history" -> {
          sb.append("prior_vulns=").append(data).append("\n");
        }
        default -> {
          // Generic: render data map inline
          sb.append(factType).append("=").append(data).append("\n");
        }
      }
    }

    sb.append("NOTE: Cross-session hints only. prior_endpoints_hint are NOT skip-listed — re-test them with current session credentials.\n");
    return sb.toString();
  }

  /**
   * Auto-learns facts from a completed run and persists them.
   * Called from {@link AgentLoop} at the end of each run.
   *
   * @param targetBase  the base URL of the target (domain is extracted automatically)
   * @param snapshot    final {@link AgentStateSnapshot} from the run
   * @param vulnStore   confirmed + observed findings accumulated during the run
   */
  synchronized void learnFromRun(String targetBase,
                                  AgentStateSnapshot snapshot,
                                  List<Map<String, Object>> vulnStore) {
    if (targetBase == null || targetBase.isBlank()) return;
    String domain = normalise(extractDomain(targetBase));

    // WAF — only record detected=true; don't overwrite a true with false from a short run
    boolean currentWaf = snapshot.wafDetected();
    Map<String, Map<String, Object>> existing = store.getOrDefault(domain, Map.of());
    boolean priorWaf = false;
    if (existing.containsKey("waf")) {
      @SuppressWarnings("unchecked")
      Map<String, Object> wafData = (Map<String, Object>) existing.get("waf").getOrDefault("data", Map.of());
      priorWaf = Boolean.TRUE.equals(wafData.get("detected"));
    }
    saveTargetFactInternal(domain, "waf",
        Map.of("detected", currentWaf || priorWaf), false);

    // Params discovered this run (merge with any prior params)
    if (!snapshot.discoveredParams().isEmpty()) {
      Set<String> merged = new TreeSet<>(snapshot.discoveredParams());
      if (existing.containsKey("params")) {
        @SuppressWarnings("unchecked")
        Map<String, Object> pd = (Map<String, Object>) existing.get("params").getOrDefault("data", Map.of());
        @SuppressWarnings("unchecked")
        List<String> prior = (List<String>) pd.getOrDefault("names", List.of());
        merged.addAll(prior);
      }
      saveTargetFactInternal(domain, "params", Map.of("names", new ArrayList<>(merged)), false);
    }

    // Endpoint paths (path-only, normalised, deduped, merged with prior)
    if (!snapshot.uniqueEndpoints().isEmpty()) {
      Set<String> paths = new TreeSet<>();
      snapshot.uniqueEndpoints().stream()
          .map(ep -> ep.contains(" ") ? ep.substring(ep.indexOf(' ') + 1) : ep)
          .forEach(paths::add);
      if (existing.containsKey("endpoints")) {
        @SuppressWarnings("unchecked")
        Map<String, Object> ed = (Map<String, Object>) existing.get("endpoints").getOrDefault("data", Map.of());
        @SuppressWarnings("unchecked")
        List<String> prior = (List<String>) ed.getOrDefault("paths", List.of());
        paths.addAll(prior);
      }
      List<String> capped = paths.stream().limit(200).toList();
      saveTargetFactInternal(domain, "endpoints",
          Map.of("count", capped.size(), "paths", capped), false);
    }

    // Vulnerability history (severity counts)
    if (!vulnStore.isEmpty()) {
      Map<String, Long> sevCounts = new ArrayList<>(vulnStore).stream()
          .collect(Collectors.groupingBy(
              v -> AgentUtils.str(v.getOrDefault("severity", "Unknown")),
              Collectors.counting()));
      Map<String, Object> sevMap = new LinkedHashMap<>();
      sevCounts.forEach((k, v) -> sevMap.put(k, v));
      saveTargetFactInternal(domain, "vuln_history", sevMap, false);
    }

    // Single file write for the entire batch
    persist();
    logger.log("[TargetMemory] Learned from run — updated facts for " + domain + "\n");
  }

  // ── I/O ───────────────────────────────────────────────────────────────────

  private void load() {
    if (!storeFile.exists()) return;
    try {
      String content = Files.readString(storeFile.toPath(), StandardCharsets.UTF_8);
      store = json.readValue(content,
          new TypeReference<Map<String, Map<String, Map<String, Object>>>>() {});
      logger.log("[TargetMemory] Loaded " + store.size() + " domain(s) from " + storeFile + "\n");
    } catch (Exception e) {
      logger.log("[TargetMemory] Could not load store (" + e.getMessage() + ") — starting fresh\n");
      store = new LinkedHashMap<>();
    }
  }

  private void persist() {
    try {
      Files.writeString(storeFile.toPath(),
          json.writeValueAsString(store), StandardCharsets.UTF_8);
    } catch (Exception e) {
      logger.log("[TargetMemory] Persist failed: " + e.getMessage() + "\n");
    }
  }

  // ── Helpers ───────────────────────────────────────────────────────────────

  /** Extracts hostname from a URL for use as the store key. */
  static String extractDomain(String url) {
    if (url == null || url.isBlank()) return "unknown";
    try {
      String s = url.trim();
      if (!s.contains("://")) s = "https://" + s;
      return new java.net.URI(s).getHost();
    } catch (Exception e) {
      return url.replaceAll("https?://", "").replaceAll("/.*", "").trim();
    }
  }

  /** Normalises a domain for map lookup. */
  private static String normalise(String domain) {
    return domain == null ? "" : domain.trim().toLowerCase(Locale.ROOT);
  }

  /** Extracts lowercase tokens from a query or data map for keyword scoring. */
  private static Set<String> tokenise(String text) {
    if (text == null || text.isBlank()) return Set.of();
    Set<String> tokens = new LinkedHashSet<>();
    Matcher m = WORD_RE.matcher(text.toLowerCase(Locale.ROOT));
    while (m.find()) tokens.add(m.group());
    return tokens;
  }

  /** Extracts keywords from a data map by flattening all string values. */
  @SuppressWarnings("unchecked")
  private static List<String> extractKeywords(Map<String, Object> data) {
    List<String> kw = new ArrayList<>();
    if (data == null) return kw;
    for (var e : data.entrySet()) {
      kw.addAll(tokenise(e.getKey()));
      Object v = e.getValue();
      if (v instanceof String s)         kw.addAll(tokenise(s));
      else if (v instanceof Collection c) c.forEach(item -> kw.addAll(tokenise(String.valueOf(item))));
      else if (v instanceof Map m)        kw.addAll(extractKeywords(m));
      else if (v != null)                 kw.addAll(tokenise(v.toString()));
    }
    return kw.stream().distinct().toList();
  }
}
