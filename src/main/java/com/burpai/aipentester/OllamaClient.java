package com.burpai.aipentester;

import burp.api.montoya.logging.Logging;

import java.io.IOException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.TimeUnit;

import com.fasterxml.jackson.databind.ObjectMapper;

public class OllamaClient {

  private final String baseUrl;
  private final String model;
  private final Logging logging;
  private final HttpClient http;
  private final ObjectMapper json = new ObjectMapper();

  public OllamaClient(String baseUrl, String model, Logging logging) {
    this.baseUrl = baseUrl.endsWith("/") ? baseUrl.substring(0, baseUrl.length()-1) : baseUrl;
    this.model = model;
    this.logging = logging;
    this.http = HttpClient.newBuilder()
      .followRedirects(HttpClient.Redirect.NORMAL)
      // Burp environments often inherit corporate proxy settings; for local/private Ollama
      // this can cause hangs or unexpected routing. Force direct connections.
      .proxy(new NoProxySelector())
      .connectTimeout(Duration.ofSeconds(10))
        .build();
  }

  private static final class NoProxySelector extends ProxySelector {
    @Override
    public List<Proxy> select(URI uri) {
      return List.of(Proxy.NO_PROXY);
    }

    @Override
    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
      // Ignore; caller will see the request failure.
    }
  }

  public static class ConnResult {
    final boolean ok;
    final String message;
    ConnResult(boolean ok, String message) { this.ok = ok; this.message = message; }
  }

  public ConnResult testConnection() {
    logging.logToOutput("[DEBUG] testConnection() starting for: " + baseUrl);
    try {
      String url = baseUrl + "/api/tags";
      logging.logToOutput("[DEBUG] Building HTTP request to: " + url);
      
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .timeout(Duration.ofSeconds(5))
          .GET()
          .build();

      logging.logToOutput("[DEBUG] Sending HTTP request...");
      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(6));
      logging.logToOutput("[DEBUG] Got response with status: " + resp.statusCode());
      if (resp.statusCode() != 200) {
        String body = resp.body() == null ? "" : resp.body();
        if (body.length() > 500) body = body.substring(0, 500) + "...[truncated]";
        return new ConnResult(false, "Ollama returned status " + resp.statusCode() + ". Body: " + body);
      }

      Map<String,Object> data = json.readValue(resp.body(), Map.class);
      List<Map<String,Object>> models = (List<Map<String,Object>>) data.getOrDefault("models", new ArrayList<>());

      if (models.isEmpty()) {
        return new ConnResult(false, "Connected to Ollama, but no models found. Run 'ollama pull " + model + "'");
      }

      boolean found = models.stream().anyMatch(m -> {
        String name = String.valueOf(m.get("name"));
        // Check exact or base name (e.g. qwen2.5:7b matches qwen2.5)
        return model.equals(name) || name.startsWith(model + ":");
      });

      if (found) return new ConnResult(true, "Connected. Model '" + model + "' is ready.");
      
      String available = String.join(", ", models.stream().map(m -> String.valueOf(m.get("name"))).toList());
      return new ConnResult(false, "Connected but model '" + model + "' not found. Available: " + available);

    } catch (IllegalArgumentException ex) {
      logging.logToError("testConnection IllegalArgumentException: " + ex);
      return new ConnResult(false, "Invalid Ollama URL format: " + baseUrl);
    } catch (Throwable t) {
      logging.logToError("testConnection Throwable: " + t);
      try {
        t.printStackTrace();
      } catch (Throwable ignored) {
        // ignore
      }
      String msg = t.getMessage();
      if (msg == null || msg.isBlank()) msg = String.valueOf(t);
      return new ConnResult(false, "Connection error: " + t.getClass().getName() + ": " + msg);
    } finally {
      logging.logToOutput("[DEBUG] testConnection() completed");
    }
  }

  public static class ToolCall {
    final String name;
    final Map<String,Object> args;
    ToolCall(String name, Map<String,Object> args) { this.name = name; this.args = args; }
  }

  public static class ChatResult {
    final boolean ok;
    final String content;
    final List<ToolCall> toolCalls;
    final String error;

    private ChatResult(boolean ok, String content, List<ToolCall> toolCalls, String error) {
      this.ok = ok; this.content = content; this.toolCalls = toolCalls; this.error = error;
    }

    static ChatResult ok(String content, List<ToolCall> toolCalls) { return new ChatResult(true, content, toolCalls, null); }
    static ChatResult err(String error) { return new ChatResult(false, null, null, error); }
  }

  public ChatResult chat(List<Map<String,Object>> messages, List<Map<String,Object>> tools) {
    int attempts = 0;
    while (true) {
      attempts++;
      try {
      Map<String,Object> payload = new HashMap<>();
      payload.put("model", model);
      payload.put("stream", false);
      payload.put("messages", messages);
      payload.put("temperature", 0.7);
      payload.put("tools", tools);

      String body = json.writeValueAsString(payload);

      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(baseUrl + "/api/chat"))
          .timeout(Duration.ofSeconds(60))
          .header("Content-Type", "application/json")
          .POST(HttpRequest.BodyPublishers.ofString(body))
          .build();

      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(65));
      if (resp.statusCode() != 200) {
        return ChatResult.err("Ollama /api/chat status " + resp.statusCode() + " body=" + resp.body());
      }

      Map<String,Object> data = json.readValue(resp.body(), Map.class);
      Map<String,Object> msg = (Map<String,Object>) data.getOrDefault("message", new HashMap<>());

      String content = String.valueOf(msg.getOrDefault("content", ""));

      // tool_calls parsing: depends on model; support common shapes
      List<ToolCall> tcs = new ArrayList<>();
      Object tcObj = msg.get("tool_calls");
      if (tcObj == null) tcObj = data.get("tool_calls");

      if (tcObj instanceof List<?> list) {
        for (Object o : list) {
          if (!(o instanceof Map<?,?> m)) continue;

          String name = null;
          Object argsObj = null;

          // Shape A: { function: { name, arguments } }
          Object fnObj = m.get("function");
          if (fnObj instanceof Map<?,?> fn) {
            name = String.valueOf(fn.get("name"));
            argsObj = fn.get("arguments");
          }

          // Shape B: { name, arguments }
          if (name == null && m.get("name") != null) {
            name = String.valueOf(m.get("name"));
            argsObj = m.get("arguments");
          }

          if (name == null) continue;

          Map<String,Object> argsMap = new HashMap<>();
          if (argsObj instanceof Map<?,?> am) {
            argsMap = (Map<String,Object>) am;
          } else if (argsObj instanceof String s) {
            // Ollama commonly returns JSON string here
            try {
              Object parsed = json.readValue(s, Object.class);
              if (parsed instanceof Map<?,?> pm) argsMap = (Map<String,Object>) pm;
            } catch (Exception ignored) {
              // keep empty
            }
          }

          tcs.add(new ToolCall(name, argsMap));
        }
      }

      return ChatResult.ok(content, tcs);

      } catch (java.net.ConnectException | java.net.SocketTimeoutException | HttpTimeoutException e) {
        if (attempts >= 3) {
          logging.logToError("Ollama chat failed after retries: " + e);
          String msg = e.getMessage();
          if (msg == null || msg.isBlank()) msg = String.valueOf(e);
          return ChatResult.err(e.getClass().getName() + ": " + msg);
        }
        long backoffMs = attempts == 1 ? 250 : (attempts == 2 ? 750 : 1500);
        logging.logToError("Ollama chat transient failure (attempt " + attempts + "): " + e + " ; retrying after " + backoffMs + "ms");
        try {
          Thread.sleep(backoffMs);
        } catch (InterruptedException ie) {
          Thread.currentThread().interrupt();
          return ChatResult.err("Interrupted while retrying Ollama call");
        }
      } catch (Throwable t) {
        logging.logToError("Ollama chat failed: " + t);
        String msg = t.getMessage();
        if (msg == null || msg.isBlank()) msg = String.valueOf(t);
        return ChatResult.err(t.getClass().getName() + ": " + msg);
      }
    }
  }

  private HttpResponse<String> sendWithTimeout(HttpRequest req, Duration timeout) throws Exception {
    var fut = http.sendAsync(req, HttpResponse.BodyHandlers.ofString());
    try {
      return fut.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException te) {
      fut.cancel(true);
      logging.logToError("[DEBUG] HTTP timeout after " + timeout.toSeconds() + "s for " + req.method() + " " + req.uri());
      throw new HttpTimeoutException("Timed out after " + timeout.toSeconds() + "s");
    } catch (ExecutionException ee) {
      Throwable cause = ee.getCause();
      if (cause instanceof Exception e) throw e;
      throw new RuntimeException(cause);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw ie;
    } catch (CompletionException ex) {
      Throwable cause = ex.getCause();
      if (cause instanceof Exception e) throw e;
      throw ex;
    }
  }
}
