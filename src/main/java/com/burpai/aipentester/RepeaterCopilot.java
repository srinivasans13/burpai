package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpHeader;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.http.message.responses.HttpResponse;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;

/**
 * RepeaterCopilot – per-Repeater-tab AI analysis engine.
 *
 * One instance is created for each Repeater tab (via RepeaterCopilotEditor).
 * No HttpHandler is registered here: Montoya's ExtensionProvidedHttpRequestEditor
 * calls setRequestResponse() natively whenever the displayed request/response changes.
 */
public class RepeaterCopilot {

  //  Suggestion model 
  public static final class Suggestion {
    public final String reasoning;
    public final String testName;
    public final String method;
    public final String url;
    public final Map<String, String> headers;
    public final String body;

    public Suggestion(String reasoning, String testName, String method, String url,
                      Map<String, String> headers, String body) {
      this.reasoning = reasoning;
      this.testName  = testName;
      this.method    = method;
      this.url       = url;
      this.headers   = headers;
      this.body      = body;
    }

    /** Human-readable raw-request form for display in the textarea. */
    public String toDisplayString() {
      StringBuilder sb = new StringBuilder();
      sb.append(method).append(" ").append(url).append(" HTTP/1.1\n");
      headers.forEach((k, v) -> sb.append(k).append(": ").append(v).append("\n"));
      if (body != null && !body.isBlank()) sb.append("\n").append(body);
      return sb.toString();
    }
  }

  //  State 
  private final MontoyaApi   api;
  private final ObjectMapper json = new ObjectMapper();

  private volatile String ollamaUrl = "http://localhost:11434";
  private volatile String model     = "qwen3-coder-next:cloud";

  private volatile Suggestion pendingSuggestion = null;

  //  Callbacks -> UI 
  private volatile Consumer<String>              onStatus;
  private volatile Consumer<String>              onLog;
  private volatile Consumer<Suggestion>          onSuggestionReady;
  private volatile Consumer<HttpRequestResponse> onApprovalResult;

  //  Worker thread 
  private final ExecutorService worker = Executors.newSingleThreadExecutor(r -> {
    Thread t = new Thread(r, "repeater-copilot-worker");
    t.setDaemon(true);
    return t;
  });

  //  Constructor 
  public RepeaterCopilot(MontoyaApi api) {
    this.api = api;
  }

  //  Configuration 
  public void configure(String ollamaUrl, String model) {
    this.ollamaUrl = ollamaUrl;
    this.model     = model;
  }

  public void setCallbacks(Consumer<String>              onStatus,
                           Consumer<String>              onLog,
                           Consumer<Suggestion>          onSuggestionReady,
                           Consumer<HttpRequestResponse> onApprovalResult) {
    this.onStatus          = onStatus;
    this.onLog             = onLog;
    this.onSuggestionReady = onSuggestionReady;
    this.onApprovalResult  = onApprovalResult;
  }

  //  Analysis 
  /** Kick off async AI analysis of a req/resp cycle. Returns immediately. */
  public void analyze(HttpRequest req, HttpResponse resp) {
    analyze(req, resp, "");
  }

  /** Kick off async AI analysis with an optional user-supplied focus prompt. */
  public void analyze(HttpRequest req, HttpResponse resp, String userPrompt) {
    String u = this.ollamaUrl;
    String m = this.model;
    String p = userPrompt == null ? "" : userPrompt.trim();
    status("Analyzing with AI" + (p.isBlank() ? "…" : " (‘" + truncate(p, 40) + "’)…"));
    pendingSuggestion = null;
    worker.submit(() -> doAnalyze(req, resp, u, m, p));
  }

  private void doAnalyze(HttpRequest req, HttpResponse resp, String baseUrl, String modelName, String userPrompt) {
    try {
      log("[Copilot] Analyzing " + req.method() + " " + req.url() + "\n");

      OllamaClient client = new OllamaClient(baseUrl, modelName, api.logging());

      String reqStr  = buildRequestString(req);
      String respStr = resp != null ? buildResponseString(resp) : "(not yet available – analyze triggered manually)";

      String focusClause = userPrompt != null && !userPrompt.isBlank()
          ? "\n\nUSER INSTRUCTION: " + userPrompt
          : "";

      String sysPrompt =
          "You are a penetration testing copilot embedded inside Burp Suite Repeater.\n" +
          "Analyze the HTTP request/response and suggest ONE concrete next security test.\n" +
          "Focus: SQLi, XSS, IDOR, SSRF, auth bypass, parameter tampering, header injection,\n" +
          "       business logic flaws, path traversal, CORS misconfigurations." +
          focusClause + "\n\n" +
          "Reply with ONLY a single valid JSON object – no markdown, no extra text:\n" +
          "{\n" +
          "  \"reasoning\": \"<why this test matters for this specific endpoint>\",\n" +
          "  \"test_name\": \"<short label, e.g. SQLi in userId param>\",\n" +
          "  \"method\": \"<HTTP method>\",\n" +
          "  \"url\": \"<full URL with any modified query params>\",\n" +
          "  \"headers\": {\"<Name>\": \"<value>\"},\n" +
          "  \"body\": \"<body or empty string>\"\n" +
          "}";

      String userMsg =
          "=== CURRENT REQUEST ===\n" + reqStr +
          "\n\n=== CURRENT RESPONSE ===\n" + respStr +
          (userPrompt != null && !userPrompt.isBlank()
              ? "\n\nFOCUS: " + userPrompt
              : "") +
          "\n\nSuggest ONE specific next penetration test.";

      @SuppressWarnings("unchecked")
      List<Map<String, Object>> messages = List.of(
          Map.of("role", "system", "content", sysPrompt),
          Map.of("role", "user",   "content", userMsg)
      );

      var result = client.chat(messages, List.of());  // plain JSON reply, no tool-use
      if (!result.ok) {
        status("AI error: " + result.error);
        log("[Copilot] AI error: " + result.error + "\n");
        return;
      }

      // Strip accidental markdown fences
      String raw = result.content == null ? "" : result.content.trim();
      if (raw.startsWith("```")) {
        raw = raw.replaceAll("(?s)^```[a-zA-Z]*\\n?", "").replaceAll("```\\s*$", "").trim();
      }

      Suggestion sug = parseSuggestion(raw);
      pendingSuggestion = sug;
      log("[Copilot] Suggestion ready: " + (sug != null ? sug.testName : "parse error") + "\n");

      if (onSuggestionReady != null) onSuggestionReady.accept(sug);
      status("Suggestion ready – Approve, Chain, or Reject");

    } catch (Exception e) {
      api.logging().logToError("RepeaterCopilot.doAnalyze: " + e);
      status("Error: " + e.getMessage());
      log("[Copilot] Crashed: " + e + "\n");
    }
  }

  //  Approval 
  /** Sends the pending suggestion through Burp's HTTP engine. Returns null on failure. */
  public HttpRequestResponse approveSuggestion() {
    Suggestion sug = pendingSuggestion;
    if (sug == null || sug.url == null || sug.url.isBlank()) {
      log("[Copilot] No pending suggestion.\n");
      return null;
    }
    try {
      status("Sending approved request");
      log("[Copilot] Approving: " + sug.method + " " + sug.url + "\n");

      HttpRequest req = HttpRequest.httpRequestFromUrl(sug.url).withMethod(sug.method);
      for (var entry : sug.headers.entrySet()) {
        req = req.withHeader(HttpHeader.httpHeader(entry.getKey(), entry.getValue()));
      }
      if (sug.body != null && !sug.body.isBlank()) req = req.withBody(sug.body);

      HttpRequestResponse rr = api.http().sendRequest(req);
      int code = rr.response() != null ? rr.response().statusCode() : -1;
      log("[Copilot] Response: HTTP " + code + "\n");
      status("Sent – HTTP " + code);
      if (onApprovalResult != null) onApprovalResult.accept(rr);
      return rr;

    } catch (Exception e) {
      api.logging().logToError("RepeaterCopilot.approveSuggestion: " + e);
      status("Send failed: " + e.getMessage());
      log("[Copilot] Send failed: " + e + "\n");
      return null;
    }
  }

  /** Approve current suggestion, then immediately re-analyze the resulting response. */
  public void approveAndChain() {
    approveAndChain("");
  }

  public void approveAndChain(String userPrompt) {
    worker.submit(() -> {
      HttpRequestResponse rr = approveSuggestion();
      if (rr != null && rr.response() != null) {
        log("[Copilot] Chaining – re-analyzing result…\n");
        analyze(rr.request(), rr.response(), userPrompt);
      }
    });
  }

  //  Helpers 
  private Suggestion parseSuggestion(String raw) {
    try {
      @SuppressWarnings("unchecked")
      Map<String, Object> map = json.readValue(raw, Map.class);

      Map<String, String> headers = new LinkedHashMap<>();
      Object hObj = map.get("headers");
      if (hObj instanceof Map<?, ?> hm) {
        for (var e : hm.entrySet()) headers.put(str(e.getKey()), str(e.getValue()));
      }
      return new Suggestion(
          str(map.get("reasoning")),
          str(map.getOrDefault("test_name", "Unnamed test")),
          str(map.getOrDefault("method", "GET")).toUpperCase(),
          str(map.get("url")),
          headers,
          str(map.getOrDefault("body", ""))
      );
    } catch (Exception e) {
      api.logging().logToError("RepeaterCopilot: JSON parse failed | raw=" + raw + " | " + e);
      return new Suggestion(
          "AI response could not be parsed.\n\nRaw output:\n" + raw,
          "Parse Error", "GET", "", Map.of(), "");
    }
  }

  static String buildRequestString(HttpRequest req) {
    StringBuilder sb = new StringBuilder();
    sb.append(req.method()).append(" ").append(req.url()).append("\n");
    try { for (var h : req.headers()) sb.append(h.name()).append(": ").append(h.value()).append("\n"); }
    catch (Exception ignored) {}
    sb.append("\n");
    try {
      String body = req.bodyToString();
      if (body != null && !body.isBlank()) sb.append(body);
    } catch (Exception ignored) {}
    return sb.toString();
  }

  static String buildResponseString(HttpResponse resp) {
    if (resp == null) return "(no response)";
    StringBuilder sb = new StringBuilder();
    sb.append("HTTP ").append(resp.statusCode()).append("\n");
    try { for (var h : resp.headers()) sb.append(h.name()).append(": ").append(h.value()).append("\n"); }
    catch (Exception ignored) {}
    sb.append("\n");
    try {
      String body = resp.bodyToString();
      if (body != null) {
        if (body.length() > 3000) body = body.substring(0, 3000) + "\n...[truncated]";
        sb.append(body);
      }
    } catch (Exception ignored) {}
    return sb.toString();
  }

  private static String str(Object o) { return o == null ? "" : String.valueOf(o); }
  private static String truncate(String s, int max) { return s.length() <= max ? s : s.substring(0, max) + "…"; }
  private void status(String s) { if (onStatus != null) onStatus.accept(s); }
  private void log(String s)    { if (onLog    != null) onLog.accept(s);    }
}
