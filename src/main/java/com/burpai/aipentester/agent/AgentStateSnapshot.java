package com.burpai.aipentester.agent;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.burpai.aipentester.model.AttackGraph;
import com.burpai.aipentester.model.EndpointNode;
import com.burpai.aipentester.model.VulnClass;

/**
 * Immutable, JSON-serialisable snapshot of the agent's deterministic run state.
 *
 * <p>Captured at the start of every iteration via {@link MemoryManager#buildSnapshot()}.
 * Only compact scalar values and small bounded collections are included — no prose.
 */
record AgentStateSnapshot(
    int                    testedRequestCount,
    Set<String>            uniqueEndpoints,
    Set<String>            discoveredParams,
    boolean                wafDetected,
    Map<Integer, Integer>  statusHistogram,
    List<String>           recentObservations,
    Map<String, String>    storedVariables
) {
  /**
   * Canonical constructor — defensively copies all collections so the snapshot is truly
   * immutable even if the originating {@link MemoryManager} continues to evolve.
   */
  AgentStateSnapshot {
    uniqueEndpoints    = Collections.unmodifiableSet(Set.copyOf(uniqueEndpoints));
    discoveredParams   = Collections.unmodifiableSet(Set.copyOf(discoveredParams));
    statusHistogram    = Collections.unmodifiableMap(Map.copyOf(statusHistogram));
    recentObservations = Collections.unmodifiableList(List.copyOf(recentObservations));
    storedVariables    = Collections.unmodifiableMap(Map.copyOf(storedVariables));
  }

  /**
   * Renders a compact one-block signal string for LLM context injection.
   * Intentionally uses key=value notation — no verbose prose.
   *
   * <p>Example output:
   * <pre>
   * STATE_SIGNALS:
   * tested_count=23 | waf_detected=true | endpoints_seen=12 | params_seen=8
   * status=[200x45,500x3,403x1]
   * new_params=["q","id","email","token"]
   * recent_obs=["CORS wildcard detected","403 on GET /admin"]
   * RULE: Do NOT repeat any endpoint+method already tested. Only call tools with NEW targets.
   * </pre>
   */
  String toPromptSignals() {
    StringBuilder sb = new StringBuilder("STATE_SIGNALS:\n");

    // ── Line 1: scalar counters ──────────────────────────────────────────────
    sb.append("tested_count=").append(testedRequestCount)
      .append(" | waf_detected=").append(wafDetected)
      .append(" | endpoints_seen=").append(uniqueEndpoints.size())
      .append(" | params_seen=").append(discoveredParams.size())
      .append("\n");

    // ── Line 2: status histogram (sorted by code) ────────────────────────────
    if (!statusHistogram.isEmpty()) {
      sb.append("status=[");
      statusHistogram.entrySet().stream()
          .sorted(Map.Entry.comparingByKey())
          .forEach(e -> sb.append(e.getKey()).append("x").append(e.getValue()).append(","));
      sb.setLength(sb.length() - 1); // trim trailing comma
      sb.append("]\n");
    }

    // ── Line 3: tested endpoints (capped at 40) — LLM MUST see these to avoid repeats ──
    if (!uniqueEndpoints.isEmpty()) {
      sb.append("already_tested=");
      List<String> sorted = uniqueEndpoints.stream().sorted().limit(40).toList();
      sb.append(toJsonArray(sorted)).append("\n");
    }

    // ── Line 4: known params (capped at 20) ─────────────────────────────────
    if (!discoveredParams.isEmpty()) {
      sb.append("known_params=");
      List<String> sorted = discoveredParams.stream().sorted().limit(20).toList();
      sb.append(toJsonArray(sorted)).append("\n");
    }

    // ── Line 5: recent observations (capped at last 6) ───────────────────────
    List<String> obs = recentObservations;
    if (obs.size() > 6) obs = obs.subList(obs.size() - 6, obs.size());
    if (!obs.isEmpty()) {
      sb.append("recent_obs=").append(toJsonArray(obs)).append("\n");
    }

    // ── Line 6: stored variables — LLM MUST chain these into subsequent requests ──
    if (!storedVariables.isEmpty()) {
      sb.append("stored_vars: The following variables are set and MUST be used in subsequent requests where relevant — ");
      sb.append("use {{var_name}} syntax for interpolation:\n");
      storedVariables.entrySet().stream()
          .sorted(Map.Entry.comparingByKey())
          .forEach(e -> sb.append("  {{")
              .append(e.getKey())
              .append("}} = ")
              .append(e.getValue().length() > 80
                  ? e.getValue().substring(0, 80) + "..."
                  : e.getValue())
              .append("\n"));
      sb.append("RULE: Do NOT call extract_from_response or set_variable for variables already listed above.\n");
    }

    sb.append("RULE: Do NOT call any tool on an endpoint already in already_tested with the same method. Only NEW targets.\n");
    return sb.toString();
  }

  /**
   * Builds an attack-graph signal block for LLM context injection.
   *
   * <p>Returns an empty string if there are no suggested next targets,
   * so calibration cost is zero when the graph is empty.
   *
   * @param graph            the current run's attack graph
   * @param currentVulnClass the vuln class being tested this run
   * @return compact signal string, or empty string if nothing to report
   */
  static String buildGraphSignals(AttackGraph graph, String currentVulnClass) {
    if (graph == null) return "";
    if (currentVulnClass == null || currentVulnClass.isBlank()) currentVulnClass = VulnClass.GENERAL;

    List<String> nextTargets = graph.suggestNextTargets(currentVulnClass, 4);
    if (nextTargets.isEmpty()) return "";

    int untestedCount = graph.untestedParamsCount(currentVulnClass);

    StringBuilder sb = new StringBuilder("\nATTACK GRAPH SIGNALS:\n");
    sb.append("next_targets=").append(toJsonArray(nextTargets)).append("\n");
    sb.append("untested_params_count=").append(untestedCount).append("\n");

    // Only include auth_required_endpoints if any next_targets have authRequired == true
    List<String> authEndpoints = new java.util.ArrayList<>();
    for (EndpointNode node : graph.allNodes()) {
      if (Boolean.TRUE.equals(node.authRequired) && nextTargets.contains(node.path)) {
        authEndpoints.add(node.path);
      }
    }
    if (!authEndpoints.isEmpty()) {
      sb.append("auth_required_endpoints=").append(toJsonArray(authEndpoints)).append("\n");
    }

    return sb.toString();
  }

  private static String toJsonArray(List<String> items) {
    StringBuilder a = new StringBuilder("[");
    for (int i = 0; i < items.size(); i++) {
      if (i > 0) a.append(",");
      a.append("\"").append(items.get(i).replace("\"", "\\\"")).append("\"");
    }
    a.append("]");
    return a.toString();
  }
}
