package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpHeader;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import static burp.api.montoya.http.message.HttpHeader.httpHeader;

public class AgentEngine {

  private final MontoyaApi api;
  private final Consumer<String> log;
  private final BiConsumer<AgentTab.LogRow, HttpRequestResponse> addRow;
  private final Consumer<HttpRequestResponse> showEditors;

  private final AtomicInteger counter = new AtomicInteger(0);
  private volatile boolean running = false;
  private final ObjectMapper json = new ObjectMapper();
  private final String logFilePath;
  private volatile RunMemory runMemory = null;

  private static final class RunMemory {
    private final Deque<String> recent = new ArrayDeque<>();
    private final Map<Integer, Integer> statusCounts = new HashMap<>();
    private final Set<String> requestFingerprints = new HashSet<>();
    private final Set<String> reportedVulnKeys = new HashSet<>();
    private final Deque<String> observations = new ArrayDeque<>();
    private int maxRecent = 12;
    private int maxObs = 10;

    void recordHttp(int requestId,
                   String method,
                   String url,
                   int status,
                   String purpose,
                   String requestBodyPreview,
                   String responseBodyPreview,
                   Map<String, List<String>> responseHeaders) {
      String bodyHash = Integer.toHexString(Objects.hash(requestBodyPreview == null ? "" : requestBodyPreview));
      String fp = method + " " + url + " body#" + bodyHash;
      requestFingerprints.add(fp);

      statusCounts.merge(status, 1, Integer::sum);

      String shortPurpose = purpose == null ? "" : purpose.trim();
      if (shortPurpose.length() > 80) shortPurpose = shortPurpose.substring(0, 80) + "...";
      String line = "#" + requestId + " " + method + " " + url + " -> " + status + (shortPurpose.isBlank() ? "" : (" | " + shortPurpose));
      recent.addLast(line);
      while (recent.size() > maxRecent) recent.removeFirst();

      String resp = responseBodyPreview == null ? "" : responseBodyPreview;
      String respLower = resp.toLowerCase(Locale.ROOT);

      // Lightweight heuristics to help the model avoid repeating and to infer WAF-ish behavior.
      if (status == 405) {
        addObs("Observed 405 Method Not Allowed on " + method + " " + url + ".");
      }
      if (status == 403 || status == 406 || status == 429) {
        addObs("Observed " + status + " on " + method + " " + url + " (possible WAF/rate-limit/ACL)." );
      }
      if (respLower.contains("access denied") || respLower.contains("request blocked") || respLower.contains("waf") || respLower.contains("cloudflare") || respLower.contains("akamai")) {
        addObs("Response body contains block/WAF indicators on " + method + " " + url + ".");
      }
      if (resp.contains("\"reference\":null") && resp.contains("\"codes\":null")) {
        addObs("Unknown/invalid reference appears to return {reference:null,codes:null}.");
      }

      // CORS hints
      if (responseHeaders != null) {
        for (var e : responseHeaders.entrySet()) {
          if (e.getKey() == null) continue;
          String k = e.getKey().toLowerCase(Locale.ROOT);
          if (k.equals("access-control-allow-origin")) {
            addObs("CORS: Access-Control-Allow-Origin present.");
          }
        }
      }
    }

    private void addObs(String s) {
      if (s == null || s.isBlank()) return;
      if (observations.contains(s)) return;
      observations.addLast(s);
      while (observations.size() > maxObs) observations.removeFirst();
    }

    String summary() {
      StringBuilder sb = new StringBuilder();
      sb.append("MEMORY: summary of what has already been tested (avoid repeats).\n");
      if (!statusCounts.isEmpty()) {
        sb.append("- Status counts: ");
        var keys = new ArrayList<>(statusCounts.keySet());
        keys.sort(Integer::compareTo);
        for (int i = 0; i < keys.size(); i++) {
          Integer k = keys.get(i);
          if (i > 0) sb.append(", ");
          sb.append(k).append("x").append(statusCounts.get(k));
        }
        sb.append("\n");
      }
      if (!recent.isEmpty()) {
        sb.append("- Recent requests:\n");
        for (String r : recent) sb.append("  ").append(r).append("\n");
      }
      if (!observations.isEmpty()) {
        sb.append("- Observations:\n");
        for (String o : observations) sb.append("  - ").append(o).append("\n");
      }
      sb.append("RULE: If you propose a test, it MUST be a NEW request (new endpoint/method/payload).\n");
      return sb.toString();
    }

    boolean alreadyReported(String key) {
      if (key == null || key.isBlank()) return false;
      return reportedVulnKeys.contains(key);
    }

    void markReported(String key) {
      if (key == null || key.isBlank()) return;
      reportedVulnKeys.add(key);
    }
  }

  public AgentEngine(MontoyaApi api,
                     Consumer<String> log,
                     BiConsumer<AgentTab.LogRow, HttpRequestResponse> addRow,
                     Consumer<HttpRequestResponse> showEditors) {
    this.api = api;
    this.log = log;
    this.addRow = addRow;
    this.showEditors = showEditors;
    this.logFilePath = initLogFile();
    if (logFilePath != null) {
      logMessage("[INFO] Persistent logging enabled: " + logFilePath + "\n");
    }
  }

  private String initLogFile() {
    try {
      String home = System.getProperty("user.home");
      File dir = new File(home, "burpai_logs");
      if (!dir.exists()) dir.mkdirs();

      String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
      File logFile = new File(dir, "agent_" + timestamp + ".log");

      try (PrintWriter out = new PrintWriter(new FileWriter(logFile, true))) {
        out.println("=== Agent Session Initialized: " + LocalDateTime.now() + " ===");
        out.println("=== Log file: " + logFile.getAbsolutePath() + " ===");
      }
      return logFile.getAbsolutePath();
    } catch (Exception e) {
      api.logging().logToError("Failed to initialize log file: " + e.getMessage());
      return null;
    }
  }

  private void logMessage(String msg) {
    log.accept(msg);
    if (logFilePath != null) {
      try (PrintWriter out = new PrintWriter(new FileWriter(logFilePath, true))) {
        out.print(msg);
        out.flush();
      } catch (Exception e) {
        // Ignore logging failures to file
      }
    }
  }

  public void stop() {
    running = false;
    logMessage("\n[INFO] Stop requested.\n");
  }

  public void testConnection(String baseUrl, String model) {
    logMessage("\n[DEBUG] Testing connection to: " + baseUrl + " with model: " + model + "\n");
    api.logging().logToOutput("[AgentEngine] testConnection() method entered");
    try {
      api.logging().logToOutput("[AgentEngine] Creating OllamaClient...");
      OllamaClient client = new OllamaClient(baseUrl, model, api.logging());
      api.logging().logToOutput("[AgentEngine] Calling client.testConnection()...");
      var res = client.testConnection();
      api.logging().logToOutput("[AgentEngine] Got result from client.testConnection()");
      logMessage("\n" + "=".repeat(60) + "\n");
      logMessage("CONNECTION TEST RESULT\n");
      logMessage("Ollama URL: " + baseUrl + "\n");
      logMessage("Model: " + model + "\n");
      logMessage(res.ok ? "[SUCCESS] " : "[FAILED] ");
      logMessage(res.message + "\n");
      logMessage("=".repeat(60) + "\n\n");
    } catch (Throwable t) {
      String msg = t.getMessage();
      if (msg == null || msg.isBlank()) msg = String.valueOf(t);
      logMessage("[ERROR] Connection test crashed: " + t.getClass().getName() + ": " + msg + "\n");
      api.logging().logToError("testConnection crashed: " + t);
      try {
        t.printStackTrace();
      } catch (Throwable ignored) {
        // ignore
      }
    } finally {
      api.logging().logToOutput("[AgentEngine] testConnection() method exiting");
    }
  }

  public void singleTurn(String baseUrl, String model, String targetBase,
                         Imported imported, String userPrompt) {
    runAgent(baseUrl, model, targetBase, 1, false, imported, userPrompt);
  }

  public void runAgent(String baseUrl, String model, String targetBase,
                       int maxIter, boolean autoMode,
                       Imported imported, String userPrompt) {
    api.logging().logToOutput("[AgentEngine] runAgent() method entered");
    logMessage("\n[DEBUG] runAgent() called\n");
    running = true;

    this.runMemory = new RunMemory();

    try {
      api.logging().logToOutput("[AgentEngine] Creating OllamaClient for agent...");
      OllamaClient client = new OllamaClient(baseUrl, model, api.logging());

      logMessage("\n" + "=".repeat(80) + "\n");
      logMessage("STARTING AGENT\n");
      logMessage("Max iterations: " + maxIter + "\n");
      logMessage("Auto mode: " + autoMode + "\n");
      logMessage("=".repeat(80) + "\n\n");

      // Very simple initial seed:
      List<Map<String,Object>> messages = new ArrayList<>();
      messages.add(msg("system", systemPrompt()));
      messages.add(msg("user", seedPrompt(imported, userPrompt, targetBase)));

      int noToolStreak = 0;

      for (int i = 1; running && i <= maxIter; i++) {
        logMessage("\n--- ITERATION " + i + "/" + maxIter + " ---\n");
        api.logging().logToOutput("[AgentEngine] Starting iteration " + i);

        // Provide a compact memory snapshot so the model does not forget earlier requests/patterns.
        upsertMemoryMessage(messages, runMemory == null ? "" : runMemory.summary());
        pruneMessages(messages);

        var resp = client.chat(messages, toolSchema());
        api.logging().logToOutput("[AgentEngine] Got chat response, ok=" + resp.ok);

        if (!resp.ok) {
          logMessage("[ERROR] LLM call failed: " + resp.error + "\n");
          break;
        }

        // Add assistant content
        String content = resp.content == null ? "" : resp.content;
        if (!content.isBlank()) {
          logMessage("Agent: " + content + "\n\n");
          messages.add(msg("assistant", content));
        }

        // Execute tool calls if present
        if (resp.toolCalls != null && !resp.toolCalls.isEmpty()) {
          noToolStreak = 0;
          logMessage("[DEBUG] Processing " + resp.toolCalls.size() + " tool calls\n");
          for (OllamaClient.ToolCall tc : resp.toolCalls) {
            if ("execute_http_request".equals(tc.name)) {
              Map<String,Object> args = tc.args;

              String method = str(args.getOrDefault("method", "GET")).toUpperCase();
              String endpoint = str(args.getOrDefault("endpoint", "/"));
              String purpose = str(args.getOrDefault("purpose", ""));
              String expected = str(args.getOrDefault("expected", ""));
              Object bodyObj = args.get("body");
              String body = bodyObj == null ? null : String.valueOf(bodyObj);

              Map<String,String> headersMap = parseHeaders(args.get("headers"));

              ToolResult tr = executeHttpRequest(targetBase, method, endpoint, headersMap, body, purpose, expected);

              // Feed tool result back to LLM (OpenAI-style "tool" message)
              Map<String,Object> toolMsg = new HashMap<>();
              toolMsg.put("role", "tool");
              toolMsg.put("name", "execute_http_request");
              toolMsg.put("content", tr.toJson());
              messages.add(toolMsg);

            } else if ("report_vulnerability".equals(tc.name)) {
              String dedupKey = vulnDedupKey(tc.args);
              if (runMemory != null && runMemory.alreadyReported(dedupKey)) {
                String dupMsg = "Duplicate vulnerability report suppressed (already reported this issue with same evidence).";
                logMessage("[WARN] " + dupMsg + "\n");
                Map<String,Object> toolMsg = new HashMap<>();
                toolMsg.put("role", "tool");
                toolMsg.put("name", "report_vulnerability");
                toolMsg.put("content", ToolResult.error("report_vulnerability", "", dupMsg).toJson());
                messages.add(toolMsg);
                continue;
              }

              String validationError = validateVulnReportArgs(tc.args);
              if (validationError != null) {
                logMessage("[WARN] Rejected report_vulnerability: " + validationError + "\n");
                Map<String,Object> toolMsg = new HashMap<>();
                toolMsg.put("role", "tool");
                toolMsg.put("name", "report_vulnerability");
                toolMsg.put("content", ToolResult.error("report_vulnerability", "", validationError).toJson());
                messages.add(toolMsg);
                continue;
              }

              logMessage("\n" + "=".repeat(80) + "\n");
              logMessage("VULNERABILITY REPORTED\n");
              logMessage(tc.args.toString() + "\n");
              logMessage("=".repeat(80) + "\n\n");

              if (runMemory != null) runMemory.markReported(dedupKey);

              Map<String,Object> toolMsg = new HashMap<>();
              toolMsg.put("role", "tool");
              toolMsg.put("name", "report_vulnerability");
              toolMsg.put("content", "ok");
              messages.add(toolMsg);
            }
          }

          // Continue loop
          if (!autoMode) break;
          continue;
        }

        // No tool calls
        if (!autoMode) break;
        noToolStreak++;
        if (noToolStreak >= 2) {
          logMessage("[WARN] No tool calls twice; stopping.\n");
          break;
        }
        // Nudge the model to either call a tool or explicitly finish.
        messages.add(msg("system",
            "Auto-mode requires progress via tools. If you need more information, call execute_http_request now. " +
            "If you cannot proceed due to scope or missing input, provide a brief final answer and do not invent results."));
      }

    } catch (Exception ex) {
      api.logging().logToError("runAgent exception: " + ex);
      ex.printStackTrace();
      logMessage("\n[ERROR] Agent crashed: " + ex.getClass().getName() + ": " + ex.getMessage() + "\n");
    } finally {
      running = false;
      logMessage("\n[INFO] Agent finished.\n");
      api.logging().logToOutput("[AgentEngine] runAgent() method exiting");
      this.runMemory = null;
    }
  }

  public void generateReport() {
    logMessage("\n[INFO] Report generation (skeleton). Add your vuln store here.\n");
  }

  // ---------------- Tool: execute_http_request ----------------

  private ToolResult executeHttpRequest(String targetBase,
                                        String method,
                                        String endpointOrUrl,
                                        Map<String,String> headers,
                                        String body,
                                        String purpose,
                                        String expected) {
    try {
      String fullUrl = toAbsolute(targetBase, endpointOrUrl);

      long startNs = System.nanoTime();

      HttpRequest req = HttpRequest.httpRequestFromUrl(fullUrl)
          .withMethod(method);

      // Add headers
      if (headers != null) {
        for (var e : headers.entrySet()) {
          req = req.withHeader(httpHeader(e.getKey(), e.getValue()));
        }
      }

      if (body != null && !body.isEmpty()) {
        req = req.withBody(body);
      }

      // Enforce in-scope ONLY (absolute allowed, but must be in Burp scope).
      if (!req.isInScope()) {
        String blockedMsg = "Blocked: " + fullUrl + ". Add to Burp Target Scope!";
        logMessage("[DEBUG] " + blockedMsg + "\n");

        int id = counter.incrementAndGet();
        addRow.accept(new AgentTab.LogRow(id, method, fullUrl, 0, "[BLOCKED] " + purpose), null);

        return ToolResult.blocked(id, method, fullUrl, blockedMsg);
      }

      logMessage("[DEBUG] Sending request: " + method + " " + fullUrl + "\n");
      // Send using Burp HTTP stack.
      HttpRequestResponse rr = api.http().sendRequest(req);

      int status = rr.response() != null ? rr.response().statusCode() : 0;
      int id = counter.incrementAndGet();

      addRow.accept(new AgentTab.LogRow(id, method, fullUrl, status, purpose), rr);
      showEditors.accept(rr);

      logMessage("Executing: " + method + " " + fullUrl + "\n");
      logMessage(" Purpose: " + purpose + "\n");
      logMessage(" Expected: " + expected + "\n");
      logMessage(" Status: " + status + "\n\n");

      long durationMs = (System.nanoTime() - startNs) / 1_000_000L;

      Map<String, String> reqHeaders = new LinkedHashMap<>();
      try {
        if (rr.request() != null) {
          for (HttpHeader h : rr.request().headers()) {
            reqHeaders.putIfAbsent(h.name(), h.value());
          }
        }
      } catch (Exception ignored) {
        // ignore
      }

      String requestBodyPreview = null;
      try {
        if (rr.request() != null) {
          requestBodyPreview = truncate(rr.request().bodyToString(), 2000);
        }
      } catch (Exception ignored) {
        // ignore
      }

      Map<String, List<String>> respHeaders = new LinkedHashMap<>();
      try {
        if (rr.response() != null) {
          for (HttpHeader h : rr.response().headers()) {
            respHeaders.computeIfAbsent(h.name(), k -> new ArrayList<>()).add(h.value());
          }
        }
      } catch (Exception ignored) {
        // ignore
      }

      String respBody = (rr.response() != null) ? rr.response().bodyToString() : "";
      boolean likelyBinary = looksBinary(respBody);
      String responseBodyPreview = truncate(respBody, 4000);

      if (runMemory != null) {
        runMemory.recordHttp(id, method, fullUrl, status, purpose, requestBodyPreview, responseBodyPreview, respHeaders);
      }

      return ToolResult.ok(id, method, fullUrl, reqHeaders, requestBodyPreview, status,
          respHeaders, responseBodyPreview, likelyBinary, durationMs);

    } catch (Exception ex) {
      api.logging().logToError("executeHttpRequest failed: " + ex);
      return ToolResult.error(method, endpointOrUrl, ex.getMessage());
    }
  }

  private static String validateVulnReportArgs(Map<String, Object> args) {
    if (args == null) return "Missing arguments";

    String name = String.valueOf(args.getOrDefault("name", "")).trim();
    String severity = String.valueOf(args.getOrDefault("severity", "")).trim();

    // Prevent obvious misuse like reporting negative findings as vulnerabilities.
    if (name.toLowerCase().contains("not detected") || name.toLowerCase().contains("no ")) {
      return "Do not use report_vulnerability for negative findings; only confirmed vulnerabilities.";
    }

    if (severity.isBlank()) return "Missing severity";

    Object ids = args.get("evidence_request_ids");
    if (!(ids instanceof List<?> list) || list.isEmpty()) {
      return "Missing evidence_request_ids (must reference request log ids from execute_http_request results).";
    }
    return null;
  }

  private static String truncate(String s, int max) {
    if (s == null) return null;
    if (s.length() <= max) return s;
    return s.substring(0, max) + "...[truncated]";
  }

  private static boolean looksBinary(String s) {
    if (s == null || s.isEmpty()) return false;
    int nonPrintable = 0;
    int sample = Math.min(s.length(), 512);
    for (int i = 0; i < sample; i++) {
      char c = s.charAt(i);
      boolean printable = (c == '\n' || c == '\r' || c == '\t') || (c >= 0x20 && c <= 0x7E);
      if (!printable) nonPrintable++;
    }
    return (nonPrintable / (double) sample) > 0.15;
  }

  private static String toAbsolute(String targetBase, String endpointOrUrl) {
    String s = endpointOrUrl.trim();
    if (s.startsWith("http://") || s.startsWith("https://")) return s; // absolute allowed
    String base = normalizeBase(targetBase);
    if (!s.startsWith("/")) s = "/" + s;
    return base + s;
  }

  private static String normalizeBase(String s) {
    if (s == null) return "";
    s = s.trim();
    int hash = s.indexOf('#');
    if (hash >= 0) s = s.substring(0, hash);
    while (s.endsWith("/")) s = s.substring(0, s.length() - 1);
    return s;
  }

  // ---------------- Prompts & tool schema ----------------

  private static String systemPrompt() {
    return """
You are an autonomous penetration testing agent inside Burp Suite.
RULES:
- For any action, call execute_http_request.
- Only test IN-SCOPE targets.
- Never claim you observed headers, cookies, params, or response content unless it appears in tool output.
- Always base conclusions on execute_http_request results (status, headers, body preview, request_id).
- Do NOT report non-vulnerabilities (e.g., \"Not detected\") via report_vulnerability.
- Validate before reporting; then call report_vulnerability with evidence_request_ids.
- Never spam report_vulnerability. Report each distinct issue once; if you receive a tool error about duplicates, stop repeating and continue testing.
""";
  }

  private static void upsertMemoryMessage(List<Map<String,Object>> messages, String content) {
    if (messages == null) return;
    if (content == null || content.isBlank()) return;

    for (int i = messages.size() - 1; i >= 0; i--) {
      Map<String,Object> m = messages.get(i);
      if (!"system".equals(String.valueOf(m.get("role")))) continue;
      String c = String.valueOf(m.getOrDefault("content", ""));
      if (c.startsWith("MEMORY:")) {
        m.put("content", content);
        return;
      }
    }
    messages.add(msg("system", content));
  }

  private static void pruneMessages(List<Map<String,Object>> messages) {
    if (messages == null) return;
    int max = 40;
    if (messages.size() <= max) return;

    Map<String,Object> rootSystem = null;
    Map<String,Object> memory = null;

    if (!messages.isEmpty() && "system".equals(String.valueOf(messages.get(0).get("role")))) {
      rootSystem = messages.get(0);
    }
    for (int i = messages.size() - 1; i >= 0; i--) {
      Map<String,Object> m = messages.get(i);
      if (!"system".equals(String.valueOf(m.get("role")))) continue;
      String c = String.valueOf(m.getOrDefault("content", ""));
      if (c.startsWith("MEMORY:")) {
        memory = m;
        break;
      }
    }

    int tailKeep = Math.max(10, max - 2);
    int start = Math.max(0, messages.size() - tailKeep);
    List<Map<String,Object>> tail = new ArrayList<>(messages.subList(start, messages.size()));

    List<Map<String,Object>> rebuilt = new ArrayList<>();
    if (rootSystem != null) rebuilt.add(rootSystem);
    if (memory != null && memory != rootSystem) rebuilt.add(memory);
    for (Map<String,Object> m : tail) {
      if (m == rootSystem) continue;
      if (m == memory) continue;
      rebuilt.add(m);
    }

    messages.clear();
    messages.addAll(rebuilt);
  }

  private static String vulnDedupKey(Map<String, Object> args) {
    if (args == null) return "";
    String name = String.valueOf(args.getOrDefault("name", "")).trim().toLowerCase(Locale.ROOT);
    String location = String.valueOf(args.getOrDefault("location", "")).trim().toLowerCase(Locale.ROOT);
    Object ids = args.get("evidence_request_ids");
    String evidence = "";
    if (ids instanceof List<?> list) {
      List<String> parts = new ArrayList<>();
      for (Object o : list) parts.add(String.valueOf(o));
      parts.sort(String::compareTo);
      evidence = String.join(",", parts);
    }
    return name + "|" + location + "|" + evidence;
  }

  private static String seedPrompt(Imported imported, String userPrompt, String targetBase) {
    if (imported == null) {
      return "Target base: " + targetBase + "\nTask: " + userPrompt
          + "\nStart with reconnaissance. Then test OWASP Top 10.";
    }
    String headers = imported.headers == null || imported.headers.isEmpty()
      ? "(none)"
      : imported.headers.toString();
    String body = imported.body == null ? "" : imported.body;
    if (body.length() > 1500) body = body.substring(0, 1500) + "...[truncated]";

    return "You are given an imported request.\n"
      + "URL: " + imported.fullUrl + "\n"
      + "Method: " + imported.method + "\n"
      + "Endpoint: " + imported.endpoint + "\n"
      + "Headers: " + headers + "\n"
      + "Body preview: " + body + "\n"
      + "Task: " + userPrompt + "\n"
      + "First replay the imported request with execute_http_request using the SAME method, endpoint, headers, and body.";
  }

  private static List<Map<String,Object>> toolSchema() {
    // OpenAI-style tool schema works with many Ollama tool-calling models (same idea as your Python).
    Map<String,Object> exec = new HashMap<>();
    exec.put("type", "function");
    exec.put("function", Map.of(
        "name", "execute_http_request",
        "description", "Send an HTTP request via Burp (must be in-scope).",
        "parameters", Map.of(
            "type", "object",
            "properties", Map.of(
                "method", Map.of("type","string"),
                "endpoint", Map.of("type","string"),
                "headers", Map.of("type","object"),
                "body", Map.of("type","string"),
                "purpose", Map.of("type","string"),
                "expected", Map.of("type","string")
            ),
            "required", List.of("method","endpoint","purpose","expected")
        )
    ));

    Map<String,Object> rep = new HashMap<>();
    rep.put("type", "function");
    rep.put("function", Map.of(
        "name", "report_vulnerability",
        "description", "Report a confirmed vulnerability.",
        "parameters", Map.of(
            "type","object",
            "properties", Map.of(
                "name", Map.of("type","string"),
                "severity", Map.of("type","string"),
                "location", Map.of("type","string"),
                "description", Map.of("type","string"),
                "impact", Map.of("type","string"),
                "poc", Map.of("type","string"),
          "evidence_request_ids", Map.of("type","array", "items", Map.of("type","integer")),
                "remediation", Map.of("type","string")
            ),
        "required", List.of("name","severity","location","description","impact","poc","evidence_request_ids","remediation")
        )
    ));

    return List.of(exec, rep);
  }

  private static Map<String,Object> msg(String role, String content) {
    Map<String,Object> m = new HashMap<>();
    m.put("role", role);
    m.put("content", content);
    return m;
  }

  private static String str(Object o) { return o == null ? "" : String.valueOf(o); }

  private Map<String, String> parseHeaders(Object obj) {
    if (obj == null) return new HashMap<>();
    if (obj instanceof Map<?, ?> map) {
      Map<String, String> result = new HashMap<>();
      for (Map.Entry<?, ?> entry : map.entrySet()) {
        result.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
      }
      return result;
    }
    if (obj instanceof String s && !s.isBlank()) {
      try {
        return json.readValue(s, new TypeReference<Map<String, String>>() {});
      } catch (Exception e) {
        logMessage("[WARN] Failed to parse headers string: " + e.getMessage() + "\n");
      }
    }
    return new HashMap<>();
  }
}


