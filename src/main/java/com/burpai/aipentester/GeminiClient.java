package com.burpai.aipentester;

import burp.api.montoya.logging.Logging;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * LLM client that targets the Google Gemini REST API
 * (generativelanguage.googleapis.com).
 *
 * <p>Converts the OpenAI-style message/tool schema used internally to
 * Gemini's content format so the rest of the agent needs no changes.
 *
 * <p>Model name examples: {@code gemini-2.0-flash}, {@code gemini-2.5-flash-preview},
 * {@code gemini-3-flash} (set whatever name is available in your project).
 */
public class GeminiClient implements LlmClient {

  private static final String BASE_URL =
      "https://generativelanguage.googleapis.com/v1beta/models/";

  private final String model;
  private final String apiKey;
  private final Logging logging;
  private final HttpClient http;
  private final ObjectMapper json = new ObjectMapper();

  public GeminiClient(String model, String apiKey, Logging logging) {
    this.model = model.trim();
    this.apiKey = apiKey.trim();
    this.logging = logging;
    this.http = HttpClient.newBuilder()
        .followRedirects(HttpClient.Redirect.NORMAL)
        .proxy(new DirectProxySelector())
        .connectTimeout(Duration.ofSeconds(15))
        .build();
  }

  // Force direct connections; Burp's proxy may not be useful for external API calls.
  private static final class DirectProxySelector extends ProxySelector {
    @Override public List<Proxy> select(URI uri) { return List.of(Proxy.NO_PROXY); }
    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}
  }

  // ---- LlmClient ----

  @Override
  public ConnResult testConnection() {
    // The simplest check: list models (or just attempt a minimal generateContent call).
    try {
      String url = BASE_URL + model + ":generateContent?key=" + apiKey;
      // Send a trivial prompt to verify the key + model combo works.
      Map<String, Object> payload = new LinkedHashMap<>();
      payload.put("contents", List.of(Map.of("role", "user",
          "parts", List.of(Map.of("text", "Say OK")))));
      payload.put("generationConfig", Map.of("maxOutputTokens", 5));

      String body = json.writeValueAsString(payload);
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .timeout(Duration.ofSeconds(20))
          .header("Content-Type", "application/json")
          .POST(HttpRequest.BodyPublishers.ofString(body))
          .build();

      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(25));
      if (resp.statusCode() == 200) {
        return new ConnResult(true, "Connected to Gemini. Model '" + model + "' is ready.");
      }
      String err = extractGeminiError(resp.body());
      return new ConnResult(false, "Gemini returned HTTP " + resp.statusCode() + ": " + err);

    } catch (Exception e) {
      return new ConnResult(false, "Connection error: " + e.getClass().getSimpleName() + ": " + e.getMessage());
    }
  }

  @Override
  public ChatResult chat(List<Map<String, Object>> messages, List<Map<String, Object>> tools) {
    int attempts = 0;
    while (true) {
      attempts++;
      try {
        String url = BASE_URL + model + ":generateContent?key=" + apiKey;

        Map<String, Object> payload = buildGeminiPayload(messages, tools);
        String body = json.writeValueAsString(payload);

        logging.logToOutput("[GeminiClient] POST " + url.substring(0, url.indexOf('?')) + " (body length=" + body.length() + ")");

        HttpRequest req = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .timeout(Duration.ofSeconds(120))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();

        HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(125));

        if (resp.statusCode() != 200) {
          String err = extractGeminiError(resp.body());
          if (resp.statusCode() == 429 && attempts < 3) {
            // Rate limit – back off and retry
            long backoffMs = attempts * 2000L;
            logging.logToError("[GeminiClient] 429 rate-limited; retrying after " + backoffMs + "ms");
            Thread.sleep(backoffMs);
            continue;
          }
          return ChatResult.err("Gemini HTTP " + resp.statusCode() + ": " + err);
        }

        return parseGeminiResponse(resp.body());

      } catch (java.net.ConnectException | java.net.SocketTimeoutException | HttpTimeoutException e) {
        if (attempts >= 3) {
          return ChatResult.err("Gemini network error after retries: " + e.getMessage());
        }
        long backoffMs = attempts * 1000L;
        logging.logToError("[GeminiClient] Transient error (attempt " + attempts + "): " + e + " ; retrying in " + backoffMs + "ms");
        try { Thread.sleep(backoffMs); } catch (InterruptedException ie) {
          Thread.currentThread().interrupt();
          return ChatResult.err("Interrupted while retrying Gemini call");
        }
      } catch (Exception e) {
        logging.logToError("[GeminiClient] chat error: " + e);
        return ChatResult.err(e.getClass().getSimpleName() + ": " + e.getMessage());
      }
    }
  }

  // ---- Message conversion ----

  /**
   * Converts OpenAI-style messages + tools to a Gemini generateContent request body.
   *
   * <ul>
   *   <li>system messages → collected into {@code systemInstruction}</li>
   *   <li>user / assistant / tool messages → {@code contents}</li>
   *   <li>Gemini requires strictly alternating user/model turns; consecutive
   *       same-role parts are merged into a single content entry.</li>
   * </ul>
   */
  @SuppressWarnings("unchecked")
  private Map<String, Object> buildGeminiPayload(
      List<Map<String, Object>> messages,
      List<Map<String, Object>> tools) {

    List<String> systemTexts = new ArrayList<>();
    List<Map<String, Object>> contents = new ArrayList<>();

    for (Map<String, Object> m : messages) {
      String role = str(m.get("role"));
      Object contentObj = m.get("content");

      switch (role) {
        case "system" -> {
          // Collect all system texts; they go into systemInstruction.
          String text = contentObj == null ? "" : String.valueOf(contentObj);
          if (!text.isBlank()) systemTexts.add(text);
        }
        case "user" -> {
          String text = contentObj == null ? "" : String.valueOf(contentObj);
          addTextTurn(contents, "user", text);
        }
        case "assistant" -> {
          // May have text and/or tool_calls
          String text = contentObj == null ? "" : String.valueOf(contentObj);
          List<Map<String, Object>> parts = new ArrayList<>();
          if (!text.isBlank()) parts.add(Map.of("text", text));

          // Inline tool_calls from message (if stored that way)
          Object tcRaw = m.get("tool_calls");
          if (tcRaw instanceof List<?> tcList) {
            for (Object tcItem : tcList) {
              if (!(tcItem instanceof Map<?, ?> tc)) continue;
              Object fn = tc.get("function");
              if (fn instanceof Map<?, ?> fnMap) {
                String name = str(fnMap.get("name"));
                Object argsObj = fnMap.get("arguments");
                Map<String, Object> args = toMap(argsObj);
                parts.add(Map.of("functionCall", Map.of("name", name, "args", args)));
              }
            }
          }
          if (!parts.isEmpty()) addPartTurn(contents, "model", parts);
        }
        case "tool" -> {
          // OpenAI tool result: { role:"tool", name:"fn", content:"..." }
          String name = str(m.get("name"));
          String resultText = contentObj == null ? "" : String.valueOf(contentObj);
          // Gemini expects functionResponse as a user-role part
          Map<String, Object> fr = new LinkedHashMap<>();
          fr.put("name", name);
          fr.put("response", Map.of("output", resultText));
          addPartTurn(contents, "user", List.of(Map.of("functionResponse", fr)));
        }
        default -> {
          // Pass through unknown roles as user text
          String text = contentObj == null ? "" : String.valueOf(contentObj);
          if (!text.isBlank()) addTextTurn(contents, "user", text);
        }
      }
    }

    // If the last turn is "model" (assistant) append an empty user nudge so the
    // API doesn't complain about a trailing model turn.
    if (!contents.isEmpty()) {
      String lastRole = str(contents.get(contents.size() - 1).get("role"));
      if ("model".equals(lastRole)) {
        contents.add(Map.of("role", "user",
            "parts", List.of(Map.of("text", "Continue."))));
      }
    }

    // Ensure we start with a user turn
    if (!contents.isEmpty() && !"user".equals(str(contents.get(0).get("role")))) {
      contents.add(0, Map.of("role", "user",
          "parts", List.of(Map.of("text", "Begin."))));
    }

    Map<String, Object> payload = new LinkedHashMap<>();

    if (!systemTexts.isEmpty()) {
      String combined = String.join("\n\n", systemTexts);
      payload.put("systemInstruction",
          Map.of("parts", List.of(Map.of("text", combined))));
    }

    payload.put("contents", contents);
    payload.put("generationConfig", Map.of("temperature", 0.7));

    // Convert tools
    if (tools != null && !tools.isEmpty()) {
      List<Map<String, Object>> funcDecls = new ArrayList<>();
      for (Map<String, Object> t : tools) {
        Object fnRaw = t.get("function");
        if (!(fnRaw instanceof Map<?, ?> fn)) continue;
        String name = str(fn.get("name"));
        String desc = str(fn.get("description"));
        Object paramsRaw = fn.get("parameters");
        Map<String, Object> params = toMap(paramsRaw);
        // Gemini requires uppercase type strings
        Map<String, Object> geminiParams = upperCaseTypes(params);
        Map<String, Object> decl = new LinkedHashMap<>();
        decl.put("name", name);
        if (!desc.isBlank()) decl.put("description", desc);
        decl.put("parameters", geminiParams);
        funcDecls.add(decl);
      }
      if (!funcDecls.isEmpty()) {
        payload.put("tools", List.of(Map.of("functionDeclarations", funcDecls)));
        // Allow the model to decide when to call tools
        payload.put("toolConfig", Map.of("functionCallingConfig", Map.of("mode", "AUTO")));
      }
    }

    return payload;
  }

  /** Adds a plain-text content turn, merging with previous if same role. */
  @SuppressWarnings("unchecked")
  private static void addTextTurn(List<Map<String, Object>> contents, String role, String text) {
    List<Map<String, Object>> parts = new ArrayList<>();
    if (!text.isBlank()) parts.add(Map.of("text", text));
    if (parts.isEmpty()) return;
    addPartTurn(contents, role, parts);
  }

  /** Adds a parts-based turn, merging with previous if same role. */
  @SuppressWarnings("unchecked")
  private static void addPartTurn(List<Map<String, Object>> contents, String role,
                                   List<Map<String, Object>> newParts) {
    if (newParts.isEmpty()) return;
    if (!contents.isEmpty()) {
      Map<String, Object> last = contents.get(contents.size() - 1);
      if (role.equals(str(last.get("role")))) {
        // Merge into existing turn
        List<Map<String, Object>> existing =
            (List<Map<String, Object>>) last.get("parts");
        List<Map<String, Object>> merged = new ArrayList<>(existing);
        merged.addAll(newParts);
        last.put("parts", merged);
        return;
      }
    }
    Map<String, Object> entry = new LinkedHashMap<>();
    entry.put("role", role);
    entry.put("parts", new ArrayList<>(newParts));
    contents.add(entry);
  }

  // ---- Response parsing ----

  @SuppressWarnings("unchecked")
  private ChatResult parseGeminiResponse(String responseBody) {
    try {
      Map<String, Object> root = json.readValue(responseBody, Map.class);
      List<?> candidates = (List<?>) root.get("candidates");
      if (candidates == null || candidates.isEmpty()) {
        // May be a prompt-blocked response
        Object promptFeedback = root.get("promptFeedback");
        if (promptFeedback != null) {
          return ChatResult.err("Gemini blocked the request: " + promptFeedback);
        }
        return ChatResult.err("Gemini returned no candidates. Body: " + truncate(responseBody, 500));
      }

      Map<?, ?> candidate = (Map<?, ?>) candidates.get(0);
      Map<?, ?> content = (Map<?, ?>) candidate.get("content");
      if (content == null) {
        return ChatResult.ok("", List.of());
      }

      List<?> parts = (List<?>) content.get("parts");
      if (parts == null) return ChatResult.ok("", List.of());

      StringBuilder text = new StringBuilder();
      List<ToolCall> toolCalls = new ArrayList<>();

      for (Object p : parts) {
        if (!(p instanceof Map<?, ?> part)) continue;

        // Text part
        Object textObj = part.get("text");
        if (textObj != null) {
          String t = String.valueOf(textObj);
          if (!t.isBlank()) {
            if (!text.isEmpty()) text.append("\n");
            text.append(t);
          }
        }

        // Function call part
        Object fcObj = part.get("functionCall");
        if (fcObj instanceof Map<?, ?> fc) {
          String name = str(fc.get("name"));
          Object argsObj = fc.get("args");
          Map<String, Object> args = toMap(argsObj);
          toolCalls.add(new ToolCall(name, args));
        }
      }

      return ChatResult.ok(text.toString(), toolCalls);
    } catch (Exception e) {
      logging.logToError("[GeminiClient] Failed to parse response: " + e);
      return ChatResult.err("Failed to parse Gemini response: " + e.getMessage());
    }
  }

  // ---- Helpers ----

  private String extractGeminiError(String body) {
    if (body == null) return "(empty)";
    try {
      @SuppressWarnings("unchecked")
      Map<String, Object> root = json.readValue(body, Map.class);
      Object err = root.get("error");
      if (err instanceof Map<?, ?> errMap) {
        return str(errMap.get("message"));
      }
    } catch (Exception ignored) {}
    return truncate(body, 300);
  }

  /** Recursively converts lowercase JSON Schema type strings to Gemini uppercase equivalents. */
  @SuppressWarnings("unchecked")
  private static Map<String, Object> upperCaseTypes(Map<String, Object> schema) {
    if (schema == null) return Map.of();
    Map<String, Object> out = new LinkedHashMap<>();
    for (Map.Entry<String, Object> e : schema.entrySet()) {
      String key = e.getKey();
      Object val = e.getValue();
      if ("type".equals(key) && val instanceof String s) {
        out.put(key, s.toUpperCase(Locale.ROOT));
      } else if (val instanceof Map<?, ?> m) {
        out.put(key, upperCaseTypes((Map<String, Object>) m));
      } else if ("properties".equals(key) && val instanceof Map<?, ?> propsMap) {
        Map<String, Object> newProps = new LinkedHashMap<>();
        for (Map.Entry<?, ?> pe : propsMap.entrySet()) {
          Object pv = pe.getValue();
          newProps.put(String.valueOf(pe.getKey()),
              pv instanceof Map<?, ?> pm ? upperCaseTypes((Map<String, Object>) pm) : pv);
        }
        out.put(key, newProps);
      } else if ("items".equals(key) && val instanceof Map<?, ?> items) {
        out.put(key, upperCaseTypes((Map<String, Object>) items));
      } else {
        out.put(key, val);
      }
    }
    return out;
  }

  @SuppressWarnings("unchecked")
  private static Map<String, Object> toMap(Object obj) {
    if (obj instanceof Map<?, ?> m) return (Map<String, Object>) m;
    return new LinkedHashMap<>();
  }

  private static String str(Object o) { return o == null ? "" : String.valueOf(o); }

  private static String truncate(String s, int max) {
    if (s == null) return "";
    return s.length() <= max ? s : s.substring(0, max) + "...[truncated]";
  }

  private HttpResponse<String> sendWithTimeout(HttpRequest req, Duration timeout) throws Exception {
    var fut = http.sendAsync(req, HttpResponse.BodyHandlers.ofString());
    try {
      return fut.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException te) {
      fut.cancel(true);
      throw new HttpTimeoutException("Gemini request timed out after " + timeout.toSeconds() + "s");
    } catch (ExecutionException ee) {
      Throwable cause = ee.getCause();
      if (cause instanceof Exception ex) throw ex;
      throw new RuntimeException(cause);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw ie;
    }
  }
}
