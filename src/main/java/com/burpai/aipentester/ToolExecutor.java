package com.burpai.aipentester;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpHeader;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import burp.api.montoya.proxy.ProxyHttpRequestResponse;
import burp.api.montoya.scanner.audit.issues.AuditIssue;
import burp.api.montoya.scanner.audit.issues.AuditIssueConfidence;
import burp.api.montoya.scanner.audit.issues.AuditIssueSeverity;
import burp.api.montoya.sitemap.SiteMapFilter;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static burp.api.montoya.http.message.HttpHeader.httpHeader;

/**
 * Executes all agent tools: HTTP requests, fuzzing, spidering, encoding,
 * variable management, response searching, site-map querying, etc.
 */
class ToolExecutor {

  private final MontoyaApi api;
  private final ObjectMapper json;
  private final AgentLogger logger;
  private final List<Map<String, Object>> vulnStore;
  private final Map<Integer, String> responseBodyStore;
  private final Map<Integer, HttpRequestResponse> rrStore;
  private final Map<String, String> sessionVars;
  private final BiConsumer<AgentTab.LogRow, HttpRequestResponse> addRow;
  private final Consumer<HttpRequestResponse> showEditors;
  private final AtomicInteger counter;

  /** Set at the start of each run; may be null between runs. */
  volatile MemoryManager runMemory;

  ToolExecutor(MontoyaApi api,
               ObjectMapper json,
               AgentLogger logger,
               List<Map<String, Object>> vulnStore,
               Map<Integer, String> responseBodyStore,
               Map<Integer, HttpRequestResponse> rrStore,
               Map<String, String> sessionVars,
               BiConsumer<AgentTab.LogRow, HttpRequestResponse> addRow,
               Consumer<HttpRequestResponse> showEditors,
               AtomicInteger counter) {
    this.api = api;
    this.json = json;
    this.logger = logger;
    this.vulnStore = vulnStore;
    this.responseBodyStore = responseBodyStore;
    this.rrStore = rrStore;
    this.sessionVars = sessionVars;
    this.addRow = addRow;
    this.showEditors = showEditors;
    this.counter = counter;
  }

  // ─────────────────────── Per-run reset ────────────────────────────────────

  /** Clear all per-run stores. Called by {@link AgentLoop} at the start of every run. */
  void reset() {
    responseBodyStore.clear();
    rrStore.clear();
    sessionVars.clear();
    runMemory = null;
  }

  // ─────────────────────── execute_http_request ────────────────────────────

  ToolResult executeHttpRequest(String targetBase,
                                String method,
                                String endpointOrUrl,
                                Map<String, String> headers,
                                String body,
                                String purpose,
                                String expected) {
    try {
      String fullUrl = AgentUtils.toAbsolute(targetBase, endpointOrUrl);
      long startNs = System.nanoTime();

      HttpRequest req = HttpRequest.httpRequestFromUrl(fullUrl).withMethod(method);

      if (headers != null) {
        for (var e : headers.entrySet()) {
          req = req.withHeader(httpHeader(e.getKey(), e.getValue()));
        }
      }
      if (body != null && !body.isEmpty()) {
        req = req.withBody(body);
      }

      logger.log("[DEBUG] Sending request: " + method + " " + fullUrl + "\n");
      HttpRequestResponse rr = api.http().sendRequest(req);

      int status = rr.response() != null ? rr.response().statusCode() : 0;
      int id = counter.incrementAndGet();

      addRow.accept(new AgentTab.LogRow(id, method, fullUrl, status, purpose), rr);
      showEditors.accept(rr);

      logger.log("Executing: " + method + " " + fullUrl + "\n");
      logger.log(" Purpose: " + purpose + "\n");
      logger.log(" Expected: " + expected + "\n");
      logger.log(" Status: " + status + "\n\n");

      long durationMs = (System.nanoTime() - startNs) / 1_000_000L;

      Map<String, String> reqHeaders = new LinkedHashMap<>();
      try {
        if (rr.request() != null) {
          for (HttpHeader h : rr.request().headers()) reqHeaders.putIfAbsent(h.name(), h.value());
        }
      } catch (Exception ignored) {}

      String requestBodyPreview = null;
      try {
        if (rr.request() != null) requestBodyPreview = AgentUtils.truncate(rr.request().bodyToString(), 2000);
      } catch (Exception ignored) {}

      Map<String, List<String>> respHeaders = new LinkedHashMap<>();
      try {
        if (rr.response() != null) {
          for (HttpHeader h : rr.response().headers()) {
            respHeaders.computeIfAbsent(h.name(), k -> new ArrayList<>()).add(h.value());
          }
        }
      } catch (Exception ignored) {}

      String respBody = (rr.response() != null) ? rr.response().bodyToString() : "";
      boolean likelyBinary = AgentUtils.looksBinary(respBody);
      String responseBodyPreview = AgentUtils.truncate(respBody, 4000);

      responseBodyStore.put(id, respBody);
      rrStore.put(id, rr);

      if (runMemory != null) {
        runMemory.recordHttp(id, method, fullUrl, status, purpose,
            requestBodyPreview, responseBodyPreview, respHeaders);
      }

      return ToolResult.ok(id, method, fullUrl, reqHeaders, requestBodyPreview,
          status, respHeaders, responseBodyPreview, likelyBinary, durationMs);

    } catch (Exception ex) {
      api.logging().logToError("executeHttpRequest failed: " + ex);
      return ToolResult.error(method, endpointOrUrl, ex.getMessage());
    }
  }

  // ─────────────────────── Burp native issue reporting ───────────────────────

  /**
   * Builds a Montoya {@link AuditIssue} from a vuln-store map and pushes it to
   * {@code api.siteMap().add()} so it appears in the Burp Dashboard and Issue Activity.
   *
   * @param args      the same map that was (or will be) stored in vulnStore
   * @param confirmed {@code true} → CERTAIN confidence (PoC-confirmed);
   *                  {@code false} → TENTATIVE (observed, not fully proven)
   */
  void reportAuditIssue(Map<String, Object> args, boolean confirmed) {
    try {
      String name        = AgentUtils.str(args.getOrDefault("name",        "Unknown Finding"));
      String description = AgentUtils.str(args.getOrDefault("description", ""));
      String impact      = AgentUtils.str(args.getOrDefault("impact",      ""));
      String remediation = AgentUtils.str(args.getOrDefault("remediation", ""));
      String location    = AgentUtils.str(args.getOrDefault("location",    ""));
      String poc         = AgentUtils.str(args.getOrDefault("poc",         ""));
      String sevStr      = AgentUtils.str(args.getOrDefault("severity",    "Information")).trim();

      AuditIssueSeverity severity = switch (sevStr.toUpperCase(Locale.ROOT)) {
        case "CRITICAL", "HIGH" -> AuditIssueSeverity.HIGH;
        case "MEDIUM"           -> AuditIssueSeverity.MEDIUM;
        case "LOW"              -> AuditIssueSeverity.LOW;
        default                 -> AuditIssueSeverity.INFORMATION;
      };
      AuditIssueConfidence confidence = confirmed
          ? AuditIssueConfidence.CERTAIN : AuditIssueConfidence.TENTATIVE;

      // Build HTML detail block
      StringBuilder detail = new StringBuilder();
      if (!description.isBlank()) detail.append("<p><b>Description:</b> ").append(escHtml(description)).append("</p>");
      if (!impact.isBlank())      detail.append("<p><b>Impact:</b> ")     .append(escHtml(impact))     .append("</p>");
      if (!poc.isBlank())         detail.append("<p><b>PoC:</b></p><pre>").append(escHtml(poc))        .append("</pre>");

      String remediationHtml = remediation.isBlank() ? null
          : "<p>" + escHtml(remediation) + "</p>";

      // Resolve evidence request/response objects
      List<HttpRequestResponse> evidence = new ArrayList<>();
      Object ids = args.get("evidence_request_ids");
      if (ids instanceof List<?> list) {
        for (Object o : list) {
          try {
            HttpRequestResponse rr = rrStore.get(((Number) o).intValue());
            if (rr != null) evidence.add(rr);
          } catch (Exception ignored) {}
        }
      }

      // Determine baseUrl: prefer first evidence request URL, fall back to location
      String baseUrl = null;
      if (!evidence.isEmpty() && evidence.get(0).request() != null) {
        try { baseUrl = evidence.get(0).request().url(); } catch (Exception ignored) {}
      }
      if (baseUrl == null || baseUrl.isBlank()) baseUrl = location;

      // Burp's AuditIssue requires a proper HTTP(S) URL. Observed/additional findings
      // often have descriptive locations like "POST /rest/user/login" or "All endpoints"
      // which are not valid URLs. Try to salvage them:
      //   • Strip leading method+space (e.g. "POST /rest/user/login" → "/rest/user/login")
      //   • If it's a bare path, borrow the origin from any stored request
      //   • If it still can't be resolved, skip Dashboard — finding is in HTML report.
      if (!baseUrl.startsWith("http://") && !baseUrl.startsWith("https://")) {
        // Strip leading method word if present ("GET /foo" → "/foo")
        String cooked = baseUrl.replaceFirst("(?i)^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\\s+", "");
        if (cooked.startsWith("/")) {
          // Try to borrow origin from any stored RR
          String origin = rrStore.values().stream()
              .filter(rr -> rr != null && rr.request() != null)
              .map(rr -> { try { return rr.request().url(); } catch (Exception e) { return ""; } })
              .filter(u -> u.startsWith("http"))
              .findFirst()
              .map(u -> { try {
                  java.net.URI uri = new java.net.URI(u);
                  return uri.getScheme() + "://" + uri.getAuthority();
                } catch (Exception e) { return ""; }})
              .orElse("");
          if (!origin.isBlank()) cooked = origin + cooked;
        }
        if (cooked.startsWith("http://") || cooked.startsWith("https://")) {
          baseUrl = cooked;
        } else {
          logger.log("[DEBUG] Burp Dashboard skip for \"" + name + "\" — location \""
              + location + "\" could not be resolved to a URL; finding is in HTML report.\n");
          return;
        }
      }

      AuditIssue issue = AuditIssue.auditIssue(
          name,
          detail.toString(),
          remediationHtml,
          baseUrl,
          severity,
          confidence,
          null,   // background (no per-issue background needed)
          null,   // remediationBackground
          severity,
          evidence);

      api.siteMap().add(issue);
      logger.log("[INFO] Sent to Burp Dashboard: [" + severity.name() + "/"
          + confidence.name() + "] " + name + "\n");

    } catch (Exception ex) {
      logger.log("[WARN] Failed to report to Burp Dashboard: " + ex.getMessage() + "\n");
      api.logging().logToError("reportAuditIssue failed: " + ex);
    }
  }

  /** Minimal HTML escaping for issue detail text. */
  private static String escHtml(String s) {
    if (s == null) return "";
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\n", "<br>");
  }

  // ─────────────────────── report_vulnerability helpers ────────────────────

  static String validateVulnReportArgs(Map<String, Object> args) {
    if (args == null) return "Missing arguments";
    String name = String.valueOf(args.getOrDefault("name", "")).trim();
    String severity = String.valueOf(args.getOrDefault("severity", "")).trim();
    if (name.toLowerCase().contains("not detected") || name.toLowerCase().contains("no ")) {
      return "Do not use report_vulnerability for negative findings; only confirmed vulnerabilities.";
    }
    if (severity.isBlank()) return "Missing severity";
    Object ids = args.get("evidence_request_ids");
    if (!(ids instanceof List<?> list) || list.isEmpty()) {
      return "Missing evidence_request_ids (must reference request log ids from execute_http_request results).";
    }
    return null;
  }

  static String vulnDedupKey(Map<String, Object> args) {
    if (args == null) return "";
    String name = String.valueOf(args.getOrDefault("name", "")).trim().toLowerCase(Locale.ROOT);
    String location = String.valueOf(args.getOrDefault("location", "")).trim().toLowerCase(Locale.ROOT);
    Object ids = args.get("evidence_request_ids");
    String evidence = "";
    if (ids instanceof List<?> list) {
      List<String> parts = new ArrayList<>();
      for (Object o : list) parts.add(String.valueOf(o));
      parts.sort(String::compareTo);
      evidence = String.join(",", parts);
    }
    return name + "|" + location + "|" + evidence;
  }

  // ─────────────────────── Variable expansion ──────────────────────────────

  String expandVars(String s) {
    if (s == null || !s.contains("{{")) return s;
    for (Map.Entry<String, String> e : sessionVars.entrySet()) {
      s = s.replace("{{" + e.getKey() + "}}", e.getValue());
    }
    return s;
  }

  // ─────────────────────── extract_from_response ───────────────────────────

  String toolExtractFromResponse(int requestId, String pattern, int group, String storeAs) throws Exception {
    String body = responseBodyStore.get(requestId);
    if (body == null) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "No stored response for request_id " + requestId + ". Use an id returned by execute_http_request."));
    }
    if (pattern == null || pattern.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "pattern is required"));
    }
    try {
      Matcher m = Pattern.compile(pattern, Pattern.DOTALL | Pattern.CASE_INSENSITIVE).matcher(body);
      List<String> matches = new ArrayList<>();
      while (m.find()) { try { matches.add(m.group(group)); } catch (Exception ignored) {} }
      if (matches.isEmpty()) {
        return json.writeValueAsString(Map.of("ok", false, "error", "Pattern not found",
            "pattern", pattern, "response_length", body.length()));
      }
      String first = matches.get(0);
      if (storeAs != null && !storeAs.isBlank()) sessionVars.put(storeAs, first);
      Map<String, Object> out = new LinkedHashMap<>();
      out.put("ok", true);
      out.put("first_match", first);
      out.put("total_matches", matches.size());
      out.put("all_matches", matches.size() <= 20 ? matches : matches.subList(0, 20));
      if (storeAs != null && !storeAs.isBlank()) out.put("stored_as", storeAs);
      return json.writeValueAsString(out);
    } catch (java.util.regex.PatternSyntaxException pse) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Invalid regex: " + pse.getMessage()));
    }
  }

  // ─────────────────────── get_variable ────────────────────────────────────

  String toolGetVariable(String name) throws Exception {
    if (name == null || name.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "name is required"));
    }
    String val = sessionVars.get(name);
    if (val == null) {
      Map<String, Object> out = new LinkedHashMap<>();
      out.put("ok", false);
      out.put("error", "Variable '" + name + "' not set");
      out.put("available_variables", new ArrayList<>(sessionVars.keySet()));
      return json.writeValueAsString(out);
    }
    return json.writeValueAsString(Map.of("ok", true, "name", name, "value", val));
  }

  // ─────────────────────── set_variable ────────────────────────────────────

  String toolSetVariable(String name, String value) throws Exception {
    if (name == null || name.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "name is required"));
    }
    sessionVars.put(name, value == null ? "" : value);
    return json.writeValueAsString(Map.of("ok", true, "name", name,
        "value", value == null ? "" : value,
        "all_variables", new ArrayList<>(sessionVars.keySet())));
  }

  // ─────────────────────── fuzz_parameter ──────────────────────────────────

  String toolFuzzParameter(Map<String, Object> args, String targetBase) throws Exception {
    String baseUrl = expandVars(AgentUtils.str(args.getOrDefault("url", "")));
    String method  = AgentUtils.str(args.getOrDefault("method", "GET")).toUpperCase();
    String param   = AgentUtils.str(args.getOrDefault("parameter", ""));
    String location = AgentUtils.str(args.getOrDefault("location", "query")).toLowerCase(Locale.ROOT);
    String bodyTpl  = args.containsKey("body_template") ? expandVars(AgentUtils.str(args.get("body_template"))) : null;
    String urlTpl   = args.containsKey("url_template")  ? expandVars(AgentUtils.str(args.get("url_template")))  : null;

    if (baseUrl.isBlank() && (urlTpl == null || urlTpl.isBlank())) {
      return json.writeValueAsString(Map.of("ok", false, "error", "url is required"));
    }
    if (urlTpl == null && baseUrl.contains("FUZZ")) {
      urlTpl  = baseUrl;
      baseUrl = baseUrl.substring(0, baseUrl.indexOf("FUZZ"));
    }
    if (urlTpl == null && param.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "parameter is required (or use url_template with FUZZ placeholder)"));
    }
    if (param.isBlank()) param = "FUZZ";

    List<String> payloads = new ArrayList<>();
    Object plObj = args.get("payload_list");
    if (plObj instanceof List<?> pl) {
      for (Object o : pl) payloads.add(String.valueOf(o));
    } else if (plObj instanceof String s) {
      for (String p : s.split(",")) { String t = p.trim(); if (!t.isEmpty()) payloads.add(t); }
    } else {
      return json.writeValueAsString(Map.of("ok", false, "error", "payload_list (array of strings) is required"));
    }
    if (payloads.size() > 25) payloads = payloads.subList(0, 25);

    List<Map<String, Object>> results = new ArrayList<>();
    int baseStatus = -1, baseLen = -1;
    long baseDurMs = -1;
    String currentMethod = method;

    for (int i = 0; i < payloads.size(); i++) {
      String payload = expandVars(payloads.get(i));
      String reqUrl  = baseUrl;
      String reqBody = null;
      Map<String, String> reqHdrs = new HashMap<>();
      String mth = currentMethod;

      if (urlTpl != null) {
        String encodedForPath = URLEncoder.encode(payload, StandardCharsets.UTF_8).replace("+", "%20");
        reqUrl = urlTpl.replace("FUZZ", encodedForPath);
      } else switch (location) {
        case "query" -> reqUrl = AgentUtils.setQueryParam(baseUrl, param, payload);
        case "body" -> {
          reqBody = (bodyTpl != null) ? bodyTpl.replace("FUZZ", payload)
              : param + "=" + URLEncoder.encode(payload, StandardCharsets.UTF_8);
          if (mth.equals("GET")) mth = "POST";
        }
        case "json_body" -> {
          String escaped = payload.replace("\\", "\\\\").replace("\"", "\\\"");
          reqBody = bodyTpl != null ? bodyTpl.replace("FUZZ", escaped) : "{\"" + param + "\":\"" + escaped + "\"}";
          reqHdrs.put("Content-Type", "application/json");
          if (mth.equals("GET")) mth = "POST";
        }
        case "header" -> reqHdrs.put(param, payload);
        case "path" -> {
          String encodedForPath = URLEncoder.encode(payload, StandardCharsets.UTF_8).replace("+", "%20");
          if (baseUrl.contains("{" + param + "}")) {
            reqUrl = baseUrl.replace("{" + param + "}", encodedForPath);
          } else if (baseUrl.contains(":" + param + "/") || baseUrl.endsWith(":" + param)) {
            reqUrl = baseUrl.replace(":" + param + "/", encodedForPath + "/").replace(":" + param, encodedForPath);
          } else if (baseUrl.contains("FUZZ")) {
            reqUrl = baseUrl.replace("FUZZ", encodedForPath);
          } else {
            reqUrl = AgentUtils.normalizeBase(baseUrl) + "/" + encodedForPath;
          }
        }
        default -> reqUrl = AgentUtils.setQueryParam(baseUrl, param, payload);
      }

      ToolResult tr = executeHttpRequest(targetBase, mth, reqUrl, reqHdrs, reqBody,
          "fuzz[" + i + "] " + param + "=" + AgentUtils.truncate(payload, 40), "*");

      int st  = tr.status != null ? tr.status : 0;
      int len = tr.responseBodyPreview != null ? tr.responseBodyPreview.length() : 0;
      long durMs = tr.durationMs != null ? tr.durationMs : 0;
      if (i == 0) { baseStatus = st; baseLen = len; baseDurMs = durMs; }

      String respSnippet = tr.responseBodyPreview != null ? tr.responseBodyPreview : "";
      boolean timingAnomaly = durMs > 3000 || (baseDurMs > 0 && durMs > baseDurMs * 3);
      boolean interesting = timingAnomaly
          || AgentUtils.isFuzzInteresting(st, len, baseStatus, baseLen, respSnippet);

      Map<String, Object> row = new LinkedHashMap<>();
      row.put("payload", payload);
      row.put("request_id", tr.requestId);
      row.put("status", st);
      row.put("body_length", len);
      row.put("duration_ms", durMs);
      row.put("interesting", interesting);
      if (interesting) {
        List<String> reasons = new ArrayList<>(
            List.of(AgentUtils.fuzzInterestReason(st, len, baseStatus, baseLen, respSnippet).split(", ")));
        if (timingAnomaly) {
          reasons.add(0, "timing_anomaly:" + durMs + "ms_vs_baseline:" + baseDurMs + "ms");
        }
        reasons.removeIf(String::isBlank);
        row.put("reason", String.join(", ", reasons));
      }
      results.add(row);
    }

    List<Map<String, Object>> interesting = results.stream()
        .filter(r -> Boolean.TRUE.equals(r.get("interesting")))
        .collect(Collectors.toList());

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("total_payloads", results.size());
    out.put("baseline_status", baseStatus);
    out.put("baseline_body_length", baseLen);
    out.put("interesting_count", interesting.size());
    out.put("interesting_results", interesting);
    out.put("all_results", results);
    return json.writeValueAsString(out);
  }

  // ─────────────────────── decode_encode ───────────────────────────────────

  String toolDecodeEncode(Map<String, Object> args) throws Exception {
    String op    = AgentUtils.str(args.getOrDefault("operation", "")).toLowerCase(Locale.ROOT);
    String input = AgentUtils.str(args.getOrDefault("input", ""));
    if (op.isBlank())    return json.writeValueAsString(Map.of("ok", false, "error", "operation is required"));
    if (input.isBlank()) return json.writeValueAsString(Map.of("ok", false, "error", "input is required"));
    String result;
    try {
      switch (op) {
        case "base64_decode"     -> result = new String(Base64.getDecoder().decode(input.trim()), StandardCharsets.UTF_8);
        case "base64_decode_url" -> result = new String(Base64.getUrlDecoder().decode(input.trim()), StandardCharsets.UTF_8);
        case "base64_encode"     -> result = Base64.getEncoder().encodeToString(input.getBytes(StandardCharsets.UTF_8));
        case "base64_encode_url" -> result = Base64.getUrlEncoder().withoutPadding().encodeToString(input.getBytes(StandardCharsets.UTF_8));
        case "url_decode"        -> result = java.net.URLDecoder.decode(input, StandardCharsets.UTF_8);
        case "url_encode"        -> result = URLEncoder.encode(input, StandardCharsets.UTF_8);
        case "hex_decode" -> {
          String h = input.replaceAll("\\s+", "");
          byte[] bytes = new byte[h.length() / 2];
          for (int i = 0; i < bytes.length; i++) bytes[i] = (byte) Integer.parseInt(h.substring(i * 2, i * 2 + 2), 16);
          result = new String(bytes, StandardCharsets.UTF_8);
        }
        case "hex_encode" -> {
          byte[] b = input.getBytes(StandardCharsets.UTF_8);
          StringBuilder sb = new StringBuilder();
          for (byte bv : b) sb.append(String.format("%02x", bv));
          result = sb.toString();
        }
        case "jwt_decode" -> {
          String[] parts = input.split("\\.");
          if (parts.length < 2) {
            return json.writeValueAsString(Map.of("ok", false, "error",
                "Input does not look like a JWT (expected header.payload.signature)"));
          }
          String hdr = new String(Base64.getUrlDecoder().decode(AgentUtils.padBase64(parts[0])), StandardCharsets.UTF_8);
          String pay = new String(Base64.getUrlDecoder().decode(AgentUtils.padBase64(parts[1])), StandardCharsets.UTF_8);
          Map<String, Object> out = new LinkedHashMap<>();
          out.put("ok", true); out.put("operation", op);
          out.put("header",  json.readValue(hdr, new TypeReference<Map<String, Object>>() {}));
          out.put("payload", json.readValue(pay, new TypeReference<Map<String, Object>>() {}));
          out.put("signature_present", parts.length == 3);
          return json.writeValueAsString(out);
        }
        case "html_decode" -> result = input
            .replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">")
            .replace("&quot;", "\"").replace("&#39;", "'").replace("&apos;", "'");
        case "html_encode" -> result = input
            .replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
            .replace("\"", "&quot;").replace("'", "&#39;");
        default -> {
          return json.writeValueAsString(Map.of("ok", false, "error", "Unknown operation: " + op,
              "supported", List.of("base64_decode", "base64_encode", "base64_decode_url", "base64_encode_url",
                  "url_decode", "url_encode", "hex_decode", "hex_encode", "jwt_decode", "html_decode", "html_encode")));
        }
      }
    } catch (Exception e) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Decode/encode failed: " + e.getMessage()));
    }
    return json.writeValueAsString(Map.of("ok", true, "operation", op, "result", result));
  }

  // ─────────────────────── search_in_response ──────────────────────────────

  String toolSearchInResponse(int requestId, String pattern, int contextLines) throws Exception {
    String body = responseBodyStore.get(requestId);
    if (body == null) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "No stored response for request_id " + requestId));
    }
    if (pattern == null || pattern.isBlank()) {
      return json.writeValueAsString(Map.of("ok", false, "error", "pattern is required"));
    }
    try {
      Pattern lineP = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
      String[] lines = body.split("\n", -1);
      int ctx = Math.max(0, Math.min(contextLines, 5));
      List<Integer> matchLineNums = new ArrayList<>();
      for (int li = 0; li < lines.length; li++) {
        if (lineP.matcher(lines[li]).find()) matchLineNums.add(li);
      }
      List<Map<String, Object>> hits = new ArrayList<>();
      for (int li : matchLineNums) {
        int from = Math.max(0, li - ctx);
        int to   = Math.min(lines.length - 1, li + ctx);
        List<String> ctxBlock = new ArrayList<>();
        for (int j = from; j <= to; j++) {
          ctxBlock.add((j == li ? ">> " : "   ") + "L" + (j + 1) + ": " + AgentUtils.truncate(lines[j], 200));
        }
        Matcher mm = lineP.matcher(lines[li]);
        List<String> matchValues = new ArrayList<>();
        while (mm.find()) { try { matchValues.add(mm.group()); } catch (Exception ignored) {} }
        Map<String, Object> hit = new LinkedHashMap<>();
        hit.put("line", li + 1);
        hit.put("matches", matchValues);
        hit.put("context", ctxBlock);
        hits.add(hit);
        if (hits.size() >= 50) break;
      }
      Map<String, Object> out = new LinkedHashMap<>();
      out.put("ok", true);
      out.put("pattern", pattern);
      out.put("total_matching_lines", matchLineNums.size());
      out.put("results", hits);
      if (matchLineNums.isEmpty()) {
        out.put("hint", "Pattern not found. Try a simpler pattern or use spider_links to discover endpoints.");
      }
      return json.writeValueAsString(out);
    } catch (java.util.regex.PatternSyntaxException pse) {
      return json.writeValueAsString(Map.of("ok", false, "error", "Invalid regex: " + pse.getMessage()));
    }
  }

  // ─────────────────────── get_sitemap ─────────────────────────────────────

  String toolGetSitemap(String baseUrl) throws Exception {
    String base = AgentUtils.normalizeBase(baseUrl);
    if (base.isBlank()) return json.writeValueAsString(Map.of("ok", false, "error", "base_url is required"));

    Set<String> seenFp = new LinkedHashSet<>();
    List<Map<String, Object>> endpoints = new ArrayList<>();

    try {
      List<HttpRequestResponse> siteMapEntries =
          api.siteMap().requestResponses(SiteMapFilter.prefixFilter(base));
      for (HttpRequestResponse rr : siteMapEntries) {
        if (rr.request() == null) continue;
        AgentUtils.addSitemapEntry(endpoints, seenFp,
            rr.request().url(), rr.request().method(),
            rr.response() != null ? rr.response().statusCode() : 0);
      }
    } catch (Exception e) {
      api.logging().logToError("[get_sitemap] sitemap query failed: " + e);
    }

    try {
      List<ProxyHttpRequestResponse> proxyEntries =
          api.proxy().history(rr -> rr.request() != null && rr.request().url().startsWith(base));
      for (ProxyHttpRequestResponse rr : proxyEntries) {
        if (rr.request() == null) continue;
        AgentUtils.addSitemapEntry(endpoints, seenFp,
            rr.request().url(), rr.request().method(),
            rr.response() != null ? rr.response().statusCode() : 0);
      }
    } catch (Exception e) {
      api.logging().logToError("[get_sitemap] proxy history query failed: " + e);
    }

    Map<String, Set<String>> pathMethods = new LinkedHashMap<>();
    Map<String, Set<String>> pathParams  = new LinkedHashMap<>();
    for (Map<String, Object> ep : endpoints) {
      String path   = String.valueOf(ep.get("path"));
      String method = String.valueOf(ep.get("method"));
      pathMethods.computeIfAbsent(path, k -> new LinkedHashSet<>()).add(method);
      @SuppressWarnings("unchecked")
      List<String> qp = (List<String>) ep.get("query_params");
      if (qp != null) pathParams.computeIfAbsent(path, k -> new LinkedHashSet<>()).addAll(qp);
    }

    List<Map<String, Object>> summary = new ArrayList<>();
    for (Map.Entry<String, Set<String>> e : pathMethods.entrySet()) {
      Map<String, Object> row = new LinkedHashMap<>();
      row.put("path", e.getKey());
      row.put("methods", new ArrayList<>(e.getValue()));
      Set<String> params = pathParams.getOrDefault(e.getKey(), new LinkedHashSet<>());
      if (!params.isEmpty()) row.put("query_params", new ArrayList<>(params));
      summary.add(row);
    }

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("base_url", base);
    out.put("total_entries", seenFp.size());
    out.put("unique_paths", summary.size());
    out.put("endpoints", summary);
    if (summary.isEmpty()) {
      out.put("hint", "No entries found for this base URL in the site map or proxy history. "
          + "Browse the target manually or run a baseline request first.");
    }
    return json.writeValueAsString(out);
  }

  // ─────────────────────── spider_links ────────────────────────────────────

  String toolSpiderLinks(int requestId, String baseUrl) throws Exception {
    String body = responseBodyStore.get(requestId);
    if (body == null) {
      return json.writeValueAsString(Map.of("ok", false, "error",
          "No stored response for request_id " + requestId));
    }

    String base = AgentUtils.normalizeBase(baseUrl);
    Set<String> links    = new LinkedHashSet<>();
    Set<String> forms    = new LinkedHashSet<>();
    Set<String> scripts  = new LinkedHashSet<>();
    Set<String> apiCalls = new LinkedHashSet<>();
    Set<String> inputs   = new LinkedHashSet<>();

    Matcher m;
    m = Pattern.compile("(?:href|src|data-url|data-href)=[\"']([^\"'#\\s][^\"']*)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) links.add(r); }

    m = Pattern.compile("<form[^>]+action=[\"']([^\"']+)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) forms.add(r); }

    m = Pattern.compile("<script[^>]+src=[\"']([^\"']+)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) scripts.add(r); }

    m = Pattern.compile(
        "(?:fetch|axios\\.(?:get|post|put|delete|patch)|\\$\\.(?:ajax|get|post))\\([\"']([^\"']+)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) apiCalls.add(r); }

    m = Pattern.compile("(?:url|endpoint|api_url|apiUrl):\\s*[\"']([^\"'?#]+(?:[?][^\"']*)?)[\"']",
        Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) { String r = AgentUtils.resolveUrl(base, m.group(1).trim()); if (r != null) apiCalls.add(r); }

    m = Pattern.compile("<input[^>]+name=[\"']([^\"']+)[\"']", Pattern.CASE_INSENSITIVE).matcher(body);
    while (m.find()) inputs.add(m.group(1));

    Map<String, Object> out = new LinkedHashMap<>();
    out.put("ok", true);
    out.put("base_url", base);
    out.put("links", new ArrayList<>(links));
    out.put("form_actions", new ArrayList<>(forms));
    out.put("scripts", new ArrayList<>(scripts));
    out.put("js_api_calls", new ArrayList<>(apiCalls));
    out.put("form_inputs", new ArrayList<>(inputs));
    out.put("total_discovered", links.size() + forms.size() + scripts.size() + apiCalls.size());
    return json.writeValueAsString(out);
  }

  // ─────────────────────── Header parsing ──────────────────────────────────

  Map<String, String> parseHeaders(Object obj) {
    if (obj == null) return new HashMap<>();
    if (obj instanceof Map<?, ?> map) {
      Map<String, String> result = new HashMap<>();
      for (Map.Entry<?, ?> entry : map.entrySet()) {
        result.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
      }
      return result;
    }
    if (obj instanceof String s && !s.isBlank()) {
      try {
        return json.readValue(s, new TypeReference<Map<String, String>>() {});
      } catch (Exception e) {
        logger.log("[WARN] Failed to parse headers string: " + e.getMessage() + "\n");
      }
    }
    return new HashMap<>();
  }
}
