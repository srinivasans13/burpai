package com.burpai.aipentester.clients;

import burp.api.montoya.logging.Logging;

import java.io.IOException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.TimeUnit;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.burpai.aipentester.llm.LlmClient;

public class OllamaClient implements LlmClient {

  private final String baseUrl;
  private final String model;
  private final Logging logging;
  private final HttpClient http;
  private final ObjectMapper json = new ObjectMapper();

  /** Flipped to true permanently once a 500 reveals the model doesn't support native tool/role:tool messages. */
  private volatile boolean toolsStripped = false;

  public OllamaClient(String baseUrl, String model, Logging logging) {
    this.baseUrl = baseUrl.endsWith("/") ? baseUrl.substring(0, baseUrl.length()-1) : baseUrl;
    this.model = model;
    this.logging = logging;
    this.http = HttpClient.newBuilder()
      .followRedirects(HttpClient.Redirect.NORMAL)
      // Burp environments often inherit corporate proxy settings; for local/private Ollama
      // this can cause hangs or unexpected routing. Force direct connections.
      .proxy(new NoProxySelector())
      .connectTimeout(Duration.ofSeconds(10))
        .build();
  }

  private static final class NoProxySelector extends ProxySelector {
    @Override
    public List<Proxy> select(URI uri) {
      return List.of(Proxy.NO_PROXY);
    }

    @Override
    public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
      // Ignore; caller will see the request failure.
    }
  }

  @Override
  public ConnResult testConnection() {
    logging.logToOutput("[DEBUG] testConnection() starting for: " + baseUrl);
    try {
      String url = baseUrl + "/api/tags";
      logging.logToOutput("[DEBUG] Building HTTP request to: " + url);
      
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .timeout(Duration.ofSeconds(5))
          .GET()
          .build();

      logging.logToOutput("[DEBUG] Sending HTTP request...");
      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(6));
      logging.logToOutput("[DEBUG] Got response with status: " + resp.statusCode());
      if (resp.statusCode() != 200) {
        String body = resp.body() == null ? "" : resp.body();
        if (body.length() > 500) body = body.substring(0, 500) + "...[truncated]";
        return new ConnResult(false, "Ollama returned status " + resp.statusCode() + ". Body: " + body); // NOSONAR
      }

      Map<String,Object> data = json.readValue(resp.body(), Map.class);
      List<Map<String,Object>> models = (List<Map<String,Object>>) data.getOrDefault("models", new ArrayList<>());

      if (models.isEmpty()) {
        return new ConnResult(false, "Connected to Ollama, but no models found. Run 'ollama pull " + model + "'");
      }

      boolean found = models.stream().anyMatch(m -> {
        String name = String.valueOf(m.get("name"));
        // Check exact or base name (e.g. qwen2.5:7b matches qwen2.5)
        return model.equals(name) || name.startsWith(model + ":");
      });

      if (found) return new ConnResult(true, "Connected. Model '" + model + "' is ready.");
      
      String available = String.join(", ", models.stream().map(m -> String.valueOf(m.get("name"))).toList());
      return new ConnResult(false, "Connected but model '" + model + "' not found. Available: " + available);

    } catch (IllegalArgumentException ex) {
      logging.logToError("testConnection IllegalArgumentException: " + ex);
      return new ConnResult(false, "Invalid Ollama URL format: " + baseUrl);
    } catch (Throwable t) {
      logging.logToError("testConnection Throwable: " + t);
      try {
        t.printStackTrace();
      } catch (Throwable ignored) {
        // ignore
      }
      String msg = t.getMessage();
      if (msg == null || msg.isBlank()) msg = String.valueOf(t);
      return new ConnResult(false, "Connection error: " + t.getClass().getName() + ": " + msg);
    } finally {
      logging.logToOutput("[DEBUG] testConnection() completed");
    }
  }

  @Override
  public ChatResult chat(List<Map<String,Object>> messages, List<Map<String,Object>> tools) {
    int attempts = 0;
    while (true) {
      attempts++;
      try {
        List<Map<String,Object>> sendMessages = toolsStripped ? stripToolMessages(messages) : messages;
        List<Map<String,Object>> sendTools   = toolsStripped ? List.of() : tools;

        Map<String,Object> payload = new HashMap<>();
        payload.put("model", model);
        payload.put("stream", false);
        payload.put("messages", sendMessages);
        payload.put("temperature", 0.7);
        if (!sendTools.isEmpty()) {
          payload.put("tools", sendTools);
        }

        String body = json.writeValueAsString(payload);
        logging.logToOutput("[OllamaClient] Sending chat (" + sendMessages.size() + " msgs, "
            + body.length() + " bytes, toolsStripped=" + toolsStripped + ")");

        HttpRequest req = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/api/chat"))
            .timeout(Duration.ofSeconds(120))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();

        HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(125));

        if (resp.statusCode() == 500 && !toolsStripped) {
          // Many models (especially cloud-proxied) return 500 when they receive
          // role:tool messages or the tools field. Strip both and retry.
          // toolsStripped is an instance field — all future iterations skip native tools too.
          logging.logToError("[OllamaClient] 500 from Ollama — switching permanently to text-mode tool calling. Body: "
              + truncate(resp.body(), 300));
          toolsStripped = true;
          attempts--; // don't count this against the retry limit
          continue;
        }

        if (resp.statusCode() != 200) {
          return LlmClient.ChatResult.err("Ollama /api/chat status " + resp.statusCode()
              + " body=" + truncate(resp.body(), 500));
        }

        Map<String,Object> data = json.readValue(resp.body(), Map.class);
        Map<String,Object> msg = (Map<String,Object>) data.getOrDefault("message", new HashMap<>());

        String content = String.valueOf(msg.getOrDefault("content", ""));

        // tool_calls parsing: supports common response shapes
        List<LlmClient.ToolCall> tcs = new ArrayList<>();

        // When toolsStripped, the model returns JSON tool calls as plain text — parse them
        if (toolsStripped) {
          tcs = parseToolCallsFromText(content);
        } else {
          Object tcObj = msg.get("tool_calls");
          if (tcObj == null) tcObj = data.get("tool_calls");

          if (tcObj instanceof List<?> list) {
            for (Object o : list) {
              if (!(o instanceof Map<?,?> m)) continue;

              String name = null;
              Object argsObj = null;

              // Shape A: { function: { name, arguments } }
              Object fnObj = m.get("function");
              if (fnObj instanceof Map<?,?> fn) {
                name = String.valueOf(fn.get("name"));
                argsObj = fn.get("arguments");
              }
              // Shape B: { name, arguments }
              if (name == null && m.get("name") != null) {
                name = String.valueOf(m.get("name"));
                argsObj = m.get("arguments");
              }
              if (name == null) continue;

              Map<String,Object> argsMap = new HashMap<>();
              if (argsObj instanceof Map<?,?> am) {
                argsMap = (Map<String,Object>) am;
              } else if (argsObj instanceof String s) {
                try {
                  Object parsed = json.readValue(s, Object.class);
                  if (parsed instanceof Map<?,?> pm) argsMap = (Map<String,Object>) pm;
                } catch (Exception ignored) {}
              }
              tcs.add(new LlmClient.ToolCall(name, argsMap));
            }
          }

          // Fallback: if native parsing found nothing, try text-mode parse on content.
          // Handles models (e.g. deepseek, cloud-proxied) that return 200 but embed
          // tool calls as JSON in the text instead of the tool_calls field.
          if (tcs.isEmpty() && content != null && !content.isBlank()) {
            tcs = parseToolCallsFromText(content);
            if (!tcs.isEmpty()) {
              logging.logToOutput("[OllamaClient] no native tool_calls found; text-mode fallback recovered "
                  + tcs.size() + " tool call(s)");
            }
          }
        }

        return LlmClient.ChatResult.ok(content, tcs);

      } catch (java.net.ConnectException | java.net.SocketTimeoutException | HttpTimeoutException e) {
        if (attempts >= 3) {
          logging.logToError("Ollama chat failed after retries: " + e);
          String msg = e.getMessage();
          if (msg == null || msg.isBlank()) msg = String.valueOf(e);
          return LlmClient.ChatResult.err(e.getClass().getName() + ": " + msg);
        }
        long backoffMs = attempts == 1 ? 250 : (attempts == 2 ? 750 : 1500);
        logging.logToError("Ollama chat transient failure (attempt " + attempts + "): " + e + " ; retrying after " + backoffMs + "ms");
        try {
          Thread.sleep(backoffMs);
        } catch (InterruptedException ie) {
          Thread.currentThread().interrupt();
          return LlmClient.ChatResult.err("Interrupted while retrying Ollama call");
        }
      } catch (Throwable t) {
        logging.logToError("Ollama chat failed: " + t);
        String msg = t.getMessage();
        if (msg == null || msg.isBlank()) msg = String.valueOf(t);
        return LlmClient.ChatResult.err(t.getClass().getName() + ": " + msg);
      }
    }
  }

  /**
   * Converts role:tool messages to role:user messages and drops any assistant
   * messages that contain only a tool_calls payload (no text), so the history
   * is valid for models that don't support native tool calling.
   * Also injects a system instruction so the model emits tool calls as JSON text.
   */
  @SuppressWarnings("unchecked")
  private static List<Map<String,Object>> stripToolMessages(List<Map<String,Object>> messages) {
    List<Map<String,Object>> out = new ArrayList<>();

    // Inject a system instruction at the top so the model knows to emit JSON
    Map<String,Object> textModeInstruction = new HashMap<>();
    textModeInstruction.put("role", "system");
    textModeInstruction.put("content",
        "TOOL CALLING MODE: This model does not support native function calling. " +
        "Whenever you want to call a tool, emit a JSON object in your response text with exactly this shape:\n" +
        "{\"name\":\"<tool_name>\",\"arguments\":{<args>}}\n" +
        "Available tools: execute_http_request, report_vulnerability, extract_from_response, get_variable, set_variable, fuzz_parameter, decode_encode, search_in_response, spider_links, get_sitemap, finish_run, generate_oob_payload, poll_collaborator\n" +
        "Examples:\n" +
        "{\"name\":\"execute_http_request\",\"arguments\":{\"method\":\"GET\",\"url\":\"/search?q=test\",\"purpose\":\"probe search\",\"expected\":\"200\"}}\n" +
        "{\"name\":\"extract_from_response\",\"arguments\":{\"request_id\":1,\"pattern\":\"csrf_token=([a-f0-9]+)\",\"store_as\":\"csrf\"}}\n" +
        "{\"name\":\"set_variable\",\"arguments\":{\"name\":\"token\",\"value\":\"abc123\"}}\n" +
        "{\"name\":\"get_variable\",\"arguments\":{\"name\":\"token\"}}\n" +
        "{\"name\":\"fuzz_parameter\",\"arguments\":{\"url\":\"https://host/search\",\"parameter\":\"q\",\"payload_list\":[\"'\",\"1 OR 1=1\",\"<script>\"],\"location\":\"query\"}}\n" +
        "{\"name\":\"decode_encode\",\"arguments\":{\"operation\":\"jwt_decode\",\"input\":\"eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxIn0.sig\"}}\n" +
        "{\"name\":\"search_in_response\",\"arguments\":{\"request_id\":1,\"pattern\":\"csrf|token|hidden\",\"context_lines\":2}}\n" +
        "{\"name\":\"spider_links\",\"arguments\":{\"request_id\":1}}\n" +
        "{\"name\":\"get_sitemap\",\"arguments\":{\"base_url\":\"https://host\"}}\n" +
        "{\"name\":\"finish_run\",\"arguments\":{\"summary\":\"Completed testing with no critical findings.\"}}\n" +
        "{\"name\":\"generate_oob_payload\",\"arguments\":{\"protocol\":\"dns\"}}\n" +
        "{\"name\":\"poll_collaborator\",\"arguments\":{}}\n" +
        "Do NOT use markdown fences. Text before/after the JSON is fine, but the JSON MUST be present and parseable.");
    out.add(textModeInstruction);

    for (Map<String,Object> m : messages) {
      String role = String.valueOf(m.getOrDefault("role", ""));
      if ("tool".equals(role)) {
        // Re-wrap result as a user message so the model still sees the tool output
        String name    = String.valueOf(m.getOrDefault("name", "tool"));
        String content = String.valueOf(m.getOrDefault("content", ""));
        Map<String,Object> wrapped = new HashMap<>();
        wrapped.put("role", "user");
        wrapped.put("content", "[Tool result for " + name + "]\n" + content);
        out.add(wrapped);
      } else {
        // Skip system messages that are already a text-mode instruction (avoid duplicates)
        if ("system".equals(role)) {
          String c = String.valueOf(m.getOrDefault("content", ""));
          if (c.startsWith("TOOL CALLING MODE:")) continue;
        }
        out.add(m);
      }
    }
    return out;
  }

  /**
   * When native tool calling is unavailable the model is expected to emit JSON
   * tool calls inline in its text. This parser handles two common shapes:
   * <pre>
   * ```json
   * {"name":"execute_http_request","arguments":{...}}
   * ```
   * </pre>
   * and bare JSON objects in the response text.
   */
  @SuppressWarnings("unchecked")
  private List<LlmClient.ToolCall> parseToolCallsFromText(String content) {
    List<LlmClient.ToolCall> result = new ArrayList<>();
    if (content == null || content.isBlank()) return result;

    // Strip <think>…</think> blocks emitted by reasoning models (DeepSeek, Qwen, etc.)
    // so the brace scanner doesn't trip over JSON-like fragments inside thinking output.
    content = content.replaceAll("(?s)<think>.*?</think>", "").strip();
    if (content.isBlank()) return result;

    // Extract all JSON objects that contain a "name" field with a tool name
    // Strategy: find all {...} blocks and try to parse them
    int depth = 0;
    int start = -1;
    for (int i = 0; i < content.length(); i++) {
      char c = content.charAt(i);
      if (c == '{') {
        if (depth == 0) start = i;
        depth++;
      } else if (c == '}') {
        depth--;
        if (depth == 0 && start >= 0) {
          String candidate = content.substring(start, i + 1);
          try {
            Object parsed = json.readValue(candidate, Object.class);
            if (parsed instanceof Map<?,?> m) {
              Map<String,Object> map = (Map<String,Object>) m;
              String name = null;
              Object argsObj = null;

              // Shape: { "name": "fn", "arguments": {...} }
              if (map.containsKey("name") && map.containsKey("arguments")) {
                name = String.valueOf(map.get("name"));
                argsObj = map.get("arguments");
              }
              // Shape: { "function": { "name": "fn", "arguments": {...} } }
              else if (map.containsKey("function") && map.get("function") instanceof Map<?,?> fn) {
                name = String.valueOf(((Map<?,?>)fn).get("name"));
                argsObj = ((Map<?,?>)fn).get("arguments");
              }

              if (name != null && isKnownTool(name)) {
                Map<String,Object> args = new HashMap<>();
                if (argsObj instanceof Map<?,?> am) args = (Map<String,Object>) am;
                else if (argsObj instanceof String s) {
                  try { Object p = json.readValue(s, Object.class);
                    if (p instanceof Map<?,?> pm) args = (Map<String,Object>) pm;
                  } catch (Exception ignored) {}
                }
                result.add(new LlmClient.ToolCall(name, args));
              }
            }
          } catch (Exception ignored) {}
          start = -1;
        }
      }
    }
    return result;
  }

  private static boolean isKnownTool(String name) {
    return "execute_http_request".equals(name)
        || "report_vulnerability".equals(name)
        || "extract_from_response".equals(name)
        || "get_variable".equals(name)
        || "set_variable".equals(name)
        || "fuzz_parameter".equals(name)
        || "decode_encode".equals(name)
        || "search_in_response".equals(name)
        || "spider_links".equals(name)
        || "get_sitemap".equals(name)
        || "finish_run".equals(name)
        || "generate_oob_payload".equals(name)
        || "poll_collaborator".equals(name);
  }

  private static String truncate(String s, int max) {
    if (s == null) return "";
    return s.length() <= max ? s : s.substring(0, max) + "...[truncated]";
  }

  private HttpResponse<String> sendWithTimeout(HttpRequest req, Duration timeout) throws Exception {
    var fut = http.sendAsync(req, HttpResponse.BodyHandlers.ofString());
    try {
      return fut.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException te) {
      fut.cancel(true);
      logging.logToError("[DEBUG] HTTP timeout after " + timeout.toSeconds() + "s for " + req.method() + " " + req.uri());
      throw new HttpTimeoutException("Timed out after " + timeout.toSeconds() + "s");
    } catch (ExecutionException ee) {
      Throwable cause = ee.getCause();
      if (cause instanceof Exception e) throw e;
      throw new RuntimeException(cause);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw ie;
    } catch (CompletionException ex) {
      Throwable cause = ex.getCause();
      if (cause instanceof Exception e) throw e;
      throw ex;
    }
  }
}
