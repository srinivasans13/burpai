package com.burpai.aipentester.clients;

import burp.api.montoya.logging.Logging;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import com.burpai.aipentester.llm.LlmClient;

/**
 * LLM client targeting the DeepSeek platform API directly.
 *
 * <p>Base URL: {@code https://api.deepseek.com}
 * <br>API docs: <a href="https://api-docs.deepseek.com/">https://api-docs.deepseek.com/</a>
 *
 * <h3>Models</h3>
 * <ul>
 *   <li>{@code deepseek-chat}     — DeepSeek-V3.2, standard mode (tool calls supported)</li>
 *   <li>{@code deepseek-reasoner} — DeepSeek-V3.2, thinking/R1 mode (CoT + tool calls).
 *       Returns {@code reasoning_content} alongside {@code content}.</li>
 * </ul>
 *
 * <h3>Thinking-mode tool calls (deepseek-reasoner)</h3>
 * When the model makes tool calls during a reasoning turn, the DeepSeek API requires that
 * the assistant message stored in the conversation history contains the full
 * {@code reasoning_content} from that turn, so it can continue reasoning on the next
 * sub-turn.  If {@code reasoning_content} is omitted, the API returns HTTP 400.
 * <p>This client handles this by populating {@link LlmClient.ChatResult#rawAssistantMessage}
 * with the complete assistant message (including {@code reasoning_content} and the
 * {@code tool_calls} array in OpenAI format).  {@link AgentLoop} stores this verbatim in
 * the conversation history, satisfying the API requirement transparently.
 */
public class DeepSeekClient implements LlmClient {

  private static final String CHAT_URL   = "https://api.deepseek.com/chat/completions";
  private static final String MODELS_URL = "https://api.deepseek.com/models";

  private final String model;
  private final String apiKey;
  private final Logging logging;
  private final HttpClient http;
  private final ObjectMapper json = new ObjectMapper();

  /** {@code true} when the model is in thinking/R1 mode. */
  private final boolean isReasoner;

  /**
   * @param model  e.g. {@code "deepseek-chat"} or {@code "deepseek-reasoner"}
   * @param apiKey DeepSeek API key from platform.deepseek.com
   */
  public DeepSeekClient(String model, String apiKey, Logging logging) {
    this.model      = model.trim();
    this.apiKey     = apiKey.trim();
    this.logging    = logging;
    this.isReasoner = this.model.contains("reasoner") || this.model.contains("r1");
    this.http = HttpClient.newBuilder()
        .followRedirects(HttpClient.Redirect.NORMAL)
        .proxy(new DirectProxySelector())     // bypass Burp proxy for external API
        .connectTimeout(Duration.ofSeconds(20))
        .build();
  }

  private static final class DirectProxySelector extends ProxySelector {
    @Override public List<Proxy> select(URI uri) { return List.of(Proxy.NO_PROXY); }
    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}
  }

  // ── LlmClient ─────────────────────────────────────────────────────────────

  @Override
  public ConnResult testConnection() {
    // GET /models — instant, no inference, validates the API key.
    try {
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(MODELS_URL))
          .timeout(Duration.ofSeconds(15))
          .header("Authorization", "Bearer " + apiKey)
          .GET()
          .build();

      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(20));

      if (resp.statusCode() == 401) {
        return new ConnResult(false, "DeepSeek API key is invalid (HTTP 401).");
      }
      if (resp.statusCode() == 402) {
        return new ConnResult(false,
            "DeepSeek: Insufficient balance. Top up at https://platform.deepseek.com");
      }
      if (resp.statusCode() != 200) {
        return new ConnResult(false, "DeepSeek /models returned HTTP " + resp.statusCode()
            + ": " + extractError(resp.body()));
      }

      boolean found = resp.body().contains("\"" + model + "\"");
      String msg = found
          ? "Connected to DeepSeek. API key valid. Model '" + model + "' is available."
              + (isReasoner ? " (thinking/R1 mode enabled)" : "")
          : "API key valid but model '" + model + "' not listed. "
              + "Common models: deepseek-chat, deepseek-reasoner";
      return new ConnResult(true, msg);

    } catch (Exception e) {
      return new ConnResult(false,
          "Connection error: " + e.getClass().getSimpleName() + ": " + e.getMessage());
    }
  }

  @Override
  public ChatResult chat(List<Map<String, Object>> messages, List<Map<String, Object>> tools) {
    int attempts = 0;
    while (true) {
      attempts++;
      try {
        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("model", model);
        payload.put("messages", messages);
        if (!tools.isEmpty()) {
          payload.put("tools", tools);
          payload.put("tool_choice", "auto");
        }
        // temperature is a no-op for deepseek-reasoner but causes no error; omit for cleanliness.
        if (!isReasoner) {
          payload.put("temperature", 0.7);
        }

        String body = json.writeValueAsString(payload);
        logging.logToOutput("[DeepSeekClient] POST " + CHAT_URL
            + " (msgs=" + messages.size() + ", body=" + body.length()
            + " bytes, reasoner=" + isReasoner + ")");

        HttpRequest req = HttpRequest.newBuilder()
            .uri(URI.create(CHAT_URL))
            .timeout(Duration.ofSeconds(180))
            .header("Content-Type", "application/json")
            .header("Authorization", "Bearer " + apiKey)
            .POST(HttpRequest.BodyPublishers.ofString(body))
            .build();

        HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(185));
        logging.logToOutput("[DeepSeekClient] HTTP " + resp.statusCode());

        if (resp.statusCode() == 401) {
          return ChatResult.err("DeepSeek: Invalid API key.");
        }
        if (resp.statusCode() == 402) {
          return ChatResult.err("DeepSeek: Insufficient balance. "
              + "Top up at https://platform.deepseek.com");
        }
        if (resp.statusCode() == 422) {
          return ChatResult.err("DeepSeek: Unprocessable request (422): "
              + extractError(resp.body()));
        }

        // 429 (rate limit) and 503 (overload) are retryable
        if (resp.statusCode() == 429 || resp.statusCode() == 503) {
          if (attempts >= 4) {
            return ChatResult.err("DeepSeek HTTP " + resp.statusCode()
                + " after " + attempts + " attempts: " + extractError(resp.body()));
          }
          long backoffMs = attempts * 3000L;
          logging.logToError("[DeepSeekClient] HTTP " + resp.statusCode()
              + "; retrying in " + backoffMs + "ms (attempt " + attempts + ")");
          Thread.sleep(backoffMs);
          continue;
        }

        if (resp.statusCode() != 200) {
          return ChatResult.err("DeepSeek HTTP " + resp.statusCode()
              + ": " + extractError(resp.body()));
        }

        // ── Parse response ─────────────────────────────────────────────────
        @SuppressWarnings("unchecked")
        Map<String, Object> data = json.readValue(resp.body(), Map.class);

        @SuppressWarnings("unchecked")
        List<Object> choices = (List<Object>) data.get("choices");
        if (choices == null || choices.isEmpty()) {
          return ChatResult.err("DeepSeek: missing 'choices' in response: "
              + truncate(resp.body(), 300));
        }

        @SuppressWarnings("unchecked")
        Map<String, Object> msg = (Map<String, Object>)
            ((Map<String, Object>) choices.get(0)).get("message");
        if (msg == null) {
          return ChatResult.err("DeepSeek: missing 'message' in choice");
        }

        Object rawContent = msg.get("content");
        String content = rawContent != null && !"null".equals(String.valueOf(rawContent))
            ? String.valueOf(rawContent) : "";

        // reasoning_content is only present on deepseek-reasoner turns
        Object rawReasoning = msg.get("reasoning_content");
        String reasoningContent = rawReasoning != null && !"null".equals(String.valueOf(rawReasoning))
            ? String.valueOf(rawReasoning) : null;
        if (reasoningContent != null) {
          logging.logToOutput("[DeepSeekClient] reasoning_content="
              + reasoningContent.length() + " chars");
        }

        List<LlmClient.ToolCall> toolCalls = parseToolCalls(msg);

        // Build the full raw assistant message.  For deepseek-reasoner, this includes
        // reasoning_content so the API can continue reasoning on the next tool-call sub-turn
        // (required; missing it causes HTTP 400).  AgentLoop stores this verbatim.
        Map<String, Object> rawAssistantMsg = buildRawAssistantMessage(
            content, reasoningContent, toolCalls);

        return ChatResult.ok(content, toolCalls, rawAssistantMsg);

      } catch (InterruptedException ie) {
        Thread.currentThread().interrupt();
        return ChatResult.err("Interrupted during DeepSeek call");

      } catch (java.net.ConnectException | java.net.SocketTimeoutException | HttpTimeoutException e) {
        if (attempts >= 3) {
          return ChatResult.err("DeepSeek connect/timeout after " + attempts
              + " attempts: " + e.getMessage());
        }
        long backoffMs = attempts * 2000L;
        logging.logToError("[DeepSeekClient] Transient error (attempt " + attempts
            + "): " + e + "; retrying in " + backoffMs + "ms");
        try {
          Thread.sleep(backoffMs);
        } catch (InterruptedException ie2) {
          Thread.currentThread().interrupt();
          return ChatResult.err("Interrupted while retrying");
        }

      } catch (Throwable t) {
        logging.logToError("[DeepSeekClient] chat failed: " + t);
        String err = t.getMessage();
        if (err == null || err.isBlank()) err = String.valueOf(t);
        return ChatResult.err(t.getClass().getName() + ": " + err);
      }
    }
  }

  // ── Helpers ────────────────────────────────────────────────────────────────

  /**
   * Constructs the assistant message map to store in the conversation history.
   * Includes {@code reasoning_content} (when non-null) and the {@code tool_calls}
   * array in OpenAI format (with proper IDs), satisfying the DeepSeek-reasoner
   * multi-turn tool-call contract.
   */
  private Map<String, Object> buildRawAssistantMessage(
      String content, String reasoningContent, List<LlmClient.ToolCall> toolCalls) {

    Map<String, Object> m = new LinkedHashMap<>();
    m.put("role", "assistant");
    m.put("content", content.isBlank() ? null : content);

    if (reasoningContent != null && !reasoningContent.isBlank()) {
      m.put("reasoning_content", reasoningContent);
    }

    if (!toolCalls.isEmpty()) {
      List<Map<String, Object>> tcList = new ArrayList<>();
      for (LlmClient.ToolCall tc : toolCalls) {
        Map<String, Object> tcMap = new LinkedHashMap<>();
        if (tc.id != null) tcMap.put("id", tc.id);
        tcMap.put("type", "function");
        String argsJson;
        try {
          argsJson = json.writeValueAsString(tc.args);
        } catch (Exception e) {
          argsJson = "{}";
        }
        tcMap.put("function", Map.of("name", tc.name, "arguments", argsJson));
        tcList.add(tcMap);
      }
      m.put("tool_calls", tcList);
    }

    return m;
  }

  @SuppressWarnings("unchecked")
  private List<LlmClient.ToolCall> parseToolCalls(Map<String, Object> msg) {
    List<LlmClient.ToolCall> result = new ArrayList<>();
    Object tcObj = msg.get("tool_calls");
    if (!(tcObj instanceof List<?> list)) return result;

    for (Object o : list) {
      if (!(o instanceof Map<?, ?> tc)) continue;
      String callId = tc.get("id") != null ? String.valueOf(tc.get("id")) : null;

      Object fnObj = tc.get("function");
      if (!(fnObj instanceof Map<?, ?> fn)) continue;

      String name = fn.get("name") != null ? String.valueOf(fn.get("name")) : null;
      if (name == null || name.isBlank()) continue;

      Object argsObj = fn.get("arguments");
      Map<String, Object> args = new HashMap<>();
      if (argsObj instanceof String s) {
        try {
          Object parsed = json.readValue(s, Object.class);
          if (parsed instanceof Map<?, ?> pm) args = (Map<String, Object>) pm;
        } catch (Exception ignored) {}
      } else if (argsObj instanceof Map<?, ?> am) {
        args = (Map<String, Object>) am;
      }
      result.add(new LlmClient.ToolCall(callId, name, args));
    }
    return result;
  }

  private String extractError(String body) {
    if (body == null || body.isBlank()) return "(empty body)";
    try {
      @SuppressWarnings("unchecked")
      Map<String, Object> map = json.readValue(body, Map.class);
      Object err = map.get("error");
      if (err instanceof Map<?, ?> em) {
        Object msg = em.get("message");
        if (msg != null) return String.valueOf(msg);
      }
      if (err != null) return String.valueOf(err);
    } catch (Exception ignored) {}
    return truncate(body, 300);
  }

  private static String truncate(String s, int max) {
    if (s == null) return "";
    return s.length() <= max ? s : s.substring(0, max) + "...[truncated]";
  }

  private HttpResponse<String> sendWithTimeout(HttpRequest req, Duration timeout) throws Exception {
    var fut = http.sendAsync(req, HttpResponse.BodyHandlers.ofString());
    try {
      return fut.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException te) {
      fut.cancel(true);
      throw new HttpTimeoutException("DeepSeek request timed out after " + timeout.toSeconds() + "s");
    } catch (ExecutionException ee) {
      Throwable cause = ee.getCause();
      if (cause instanceof Exception e) throw e;
      throw new RuntimeException(cause);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw ie;
    }
  }
}
