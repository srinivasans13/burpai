package com.burpai.aipentester.clients;

import burp.api.montoya.logging.Logging;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketAddress;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import com.burpai.aipentester.llm.LlmClient;

/**
 * LLM client targeting the Anthropic Claude REST API.
 *
 * <p>API reference: <a href="https://docs.anthropic.com/en/api/messages">
 * https://docs.anthropic.com/en/api/messages</a>
 *
 * <p>The Anthropic Messages API uses a different format from the OpenAI-compatible
 * clients. Key transformations performed internally:
 * <ul>
 *   <li>System messages are extracted and sent as the top-level {@code system} field.</li>
 *   <li>Tool schema is converted from OpenAI {@code parameters} format to Anthropic
 *       {@code input_schema} format.</li>
 *   <li>{@code role:tool} messages are converted to {@code role:user} messages containing
 *       {@code tool_result} content blocks. Consecutive tool results are merged into one
 *       user turn to satisfy Anthropic's strict alternation requirement.</li>
 *   <li>When an assistant turn contained only tool calls (no text), the agent loop does
 *       not store an assistant message. This client synthesises a minimal assistant message
 *       with the {@code tool_use} blocks to satisfy Anthropic's validation.</li>
 * </ul>
 */
public class ClaudeClient implements LlmClient {

  private static final String API_URL   = "https://api.anthropic.com/v1/messages";
  private static final String MODELS_URL = "https://api.anthropic.com/v1/models";
  private static final String ANTHROPIC_VERSION = "2023-06-01";

  /** Default max_tokens — Claude requires this to be set explicitly. */
  private static final int MAX_TOKENS = 8192;

  private final String model;
  private final String apiKey;
  private final Logging logging;
  private final HttpClient http;
  private final ObjectMapper json = new ObjectMapper();

  /**
   * @param model  Anthropic model ID, e.g. {@code "claude-opus-4-5"} or {@code "claude-sonnet-4-5"}
   * @param apiKey Anthropic API key (sk-ant-…)
   */
  public ClaudeClient(String model, String apiKey, Logging logging) {
    this.model   = model.trim();
    this.apiKey  = apiKey.trim();
    this.logging = logging;
    this.http = HttpClient.newBuilder()
        .followRedirects(HttpClient.Redirect.NORMAL)
        .proxy(new DirectProxySelector())   // bypass Burp proxy for external API calls
        .connectTimeout(Duration.ofSeconds(20))
        .build();
  }

  // Force direct connections — avoids Burp intercepting calls to api.anthropic.com.
  private static final class DirectProxySelector extends ProxySelector {
    @Override public List<Proxy> select(URI uri) { return List.of(Proxy.NO_PROXY); }
    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {}
  }

  // ── LlmClient ─────────────────────────────────────────────────────────────

  @Override
  public ConnResult testConnection() {
    try {
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(MODELS_URL))
          .timeout(Duration.ofSeconds(15))
          .header("x-api-key", apiKey)
          .header("anthropic-version", ANTHROPIC_VERSION)
          .GET()
          .build();

      HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(20));

      if (resp.statusCode() == 401 || resp.statusCode() == 403) {
        return new ConnResult(false,
            "Claude API key is invalid or lacks permission (HTTP " + resp.statusCode() + ").");
      }
      if (resp.statusCode() != 200) {
        return new ConnResult(false,
            "Anthropic /models returned HTTP " + resp.statusCode()
            + ": " + extractError(resp.body()));
      }

      // Verify the requested model exists in Anthropic's model list.
      boolean found = resp.body().contains("\"" + model + "\"");
      if (!found) {
        return new ConnResult(false,
            "API key is valid but model '" + model + "' was not found in Anthropic's model list. "
            + "Check the model ID at https://docs.anthropic.com/en/docs/about-claude/models");
      }
      return new ConnResult(true,
          "Connected to Anthropic Claude API. Key valid. Model '" + model + "' is available.");

    } catch (Exception e) {
      return new ConnResult(false,
          "Connection error: " + e.getClass().getSimpleName() + ": " + e.getMessage());
    }
  }

  @Override
  public ChatResult chat(List<Map<String, Object>> messages, List<Map<String, Object>> tools) {
    int attempts = 0;
    while (true) {
      attempts++;
      try {
        // ── Transform messages and tools to Anthropic format ──────────────
        String systemText = extractSystem(messages);
        List<Map<String, Object>> anthropicMessages = toAnthropicMessages(messages);
        List<Map<String, Object>> anthropicTools    = toAnthropicTools(tools);

        Map<String, Object> payload = new LinkedHashMap<>();
        payload.put("model", model);
        payload.put("max_tokens", MAX_TOKENS);
        if (!systemText.isBlank()) {
          payload.put("system", systemText);
        }
        payload.put("messages", anthropicMessages);
        if (!anthropicTools.isEmpty()) {
          payload.put("tools", anthropicTools);
          // "auto" lets the model decide when to use tools
          payload.put("tool_choice", Map.of("type", "auto"));
        }

        String body = json.writeValueAsString(payload);
        logging.logToOutput("[ClaudeClient] POST " + API_URL
            + " (msgs=" + anthropicMessages.size() + ", body=" + body.length()
            + " bytes, model=" + model + ")");

        HttpRequest req = buildRequest(body, Duration.ofSeconds(180));
        HttpResponse<String> resp = sendWithTimeout(req, Duration.ofSeconds(185));
        logging.logToOutput("[ClaudeClient] HTTP " + resp.statusCode());

        // ── 401/403: bad key ──────────────────────────────────────────────
        if (resp.statusCode() == 401 || resp.statusCode() == 403) {
          return ChatResult.err("Anthropic: Invalid API key (HTTP " + resp.statusCode()
              + "). Check your key at https://console.anthropic.com/");
        }

        // ── 529 / 529: overloaded ─────────────────────────────────────────
        // 429 rate limit, 529 overloaded — retryable
        int sc = resp.statusCode();
        if (sc == 429 || sc == 500 || sc == 529) {
          if (attempts >= 4) {
            return ChatResult.err("Anthropic HTTP " + sc + " after " + attempts
                + " attempts: " + extractError(resp.body()));
          }
          long backoffMs = attempts * 3000L;
          logging.logToError("[ClaudeClient] HTTP " + sc
              + " (retryable); retrying in " + backoffMs + "ms (attempt " + attempts + ")");
          Thread.sleep(backoffMs);
          continue;
        }

        if (resp.statusCode() != 200) {
          return ChatResult.err("Anthropic HTTP " + resp.statusCode()
              + ": " + extractError(resp.body()));
        }

        // ── Parse response ────────────────────────────────────────────────
        @SuppressWarnings("unchecked")
        Map<String, Object> data = json.readValue(resp.body(), Map.class);

        @SuppressWarnings("unchecked")
        List<Object> contentBlocks = (List<Object>) data.get("content");
        if (contentBlocks == null || contentBlocks.isEmpty()) {
          return ChatResult.err("Anthropic response missing 'content': " + truncate(resp.body(), 300));
        }

        String textContent = "";
        List<LlmClient.ToolCall> toolCalls = new ArrayList<>();

        for (Object block : contentBlocks) {
          if (!(block instanceof Map<?, ?> b)) continue;
          Object typeObj = b.get("type");
          String type = typeObj != null ? String.valueOf(typeObj) : "";
          if ("text".equals(type)) {
            Object t = b.get("text");
            if (t != null) textContent += String.valueOf(t);
          } else if ("tool_use".equals(type)) {
            String id   = b.get("id")   != null ? String.valueOf(b.get("id"))   : null;
            String name = b.get("name") != null ? String.valueOf(b.get("name")) : null;
            if (name == null || name.isBlank()) continue;

            @SuppressWarnings("unchecked")
            Map<String, Object> input = b.get("input") instanceof Map<?, ?> m
                ? (Map<String, Object>) m : new HashMap<>();
            toolCalls.add(new LlmClient.ToolCall(id, name, input));
          }
        }

        return ChatResult.ok(textContent, toolCalls);

      } catch (InterruptedException ie) {
        Thread.currentThread().interrupt();
        return ChatResult.err("Interrupted during Anthropic Claude call");

      } catch (java.net.ConnectException | java.net.SocketTimeoutException | HttpTimeoutException e) {
        if (attempts >= 3) {
          return ChatResult.err("Anthropic connect/timeout after " + attempts
              + " attempts: " + e.getMessage());
        }
        long backoffMs = attempts * 1500L;
        logging.logToError("[ClaudeClient] Transient failure (attempt " + attempts
            + "): " + e + "; retrying in " + backoffMs + "ms");
        try {
          Thread.sleep(backoffMs);
        } catch (InterruptedException ie2) {
          Thread.currentThread().interrupt();
          return ChatResult.err("Interrupted while retrying Anthropic call");
        }

      } catch (Throwable t) {
        logging.logToError("[ClaudeClient] chat failed: " + t);
        String msg = t.getMessage();
        if (msg == null || msg.isBlank()) msg = String.valueOf(t);
        return ChatResult.err(t.getClass().getName() + ": " + msg);
      }
    }
  }

  // ── Message transformation ─────────────────────────────────────────────────

  /**
   * Concatenates all {@code role:system} messages into a single string for the
   * Anthropic top-level {@code system} field.
   */
  private static String extractSystem(List<Map<String, Object>> messages) {
    StringBuilder sb = new StringBuilder();
    for (Map<String, Object> m : messages) {
      if ("system".equals(m.get("role"))) {
        Object c = m.get("content");
        if (c != null && !String.valueOf(c).isBlank()) {
          if (sb.length() > 0) sb.append("\n\n");
          sb.append(String.valueOf(c));
        }
      }
    }
    return sb.toString();
  }

  /**
   * Converts an OpenAI-style message list to Anthropic's {@code messages} array.
   *
   * <p>Rules:
   * <ul>
   *   <li>System messages are skipped (extracted separately by {@link #extractSystem}).</li>
   *   <li>User messages are passed through with string content.</li>
   *   <li>Assistant messages are passed through with string content.</li>
   *   <li>{@code role:tool} messages are converted to user turns containing
   *       {@code tool_result} content blocks. Consecutive tool messages are merged into
   *       one user turn.</li>
   *   <li>If tool result messages appear without a preceding assistant message (which
   *       happens when Claude returned only tool calls with no text content and the agent
   *       loop did not store the assistant turn), a synthetic assistant message is inserted
   *       containing {@code tool_use} blocks so Anthropic's strict alternation and
   *       ID-reference requirements are met.</li>
   *   <li>The resulting list always starts with a user turn and strictly alternates.</li>
   * </ul>
   */
  @SuppressWarnings("unchecked")
  private static List<Map<String, Object>> toAnthropicMessages(List<Map<String, Object>> messages) {
    // Build an intermediate list of non-system messages.
    List<Map<String, Object>> filtered = new ArrayList<>();
    for (Map<String, Object> m : messages) {
      if (!"system".equals(m.get("role"))) {
        filtered.add(m);
      }
    }

    List<Map<String, Object>> out = new ArrayList<>();

    int i = 0;
    while (i < filtered.size()) {
      Map<String, Object> m = filtered.get(i);
      String role = String.valueOf(m.getOrDefault("role", ""));

      if ("user".equals(role)) {
        // Collect all consecutive tool messages that follow immediately
        // (they will be grouped into this user turn if they appear first).
        // But for a plain user text message, just add it.
        String content = String.valueOf(m.getOrDefault("content", ""));

        // Check if the previous out entry was also a user — merge if so.
        if (!out.isEmpty() && "user".equals(out.get(out.size() - 1).get("role"))) {
          mergeUserContent(out.get(out.size() - 1), "text", content, null);
        } else {
          out.add(userTextMsg(content));
        }
        i++;

      } else if ("assistant".equals(role)) {
        String content = String.valueOf(m.getOrDefault("content", ""));
        // Merge consecutive assistant messages (edge case from pruning).
        if (!out.isEmpty() && "assistant".equals(out.get(out.size() - 1).get("role"))) {
          Object existing = out.get(out.size() - 1).get("content");
          if (existing instanceof List<?> blocks) {
            ((List<Map<String, Object>>) blocks).add(textBlock(content));
          }
        } else {
          out.add(assistantTextMsg(content));
        }
        i++;

      } else if ("tool".equals(role)) {
        // Consecutive tool messages → one user turn with multiple tool_result blocks.
        // If the last out entry is NOT assistant, we need to synthesise one.

        // Collect all consecutive tool messages starting from i.
        List<Map<String, Object>> toolMsgs = new ArrayList<>();
        int j = i;
        while (j < filtered.size() && "tool".equals(filtered.get(j).get("role"))) {
          toolMsgs.add(filtered.get(j));
          j++;
        }

        // Ensure the immediately preceding turn in out is an assistant; synthesise one if not.
        if (out.isEmpty() || !"assistant".equals(out.get(out.size() - 1).get("role"))) {
          // Synthesise an assistant message with tool_use blocks matching the tool_call_ids.
          List<Map<String, Object>> syntheticBlocks = new ArrayList<>();
          for (Map<String, Object> tm : toolMsgs) {
            String tcId   = tm.get("tool_call_id") != null ? String.valueOf(tm.get("tool_call_id")) : generateId();
            String tcName = tm.get("name") != null ? String.valueOf(tm.get("name")) : "unknown_tool";
            Map<String, Object> tuBlock = new LinkedHashMap<>();
            tuBlock.put("type", "tool_use");
            tuBlock.put("id", tcId);
            tuBlock.put("name", tcName);
            tuBlock.put("input", new HashMap<>());  // input unavailable; empty is acceptable
            syntheticBlocks.add(tuBlock);
          }
          Map<String, Object> syntheticAssistant = new LinkedHashMap<>();
          syntheticAssistant.put("role", "assistant");
          syntheticAssistant.put("content", syntheticBlocks);
          out.add(syntheticAssistant);
        }

        // Build the user turn with tool_result blocks.
        List<Map<String, Object>> toolResultBlocks = new ArrayList<>();
        for (Map<String, Object> tm : toolMsgs) {
          String tcId      = tm.get("tool_call_id") != null ? String.valueOf(tm.get("tool_call_id")) : null;
          String tcContent = String.valueOf(tm.getOrDefault("content", ""));
          Map<String, Object> trBlock = new LinkedHashMap<>();
          trBlock.put("type", "tool_result");
          if (tcId != null) trBlock.put("tool_use_id", tcId);
          trBlock.put("content", tcContent);
          toolResultBlocks.add(trBlock);
        }
        Map<String, Object> toolResultUserMsg = new LinkedHashMap<>();
        toolResultUserMsg.put("role", "user");
        toolResultUserMsg.put("content", toolResultBlocks);
        out.add(toolResultUserMsg);
        i = j;

      } else {
        // Unknown role — skip.
        i++;
      }
    }

    // Anthropic requires the first message to be role:user.
    // Drop any leading assistant turns (shouldn't happen, but guard anyway).
    while (!out.isEmpty() && !"user".equals(out.get(0).get("role"))) {
      out.remove(0);
    }

    return out;
  }

  /** Creates a user message with plain text content. */
  private static Map<String, Object> userTextMsg(String text) {
    Map<String, Object> m = new LinkedHashMap<>();
    m.put("role", "user");
    m.put("content", text);
    return m;
  }

  /** Creates an assistant message whose content is a list of content blocks. */
  private static Map<String, Object> assistantTextMsg(String text) {
    List<Map<String, Object>> blocks = new ArrayList<>();
    blocks.add(textBlock(text));
    Map<String, Object> m = new LinkedHashMap<>();
    m.put("role", "assistant");
    m.put("content", blocks);
    return m;
  }

  private static Map<String, Object> textBlock(String text) {
    Map<String, Object> b = new LinkedHashMap<>();
    b.put("type", "text");
    b.put("text", text);
    return b;
  }

  /**
   * Merges additional content into an existing user message.
   * The existing message's content field is upgraded to a list of blocks if needed.
   */
  @SuppressWarnings("unchecked")
  private static void mergeUserContent(Map<String, Object> existingUserMsg,
                                        String type, String text, String toolUseId) {
    Object existing = existingUserMsg.get("content");
    List<Map<String, Object>> blocks;
    if (existing instanceof List<?>) {
      blocks = (List<Map<String, Object>>) existing;
    } else {
      // Convert string content to list form
      blocks = new ArrayList<>();
      if (existing != null && !String.valueOf(existing).isBlank()) {
        blocks.add(textBlock(String.valueOf(existing)));
      }
      existingUserMsg.put("content", blocks);
    }
    if ("text".equals(type)) {
      blocks.add(textBlock(text));
    } else if ("tool_result".equals(type)) {
      Map<String, Object> trBlock = new LinkedHashMap<>();
      trBlock.put("type", "tool_result");
      if (toolUseId != null) trBlock.put("tool_use_id", toolUseId);
      trBlock.put("content", text);
      blocks.add(trBlock);
    }
  }

  private static String generateId() {
    return "toolu_" + Long.toHexString(System.nanoTime());
  }

  // ── Tool schema transformation ──────────────────────────────────────────────

  /**
   * Converts OpenAI-style tool definitions to Anthropic's format.
   *
   * <p>OpenAI: {@code {"type": "function", "function": {"name": "...", "description": "...", "parameters": {...}}}}
   * <p>Anthropic: {@code {"name": "...", "description": "...", "input_schema": {...}}}
   */
  @SuppressWarnings("unchecked")
  private static List<Map<String, Object>> toAnthropicTools(List<Map<String, Object>> openAiTools) {
    if (openAiTools == null || openAiTools.isEmpty()) return List.of();
    List<Map<String, Object>> anthropicTools = new ArrayList<>();
    for (Map<String, Object> tool : openAiTools) {
      Object fnObj = tool.get("function");
      if (!(fnObj instanceof Map<?, ?> fn)) continue;
      Map<String, Object> anthropicTool = new LinkedHashMap<>();
      anthropicTool.put("name", fn.get("name"));
      anthropicTool.put("description", fn.get("description"));
      // Anthropic uses "input_schema" where OpenAI uses "parameters"
      Object params = fn.get("parameters");
      anthropicTool.put("input_schema", params != null ? params : Map.of("type", "object", "properties", Map.of()));
      anthropicTools.add(anthropicTool);
    }
    return anthropicTools;
  }

  // ── Helpers ────────────────────────────────────────────────────────────────

  private HttpRequest buildRequest(String body, Duration timeout) {
    return HttpRequest.newBuilder()
        .uri(URI.create(API_URL))
        .timeout(timeout)
        .header("Content-Type", "application/json")
        .header("x-api-key", apiKey)
        .header("anthropic-version", ANTHROPIC_VERSION)
        .POST(HttpRequest.BodyPublishers.ofString(body))
        .build();
  }

  private String extractError(String body) {
    if (body == null || body.isBlank()) return "(empty body)";
    try {
      @SuppressWarnings("unchecked")
      Map<String, Object> map = json.readValue(body, Map.class);
      Object err = map.get("error");
      if (err instanceof Map<?, ?> em) {
        Object msg = em.get("message");
        if (msg != null) return String.valueOf(msg);
      }
      if (err != null) return String.valueOf(err);
    } catch (Exception ignored) {}
    return truncate(body, 300);
  }

  private static String truncate(String s, int max) {
    if (s == null) return "";
    return s.length() <= max ? s : s.substring(0, max) + "...[truncated]";
  }

  private HttpResponse<String> sendWithTimeout(HttpRequest req, Duration timeout) throws Exception {
    var fut = http.sendAsync(req, HttpResponse.BodyHandlers.ofString());
    try {
      return fut.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException te) {
      fut.cancel(true);
      throw new HttpTimeoutException("Anthropic request timed out after " + timeout.toSeconds() + "s");
    } catch (ExecutionException ee) {
      Throwable cause = ee.getCause();
      if (cause instanceof Exception e) throw e;
      throw new RuntimeException(cause);
    } catch (InterruptedException ie) {
      Thread.currentThread().interrupt();
      throw ie;
    }
  }
}
