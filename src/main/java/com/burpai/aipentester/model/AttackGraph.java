package com.burpai.aipentester.model;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URI;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Directed graph of discovered endpoints and their testing state.
 *
 * <p>Thread-safe: the node map is a {@link ConcurrentHashMap} and individual
 * {@link EndpointNode} fields use concurrent collections or volatile primitives.
 *
 * <p>Has <b>zero</b> dependencies on {@link AgentLoop}.
 */
public class AttackGraph {

  private final ConcurrentHashMap<String, EndpointNode> nodes = new ConcurrentHashMap<>();
  private static final ObjectMapper JSON = new ObjectMapper();

  // ── Mutation API ──────────────────────────────────────────────────────────

  public void upsertEndpoint(String path) {
    String key = normalise(path);
    if (key.isEmpty()) return;
    nodes.computeIfAbsent(key, EndpointNode::new).touch();
  }

  public void addMethod(String path, String method) {
    String key = normalise(path);
    if (key.isEmpty() || method == null || method.isBlank()) return;
    EndpointNode node = nodes.computeIfAbsent(key, EndpointNode::new);
    node.methods.add(method.toUpperCase(Locale.ROOT));
    node.touch();
  }

  public void addParameter(String path, String param) {
    String key = normalise(path);
    if (key.isEmpty() || param == null || param.isBlank()) return;
    EndpointNode node = nodes.computeIfAbsent(key, EndpointNode::new);
    node.parameters.add(param);
    node.touch();
  }

  public void addExtractedVariable(String path, String variable) {
    String key = normalise(path);
    if (key.isEmpty() || variable == null || variable.isBlank()) return;
    EndpointNode node = nodes.computeIfAbsent(key, EndpointNode::new);
    node.extractedVariables.add(variable);
    node.touch();
  }

  public void markPayloadTested(String path, String vulnClass) {
    String key = normalise(path);
    if (key.isEmpty() || vulnClass == null || vulnClass.isBlank()) return;
    EndpointNode node = nodes.get(key);
    if (node != null) {
      node.testedPayloadTypes.add(vulnClass);
      // Intentionally no touch() — timestamp must reflect discovery/activity,
      // not test completion. Calling touch() here would push fully-tested
      // endpoints to the top of the next suggestion list.
    }
  }

  public void setAuthRequired(String path, boolean required) {
    String key = normalise(path);
    if (key.isEmpty()) return;
    EndpointNode node = nodes.computeIfAbsent(key, EndpointNode::new);
    node.authRequired = required;
    node.touch();
  }

  // ── Query API ─────────────────────────────────────────────────────────────

  /**
   * Suggests up to {@code limit} endpoint paths for the agent to target next.
   *
   * <p>Selection tiers (each sorted by {@code lastSeenTimestamp} descending):
   * <ol>
   *   <li>Has parameters + not yet tested for {@code vulnClass}</li>
   *   <li>No parameters discovered yet (baseline candidate)</li>
   *   <li>Has parameters + other vuln classes tested but not this one</li>
   * </ol>
   * Endpoints already containing {@code vulnClass} in {@code testedPayloadTypes}
   * are skipped entirely.
   */
  public List<String> suggestNextTargets(String vulnClass, int limit) {
    if (vulnClass == null) vulnClass = VulnClass.GENERAL;

    String vc = vulnClass;

    // Primary: lastSeenTimestamp DESC; secondary: parameter count DESC (more surface = higher priority)
    Comparator<EndpointNode> tierOrder =
        Comparator.<EndpointNode>comparingLong(n -> n.lastSeenTimestamp).reversed()
            .thenComparing(
                Comparator.<EndpointNode>comparingInt(n -> n.parameters.size()).reversed());

    // Tier 1: has params + not tested for this vulnClass
    List<EndpointNode> tier1 = nodes.values().stream()
        .filter(n -> n.hasParameters() && n.hasUntestedPayload(vc))
        .sorted(tierOrder)
        .collect(Collectors.toList());

    // Tier 2: no params discovered yet (baseline candidate)
    List<EndpointNode> tier2 = nodes.values().stream()
        .filter(n -> !n.hasParameters() && n.hasUntestedPayload(vc))
        .sorted(tierOrder)
        .collect(Collectors.toList());

    // Tier 3: has params + other classes tested but not this one
    List<EndpointNode> tier3 = nodes.values().stream()
        .filter(n -> n.hasParameters()
            && n.hasUntestedPayload(vc)
            && !n.testedPayloadTypes.isEmpty())
        .sorted(tierOrder)
        .collect(Collectors.toList());

    // Remove tier3 entries already in tier1 to avoid duplicates
    Set<String> tier1Paths = tier1.stream().map(n -> n.path).collect(Collectors.toSet());
    tier3.removeIf(n -> tier1Paths.contains(n.path));

    return Stream.of(tier1, tier2, tier3)
        .flatMap(Collection::stream)
        .map(n -> n.path)
        .distinct()
        .limit(limit)
        .collect(Collectors.toList());
  }

  /**
   * Returns all endpoint nodes that have not been tested for the given
   * vulnerability class.
   */
  List<EndpointNode> getUntestedTargets(String vulnClass) {
    if (vulnClass == null) vulnClass = VulnClass.GENERAL;
    String vc = vulnClass;
    return nodes.values().stream()
        .filter(n -> n.hasUntestedPayload(vc))
        .sorted(Comparator.comparingLong((EndpointNode n) -> n.lastSeenTimestamp).reversed())
        .collect(Collectors.toList());
  }

  /**
   * Counts the total number of discovered parameters across all endpoints
   * that have NOT yet been tested for the given vuln class.
   */
  public int untestedParamsCount(String vulnClass) {
    if (vulnClass == null) vulnClass = VulnClass.GENERAL;
    String vc = vulnClass;
    return nodes.values().stream()
        .filter(n -> n.hasUntestedPayload(vc) && n.hasParameters())
        .mapToInt(n -> n.parameters.size())
        .sum();
  }

  // ── Serialization (testing state only — NOT topology) ─────────────────────

  /**
   * Serialises only the testing-relevant state of each node:
   * {@code testedPayloadTypes}, {@code extractedVariables}, {@code authRequired}.
   *
   * <p>Topology (paths, methods, parameters) is NOT included — that lives
   * in {@link TargetMemoryStore}.
   */
  public String serializeTestingState() {
    try {
      Map<String, Map<String, Object>> state = new LinkedHashMap<>();
      for (var entry : nodes.entrySet()) {
        EndpointNode node = entry.getValue();
        // Only serialize nodes that have some testing state
        if (node.testedPayloadTypes.isEmpty()
            && node.extractedVariables.isEmpty()
            && node.authRequired == null) {
          continue;
        }
        Map<String, Object> nodeState = new LinkedHashMap<>();
        if (!node.testedPayloadTypes.isEmpty()) {
          nodeState.put("testedPayloadTypes", new ArrayList<>(node.testedPayloadTypes));
        }
        if (!node.extractedVariables.isEmpty()) {
          nodeState.put("extractedVariables", new ArrayList<>(node.extractedVariables));
        }
        if (node.authRequired != null) {
          nodeState.put("authRequired", node.authRequired);
        }
        state.put(entry.getKey(), nodeState);
      }
      return JSON.writeValueAsString(state);
    } catch (Exception e) {
      return "{}";
    }
  }

  /**
   * Restores testing state previously produced by {@link #serializeTestingState()}.
   * Nodes are created (or updated) for each path in the serialised map.
   */
  public void restoreTestingState(String serialized) {
    if (serialized == null || serialized.isBlank()) return;
    try {
      Map<String, Map<String, Object>> state = JSON.readValue(serialized,
          new TypeReference<Map<String, Map<String, Object>>>() {});
      for (var entry : state.entrySet()) {
        String path = entry.getKey();
        Map<String, Object> nodeState = entry.getValue();
        EndpointNode node = nodes.computeIfAbsent(path, EndpointNode::new);

        Object tpt = nodeState.get("testedPayloadTypes");
        if (tpt instanceof List<?> list) {
          for (Object item : list) node.testedPayloadTypes.add(String.valueOf(item));
        }

        Object ev = nodeState.get("extractedVariables");
        if (ev instanceof List<?> list) {
          for (Object item : list) node.extractedVariables.add(String.valueOf(item));
        }

        Object ar = nodeState.get("authRequired");
        if (ar instanceof Boolean b) {
          node.authRequired = b;
        }
      }
    } catch (Exception ignored) {
      // Gracefully degrade — start fresh if deserialization fails
    }
  }

  // ── Internal helpers ──────────────────────────────────────────────────────

  /**
   * Normalises a URL or path to a canonical path-only key.
   *
   * <ul>
   *   <li>Absolute URLs: scheme+host stripped, path extracted, query and fragment discarded.</li>
   *   <li>Relative paths: query and fragment discarded.</li>
   *   <li>Trailing slash removed except for bare {@code "/"}.</li>
   *   <li>Empty path after stripping collapses to {@code "/"}.</li>
   * </ul>
   *
   * Examples:
   * <pre>
   *   "http://example.com/api/login"      → "/api/login"
   *   "http://example.com/api/login/"     → "/api/login"
   *   "http://example.com/api/login?x=1"  → "/api/login"
   *   "/api/login"                        → "/api/login"
   *   "http://example.com/"               → "/"
   *   "http://example.com"                → "/"
   * </pre>
   */
  static String normalise(String path) {
    if (path == null || path.isBlank()) return "";
    String s = path.trim();

    if (s.contains("://")) {
      // Absolute URL — extract path component only
      try {
        URI uri = new URI(s);
        String p = uri.getPath();
        s = (p == null || p.isEmpty()) ? "/" : p;
      } catch (Exception e) {
        // Malformed URI: best-effort strip of scheme+host
        int slashSlash = s.indexOf("://");
        int afterHost  = s.indexOf('/', slashSlash + 3);
        s = (afterHost < 0) ? "/" : s.substring(afterHost);
      }
    } else {
      // Relative path — strip query string and fragment
      int q = s.indexOf('?');
      if (q >= 0) s = s.substring(0, q);
      int h = s.indexOf('#');
      if (h >= 0) s = s.substring(0, h);
    }

    // Strip trailing slash, except root
    while (s.length() > 1 && s.endsWith("/")) {
      s = s.substring(0, s.length() - 1);
    }

    return s.isEmpty() ? "/" : s;
  }

  /** Provides read access to nodes for {@link AgentStateSnapshot}. */
  public Collection<EndpointNode> allNodes() {
    return Collections.unmodifiableCollection(nodes.values());
  }
}
