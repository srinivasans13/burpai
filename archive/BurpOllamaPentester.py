# -*- coding: utf-8 -*-
"""
Burp Suite Extension - Agentic Pentesting with Ollama
This is a proper Burp Suite extension that uses Ollama for AI-powered pentesting

Install instructions:
1. Download Jython from https://www.jython.org/download
2. In Burp Suite: Extender -> Options -> Python Environment -> Select jython.jar
3. In Burp Suite: Extender -> Add -> Select this file
"""

import json
from datetime import datetime
from java.net import URL, HttpURLConnection
from java.io import OutputStreamWriter, BufferedReader, InputStreamReader
from java.lang import String

# Burp API imports
from burp import IBurpExtender, IHttpListener, ITab, IMessageEditorController
from java.io import PrintWriter
from java.util import ArrayList
from javax.swing import JScrollPane, JTable, JPanel, JButton, JTextArea, JTextField, JLabel, JComboBox, BoxLayout, BorderFactory, JSplitPane
from javax.swing.table import DefaultTableModel
from java.awt import BorderLayout, Dimension


class OllamaClient:
    """Ollama API client using Java HTTP"""
    
    def __init__(self, base_url="http://localhost:11434", model="qwen3-coder-next:cloud"):
        self.base_url = base_url.rstrip('/')
        self.model = model
    
    def chat(self, messages, tools=None, temperature=0.7, max_tokens=4096):
        """Send a chat request to Ollama using Java HTTP"""
        url = URL(self.base_url + "/api/chat")
        conn = url.openConnection()
        conn.setRequestMethod("POST")
        conn.setDoOutput(True)
        conn.setRequestProperty("Content-Type", "application/json")
        
        payload = {
            "model": self.model,
            "messages": messages,
            "temperature": temperature,
            "stream": False
        }
        
        # Only include tools if explicitly requested (some models don't support it)
        # For now, don't send tools to avoid 500 errors
        # if tools:
        #     payload["tools"] = tools
        
        # Write request body
        writer = OutputStreamWriter(conn.getOutputStream())
        writer.write(json.dumps(payload))
        writer.flush()
        writer.close()
        
        # Read response
        response_code = conn.getResponseCode()
        if response_code == 200:
            reader = BufferedReader(InputStreamReader(conn.getInputStream()))
            response = ""
            line = reader.readLine()
            while line:
                response = response + line
                line = reader.readLine()
            reader.close()
            return json.loads(response)
        else:
            # Read error message
            error_msg = ""
            try:
                reader = BufferedReader(InputStreamReader(conn.getErrorStream()))
                line = reader.readLine()
                while line:
                    error_msg = error_msg + line
                    line = reader.readLine()
                reader.close()
            except:
                pass
            raise RuntimeError("Ollama API error: " + str(response_code) + " - " + error_msg)


class BurpExtender(IBurpExtender, IHttpListener, ITab, IMessageEditorController):
    """Main Burp Extension class"""
    
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        
        # Set extension name
        callbacks.setExtensionName("AI Pentest Agent (Ollama)")
        
        # Get stdout for logging
        self._stdout = PrintWriter(callbacks.getStdout(), True)
        self._stderr = PrintWriter(callbacks.getStderr(), True)
        
        # Initialize state
        self.conversation_history = []
        self.vulnerabilities_found = []
        self.request_log = []
        
        # Load config
        self.load_config()
        
        # Initialize Ollama client
        self.ollama = OllamaClient(
            base_url=self.ollama_base_url,
            model=self.ollama_model
        )
        
        # Setup UI
        self.create_ui()
        
        # Register listener
        callbacks.registerHttpListener(self)
        
        # Register tab
        callbacks.addSuiteTab(self)
        
        self._stdout.println("[OK] AI Pentest Agent loaded successfully!")
        self._stdout.println("  Model: " + self.ollama_model)
        self._stdout.println("  Target: " + self.target_url)
    
    def load_config(self):
        """Load configuration from file or use defaults"""
        try:
            with open('config.json', 'r') as f:
                config = json.load(f)
            
            self.llm_provider = config.get('llm_provider', 'ollama')
            self.ollama_base_url = config.get('ollama_base_url', 'http://localhost:11434')
            self.ollama_model = config.get('ollama_model', 'minimax-m2.5:cloud')
            self.target_url = config.get('target_base_url', 'http://localhost')
            self.burp_proxy = config.get('burp_proxy', 'http://127.0.0.1:8080')
            self.log_enabled = True
            
        except Exception as e:
            # Default config
            self.llm_provider = 'ollama'
            self.ollama_base_url = 'http://localhost:11434'
            self.ollama_model = 'minimax-m2.5:cloud'
            self.target_url = 'http://localhost'
            self.burp_proxy = 'http://127.0.0.1:8080'
            self.log_enabled = True
            self._stdout.println("Using default config: " + str(e))
    
    def create_ui(self):
        """Create the extension UI"""
        # Main panel
        self._panel = JPanel(BorderLayout())
        
        # Top controls panel
        controls_panel = JPanel()
        controls_panel.setLayout(BoxLayout(controls_panel, BoxLayout.Y_AXIS))
        
        # Config row
        config_row = JPanel()
        config_row.add(JLabel("Ollama URL:"))
        self.ollama_url_field = JTextField(self.ollama_base_url, 20)
        config_row.add(self.ollama_url_field)
        
        config_row.add(JLabel("Model:"))
        self.model_field = JTextField(self.ollama_model, 15)
        config_row.add(self.model_field)
        
        config_row.add(JLabel("Target:"))
        self.target_field = JTextField(self.target_url, 20)
        config_row.add(self.target_field)
        
        controls_panel.add(config_row)
        
        # Buttons row
        button_row = JPanel()
        
        self.connect_btn = JButton("Connect to Ollama", actionPerformed=self.connect_ollama)
        button_row.add(self.connect_btn)
        
        self.send_btn = JButton("Send Prompt", actionPerformed=self.send_prompt)
        button_row.add(self.send_btn)
        
        self.clear_btn = JButton("Clear History", actionPerformed=self.clear_history)
        button_row.add(self.clear_btn)
        
        self.log_btn = JButton("Toggle Logging", actionPerformed=self.toggle_logging)
        button_row.add(self.log_btn)
        
        controls_panel.add(button_row)
        
        # Prompt input
        prompt_panel = JPanel(BorderLayout())
        prompt_panel.add(JLabel("Prompt:"), BorderLayout.NORTH)
        self.prompt_area = JTextArea(3, 50)
        self.prompt_area.setText("Perform reconnaissance on the target. What endpoints can you find?")
        prompt_panel.add(JScrollPane(self.prompt_area), BorderLayout.CENTER)
        
        controls_panel.add(prompt_panel)
        
        # Response area
        response_panel = JPanel(BorderLayout())
        response_panel.add(JLabel("AI Response:"), BorderLayout.NORTH)
        self.response_area = JTextArea(10, 50)
        self.response_area.setEditable(False)
        response_panel.add(JScrollPane(self.response_area), BorderLayout.CENTER)
        
        # Request log table
        log_panel = JPanel(BorderLayout())
        log_panel.add(JLabel("Request Log:"), BorderLayout.NORTH)
        
        self.log_model = DefaultTableModel(
            ["#", "Method", "URL", "Status", "Time"], 0
        )
        self.log_table = JTable(self.log_model)
        log_panel.add(JScrollPane(self.log_table), BorderLayout.CENTER)
        
        # Split panes
        top_split = JSplitPane(JSplitPane.VERTICAL_SPLIT, controls_panel, response_panel)
        top_split.setResizeWeight(0.3)
        
        main_split = JSplitPane(JSplitPane.VERTICAL_SPLIT, top_split, log_panel)
        main_split.setResizeWeight(0.6)
        
        self._panel.add(main_split, BorderLayout.CENTER)
    
    def connect_ollama(self, event):
        """Connect to Ollama with new settings"""
        self.ollama_base_url = self.ollama_url_field.getText()
        self.ollama_model = self.model_field.getText()
        self.target_url = self.target_field.getText()
        
        try:
            self.ollama = OllamaClient(
                base_url=self.ollama_base_url,
                model=self.ollama_model
            )
            # Test connection
            test_msg = [{"role": "user", "content": "Hello"}]
            self.ollama.chat(test_msg)
            self._stdout.println("[OK] Connected to Ollama: " + self.ollama_model)
            self.response_area.setText("Connected to Ollama successfully!\n")
        except Exception as e:
            self._stdout.println("[ERROR] Connection failed: " + str(e))
            self.response_area.setText("Connection failed: " + str(e) + "\n")
    
    def send_prompt(self, event):
        """Send prompt to Ollama with tool calling loop"""
        if not self.ollama:
            self.response_area.setText("Not connected to Ollama. Click 'Connect to Ollama' first.\n")
            return
        
        prompt = self.prompt_area.getText()
        if not prompt.strip():
            return
        
        self._stdout.println("=== Starting prompt execution ===")
        self._stdout.println("Model: " + str(self.ollama.model))
        
        self.conversation_history.append({"role": "user", "content": prompt})
        
        # Define tools
        tools = self._get_tools_definition()
        self._stdout.println("Tools defined: " + str([t.get("name") for t in tools]))
        
        max_iterations = 10
        iteration = 0
        
        try:
            while iteration < max_iterations:
                iteration += 1
                self._stdout.println("--- Iteration " + str(iteration) + " ---")
                
                # Convert history
                messages = self._convert_history()
                messages.insert(0, {"role": "system", "content": self._get_system_prompt()})
                
                self._stdout.println("Sending to Ollama with " + str(len(messages)) + " messages")
                
                response = self.ollama.chat(messages=messages, tools=tools)
                
                self._stdout.println("Response received, processing...")
                
                # Process response - returns True if tool was called
                has_more = self._process_response(response)
                
                self._stdout.println("Has more tool calls: " + str(has_more))
                
                if not has_more:
                    self._stdout.println("No more tool calls, stopping")
                    break
                    
            if iteration >= max_iterations:
                self.response_area.append("\n[Max iterations reached]")
                
            self._stdout.println("=== Finished execution ===")
                
        except Exception as e:
            import traceback
            self._stdout.println("Error: " + str(e))
            traceback.print_exc()
            self.response_area.setText("Error: " + str(e) + "\n")
    
    def clear_history(self, event):
        """Clear conversation history"""
        self.conversation_history = []
        self.response_area.setText("History cleared.\n")
    
    def toggle_logging(self, event):
        """Toggle request logging"""
        self.log_enabled = not self.log_enabled
        status = "enabled" if self.log_enabled else "disabled"
        self._stdout.println("Logging " + status)
    
    def _get_tools_definition(self):
        """Define tools for the agent"""
        return [
            {
                "name": "execute_http_request",
                "description": "Execute an HTTP request against the target. Use 'url' for full URLs or 'endpoint' for paths relative to the target base URL.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "method": {
                            "type": "string",
                            "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"],
                            "description": "HTTP method (GET, POST, etc.)"
                        },
                        "url": {
                            "type": "string",
                            "description": "Full URL to request (e.g., https://example.com/api/login)"
                        },
                        "endpoint": {
                            "type": "string",
                            "description": "Path relative to target base URL (e.g., /api/login)"
                        },
                        "headers": {
                            "type": "object",
                            "description": "HTTP headers as key-value pairs"
                        },
                        "body": {
                            "type": "string",
                            "description": "Request body (JSON, form data, etc.)"
                        },
                        "purpose": {
                            "type": "string",
                            "description": "WHY you're making this request - what are you testing?"
                        },
                        "expected": {
                            "type": "string",
                            "description": "What you EXPECT to discover or learn from this request"
                        }
                    },
                    "required": ["method", "purpose", "expected"]
                }
            },
            {
                "name": "report_vulnerability",
                "description": "Report a vulnerability",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "severity": {"type": "string", "enum": ["Critical", "High", "Medium", "Low"]},
                        "location": {"type": "string"},
                        "description": {"type": "string"},
                        "impact": {"type": "string"},
                        "poc": {"type": "string"},
                        "remediation": {"type": "string"}
                    },
                    "required": ["name", "severity", "location", "description"]
                }
            }
        ]
    
    def _get_system_prompt(self):
        """Get the system prompt"""
        # Get current target from UI field
        current_target = self.target_field.getText()
        return """You are an expert autonomous penetration testing AI agent.

Your mission: Systematically discover and exploit web vulnerabilities.

CRITICAL: You MUST make actual HTTP requests to test the target. Do not just describe what you would do - actually DO it.

When you need to make a request, respond with a JSON object in this EXACT format (include it and nothing else):

[[REQUEST]]
{
  "method": "GET",
  "endpoint": "/api/users",
  "purpose": "testing for exposed API endpoints",
  "expected": "list of users or error"
}
[[END]]

The target base URL is: """ + current_target + """

Example conversation:
User: Test the login endpoint
You: [[REQUEST]]
{"method": "POST", "endpoint": "/login", "purpose": "Check for SQL injection", "expected": "Login bypass or error"}
[[END]]

Now start by exploring the target. Make your first request now.
"""
    
    def _convert_history(self):
        """Convert conversation history"""
        converted = []
        for msg in self.conversation_history:
            content = msg.get("content", "")
            if isinstance(content, list):
                tool_text = ""
                for item in content:
                    if item.get("type") == "tool_result":
                        tool_text = tool_text + "\n[Tool Result]:\n" + item.get('content', '') + "\n"
                content = tool_text
            converted.append({"role": msg.get("role", "user"), "content": str(content)})
        return converted
    
    def _process_response(self, response):
        """Process Ollama response and handle tool calls. Returns True if tool was called."""
        # Debug: Log full response
        self._stdout.println("[DEBUG] Full response keys: " + str(response.keys()))
        
        message = response.get("message", {})
        content = message.get("content", "") if message else ""
        tool_calls = message.get("tool_calls", []) if message else []
        
        # Debug: Log tool calls found
        self._stdout.println("[DEBUG] Tool calls: " + str(type(tool_calls)) + " len=" + str(len(tool_calls) if tool_calls else 0))
        
        has_tool_call = False
        
        # If no tool_calls in proper format, try to parse from content
        if not tool_calls and content:
            parsed = self._parse_tool_calls_from_content(content)
            if parsed:
                tool_calls = parsed
                self._stdout.println("[DEBUG] Parsed tool calls from content!")
        
        self.response_area.setText(content + "\n\n")
        
        for tool_call in tool_calls:
            has_tool_call = True
            
            # Handle different tool_call formats
            if isinstance(tool_call, dict):
                if "function" in tool_call:
                    func = tool_call.get("function", {})
                    name = func.get("name")
                    args = func.get("arguments", {})
                else:
                    name = tool_call.get("name")
                    args = tool_call.get("arguments", {})
            else:
                continue
            
            self._stdout.println("Tool call: " + str(name))
            
            if name == "execute_http_request":
                # Support both 'url' (full URL) and 'endpoint' (path)
                url_arg = args.get("url")
                endpoint_arg = args.get("endpoint", "/")
                
                result = self._execute_http_request(
                    method=args.get("method", "GET"),
                    url=url_arg,
                    endpoint=endpoint_arg,
                    headers=args.get("headers", {}),
                    body=args.get("body"),
                    purpose=args.get("purpose", ""),
                    expected=args.get("expected", "")
                )
                # Add to conversation
                self.conversation_history.append({
                    "role": "assistant",
                    "content": "[Calling " + name + "]"
                })
                self.conversation_history.append({
                    "role": "user",
                    "content": "[Tool Result]:\n" + json.dumps(result, indent=2)
                })
                
            elif name == "report_vulnerability":
                self.vulnerabilities_found.append(args)
                self._stdout.println("[VULN] " + args.get('name') + " [" + args.get('severity') + "]")
                
                self.conversation_history.append({
                    "role": "assistant",
                    "content": "[Calling " + name + "]"
                })
                self.conversation_history.append({
                    "role": "user",
                    "content": "Vulnerability logged"
                })
        
        return has_tool_call
    
    def _parse_tool_calls_from_content(self, content):
        """Try to parse tool calls from response content if model didn't use proper format"""
        import re
        
        tool_calls = []
        
        # NEW: Look for [[REQUEST]] ... [[END]] format
        request_match = re.search(r'\[\[REQUEST\]\](.*?)\[\[END\]\]', content, re.DOTALL)
        if request_match:
            json_str = request_match.group(1).strip()
            self._stdout.println("[DEBUG] Found [[REQUEST]] block: " + json_str[:100])
            try:
                args = json.loads(json_str)
                tool_calls.append({
                    "function": {
                        "name": "execute_http_request",
                        "arguments": args
                    }
                })
                return tool_calls
            except json.JSONDecodeError as e:
                self._stdout.println("[DEBUG] Failed to parse JSON: " + str(e))
        
        # Try to find JSON objects in the content that look like tool calls
        # Look for patterns like: {"name": "execute_http_request", "arguments": {...}}
        # Pattern 1: Look for tool call JSON
        patterns = [
            r'\{[^{}]*"name"\s*:\s*"([^"]+)"[^{}]*"arguments"\s*:\s*(\{[^{}]*\})[^{}]*\}',
            r'"execute_http_request"\s*:\s*\{[^}]*\}',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, content, re.DOTALL)
            for match in matches:
                if len(match) >= 2:
                    tool_name = match[0] if isinstance(match, tuple) else "execute_http_request"
                    args_str = match[1] if isinstance(match, tuple) else match
                    try:
                        args = json.loads(args_str)
                        tool_calls.append({
                            "function": {
                                "name": tool_name,
                                "arguments": args
                            }
                        })
                    except:
                        pass
        
        # Also check if content mentions tool execution
        if "execute_http_request" in content.lower() and ("{" in content or "}" in content):
            # Try to extract any JSON that looks like tool args
            # Look for method, endpoint, purpose, expected
            method_match = re.search(r'"method"\s*:\s*"([^"]+)"', content)
            endpoint_match = re.search(r'"endpoint"\s*:\s*"([^"]+)"', content)
            url_match = re.search(r'"url"\s*:\s*"([^"]+)"', content)
            purpose_match = re.search(r'"purpose"\s*:\s*"([^"]+)"', content)
            expected_match = re.search(r'"expected"\s*:\s*"([^"]+)"', content)
            
            if method_match or endpoint_match or url_match:
                args = {}
                if method_match:
                    args["method"] = method_match.group(1)
                if endpoint_match:
                    args["endpoint"] = endpoint_match.group(1)
                if url_match:
                    args["url"] = url_match.group(1)
                if purpose_match:
                    args["purpose"] = purpose_match.group(1)
                if expected_match:
                    args["expected"] = expected_match.group(1)
                
                tool_calls.append({
                    "function": {
                        "name": "execute_http_request",
                        "arguments": args
                    }
                })
        
        return tool_calls if tool_calls else None
    
    def _execute_http_request(self, method, url=None, endpoint=None, headers=None, body=None, purpose=None, expected=None):
        """Execute HTTP request through Burp"""
        # Use full URL if provided, otherwise combine target + endpoint
        if url:
            full_url = url
            # Extract path for logging
            path = url
        elif endpoint:
            full_url = self.target_url + endpoint
            path = endpoint
        else:
            full_url = self.target_url
            path = "/"
        
        if headers is None:
            headers = {}
        if purpose is None:
            purpose = ""
        if expected is None:
            expected = ""
        
        self._stdout.println("[REQUEST] " + method + " " + full_url)
        self._stdout.println("  Purpose: " + purpose)
        
        try:
            # Parse the URL properly
            from java.net import URL
            parsed_url = URL(full_url)
            host = parsed_url.getHost()
            port = parsed_url.getPort()
            if port == -1:
                port = 443 if parsed_url.getProtocol() == "https" else 80
            
            # Prepare headers
            header_list = []
            if isinstance(headers, dict):
                for k, v in headers.items():
                    header_list.append(str(k) + ": " + str(v))
            elif isinstance(headers, list):
                header_list = headers
            
            # Ensure we have at least a Host header
            has_host = False
            for h in header_list:
                if h.lower().startswith("host:"):
                    has_host = True
                    break
            if not has_host:
                header_list.insert(0, "Host: " + host)
            
            # Build the request body
            body_bytes = b''
            if body:
                body_bytes = body.encode('utf-8')
            
            # Use Burp's helpers to build the request
            req_bytes = self._helpers.buildHttpMessage(header_list, body_bytes)
            
            # Make request through Burp
            self._stdout.println("  Making HTTP request via Burp...")
            response = self._callbacks.makeHttpRequest(host, port, parsed_url.getProtocol() == "https", req_bytes)
            
            if response is None or len(response) == 0:
                self._stdout.println("[ERROR] No response received")
                return {"error": "No response received", "status_code": 0, "body": ""}
            
            # Get response details
            response_info = self._helpers.analyzeResponse(response)
            status_code = response_info.getStatusCode()
            response_headers = response_info.getHeaders()
            response_body_bytes = response[response_info.getBodyOffset():]
            response_body = response_body_bytes.tostring() if response_body_bytes else ""
            
            self._stdout.println("[RESPONSE] Status: " + str(status_code))
            
            # Log to table - use SwingUtilities to ensure thread safety
            if self.log_enabled:
                self._log_request_safe(method, path, status_code)
            
            # Convert headers to dict
            headers_dict = {}
            for h in response_headers:
                if ':' in h:
                    key, val = h.split(':', 1)
                    headers_dict[key.strip()] = val.strip()
            
            return {
                "status_code": status_code,
                "headers": headers_dict,
                "body": response_body[:5000],
                "purpose": purpose,
                "expected": expected
            }
            
        except Exception as e:
            import traceback
            self._stdout.println("[ERROR] Request failed: " + str(e))
            traceback.print_exc()
            return {"error": str(e), "status_code": 0, "body": ""}
    
    def _log_request_safe(self, method, endpoint, status):
        """Log request to table (thread-safe)"""
        try:
            from javax.swing import SwingUtilities
            SwingUtilities.invokeLater(lambda: self.log_request(method, endpoint, status))
        except:
            # Fallback if SwingUtilities fails
            self.log_request(method, endpoint, status)
    
    def log_request(self, method, endpoint, status):
        """Log request to table"""
        self.log_model.addRow([
            self.log_model.getRowCount() + 1,
            method,
            endpoint,
            status,
            datetime.now().strftime("%H:%M:%S")
        ])
        self.request_log.append({
            "method": method,
            "endpoint": endpoint,
            "status": status
        })
    
    # ITab methods
    def getTabCaption(self):
        return "AI Pentester"
    
    def getUiComponent(self):
        return self._panel
    
    # IHttpListener methods
    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        # Could add auto-analysis of traffic here
        pass
    
    # IMessageEditorController methods  
    def getHttpService(self):
        return None
    
    def getRequest(self):
        return None
    
    def getResponse(self):
        return None
